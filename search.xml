<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[NOIP2017 D1 T2] 时间复杂度（栈，模拟）]]></title>
    <url>%2F2018%2F04%2F14%2FNOIP2017-D1-T2-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%88%E6%A0%88%EF%BC%8C%E6%A8%A1%E6%8B%9F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并 给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序， 于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。 A++语言的循环结构如下：123F i x y 循环体E 其中F i x y表示新建变量 $i$（变量 $i$ 不可与未被销毁的变量重名）并初始化为 $x$， 然后判断 $i$ 和 $y$ 的大小关系，若 $i$ 小于等于 $y$ 则进入循环，否则不进入。每次循环结束后 $i$ 都会被修改成 $i +1$，一旦 $i$ 大于 $y$ 终止循环。 $x$ 和 $y$ 可以是正整数（$x$ 和 $y$ 的大小关系不定）或变量 $n$。$n$ 是一个表示数据规模的变量，在时间复杂度计算中需保留该变量而不能将其视为常数，该数远大于 100。 “E”表示循环体结束。循环体结束时，这个循环体新建的变量也被销毁。 注：本题中为了书写方便，在描述复杂度时，使用大写英文字母“O”表示通常意义下“Θ”的概念。 输入输入文件第一行一个正整数 $t$，表示有 $t$（$t \le 10$）个程序需要计算时间复杂度。 每个程序我们只需抽取其中 F i x y和E即可计算时间复杂度。注意：循环结构允许嵌套。 接下来每个程序的第一行包含一个正整数 $L$ 和一个字符串，$L$ 代表程序行数，字符串表示这个程序的复杂度，O(1)表示常数复杂度，O(n^w)表示复杂度为$n^w$，其中w是一个小于100的正整数（输入中不包含引号），输入保证复杂度只有O(1)和O(n^w) 两种类型。 接下来 $L$ 行代表程序中循环结构中的F i x y或者 E。 程序行若以F开头，表示进入一个循环，之后有空格分离的三个字符（串）i x y， 其中 $i$ 是一个小写字母（保证不为$n$），表示新建的变量名，$x$ 和 $y$ 可能是正整数或 $n$ ，已知若为正整数则一定小于 100。 程序行若以E开头，则表示循环体结束。 输出输出文件共 $t$ 行，对应输入的 $t$ 个程序，每行输出”Yes”或”No”或者”ERR”（输出中不包含引号），若程序实际复杂度与输入给出的复杂度一致则输出”Yes”，不一致则输出”No”，若程序有语法错误（其中语法错误只有: ① F 和 E 不匹配 ②新建的变量与已经存在但未被销毁的变量重复两种情况），则输出”ERR” 。 注意：即使在程序不会执行的循环体中出现了语法错误也会编译错误，要输出 ERR。 样例输入1234567891011121314151617181920212223242526272829303132333482 O(1)F i 1 1E2 O(n^1)F x 1 nE1 O(1)F x 1 n4 O(n^2)F x 5 nF y 10 nEE4 O(n^2)F x 9 nEF y 2 nE4 O(n^1)F x 9 nF y n 4EE4 O(1)F y n 4F x 9 nEE4 O(n^2)F x 1 nF x 1 10EE 样例输出12345678YesYesERRYesNoYesYesERR 输入输出样例解释第一个程序 $i$ 从 1 到 1 是常数复杂度。第二个程序 $x$ 从 1 到 $n$ 是 $n$ 的一次方的复杂度。第三个程序有一个 F 开启循环却没有 E 结束，语法错误。第四个程序二重循环，$n$ 的平方的复杂度。第五个程序两个一重循环，$n$ 的一次方的复杂度。第六个程序第一重循环正常，但第二重循环开始即终止（因为$n$远大于100，100大于4）。第七个程序第一重循环无法进入，故为常数复杂度。第八个程序第二重循环中的变量 $x$ 与第一重循环中的变量重复，出现语法错误②，输出 ERR。 数据规模与约定对于 30%的数据：不存在语法错误，数据保证小明给出的每个程序的前 $L/2$ 行一定为以 F 开头的语句，第 $L/2+1$ 行至第 $L$ 行一定为以 $E$ 开头的语句，$L \le 10$，若 $x$、$y$ 均 为整数，$x$ 一定小于 $y$，且只有 $y$ 有可能为 $n$。对于 50%的数据：不存在语法错误，$L \le 100$，且若 $x$、$y$ 均为整数，$x$ 一定小于 $y$， 且只有 $y$ 有可能为 $n$。对于 70%的数据：不存在语法错误，$L \le 100$。对于 100%的数据：$L \le 100$。 解题思路由于循环必须要让F与E配对，联想到括号匹配问题，所以用栈来模拟。为了方便计算，我在栈里维护了三个值，分别表示当前循环所用变量名、程序执行到当前循环时的复杂度、当前循环是否处于被跳过的循环之中（即程序不会执行到）。在压栈时维护一下这三个值就好了，最后的复杂度即为最大的可被执行到的复杂度。最后，注意一下关于字符串的读入处理就好了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int T, L, kind, w;//kind == 1:O(1); kind == 2: O(n^w)int top, ans;char com[100], opt[100];bool used[1000], err;struct Node&#123; char ch; int c;//执行至此的时间复杂度 bool dir;//是否处于直接跳过的循环中 &#125;sta[1000];void solve()&#123; scanf("%d ", &amp;L); cin.getline(com, 99); if(com[2] == '1') kind = 1; else&#123; int now = 4; while(com[now] &gt;= '0' &amp;&amp; com[now] &lt;= '9')&#123; w = w * 10 + com[now] - '0'; now++; &#125; kind = 2; &#125; for(int i = 1; i &lt;= L; i++)&#123; cin.getline(opt, 99); if(err) continue; if(opt[0] == 'F')&#123; if(used[opt[2]])&#123; err = 1; continue; &#125; used[opt[2]] = 1; int now = 4, l = 0, r = 0, pre = 0, nxt = 0; while((opt[now] &gt;= '0' &amp;&amp; opt[now] &lt;= '9') || opt[now] == 'n')&#123; if(opt[now] == 'n') pre = 1; else l = l * 10 + opt[now] - '0'; now++; &#125; now++; while((opt[now] &gt;= '0' &amp;&amp; opt[now] &lt;= '9') || (opt[now] == 'n'))&#123; if(opt[now] == 'n') nxt = 1; else r = r * 10 + opt[now] - '0'; now++; &#125; if(pre == 1 &amp;&amp; nxt == 1)&#123; sta[top+1] = (Node)&#123;opt[2], sta[top].c, sta[top].dir&#125;; top++; if(sta[top].dir == 0) ans = max(ans, sta[top].c); &#125; else if(pre == 1 &amp;&amp; nxt == 0)&#123; sta[top+1] = (Node)&#123;opt[2], sta[top].c, 1&#125;; top++; &#125; else if(pre == 0 &amp;&amp; nxt == 1)&#123; sta[top+1] = (Node)&#123;opt[2], sta[top].c + 1, sta[top].dir&#125;; top++; if(sta[top].dir == 0) ans = max(ans, sta[top].c); &#125; else if(pre == 0 &amp;&amp; nxt == 0)&#123; if(l &lt;= r)&#123; sta[top+1] = (Node)&#123;opt[2], sta[top].c, sta[top].dir&#125;; top++; if(sta[top].dir == 0) ans = max(ans, sta[top].c); &#125; else&#123; sta[top+1] = (Node)&#123;opt[2], sta[top].c, 1&#125;; top++; &#125; &#125; &#125; else if(opt[0] == 'E')&#123; if(top == 0) err = 1; else&#123; used[sta[top].ch] = 0; top--; &#125; &#125; &#125; if(top) err = 1; if(err)&#123; puts("ERR"); return; &#125; if(kind == 1 &amp;&amp; ans == 0)&#123; puts("Yes"); return; &#125; if(kind == 2 &amp;&amp; w == ans)&#123; puts("Yes"); return; &#125; puts("No"); return;&#125;void init()&#123; memset(sta, 0, sizeof sta); top = 0; memset(com, 0, sizeof com); memset(opt, 0, sizeof opt); memset(used, 0, sizeof used); err = 0; ans = 0; kind = w = 0;&#125;int main()&#123; scanf("%d", &amp;T); while(T--)&#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>模拟，数据结构，栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2017 D1 T1] 小凯的疑惑（数论）]]></title>
    <url>%2F2018%2F04%2F14%2FNOIP2017-D1-T1-%E5%B0%8F%E5%87%AF%E7%9A%84%E7%96%91%E6%83%91%EF%BC%88%E6%95%B0%E8%AE%BA%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述小凯手中有两种面值的金币，两种面值均为正整数且彼此互素。每种金币小凯都有 无数个。在不找零的情况下，仅凭这两种金币，有些物品他是无法准确支付的。现在小凯想知道在无法准确支付的物品中，最贵的价值是多少金币？注意：输入数据保证存在小凯无法准确支付的商品。 输入输入数据仅一行，包含两个正整数 $a$ 和 $ b $，它们之间用一个空格隔开，表示小凯手 中金币的面值。 输出输出文件仅一行，一个正整数 $ N $，表示不找零的情况下，小凯用手中的金币不能准确支付的最贵的物品的价值。 样例输入13 7 样例输出111 样例说明小凯手中有面值为3和7的金币无数个，在不找零的前提下无法准确支付价值为1、 2、4、5、8、11 的物品，其中最贵的物品价值为 11，比 11 贵的物品都能买到，比如：$ 12 = 3 \times 4 + 7 \times 0 $$ 13 = 3 \times 2 + 7 \times 1 $$ 14 = 3 \times 0 + 7 \times 2 $$ 15 = 3 \times 5 + 7 \times 0 $ 数据范围与约定对于 30%的数据： $ 1 \le a,b \le 50 $。对于 60%的数据： $ 1 \le a,b \le 10^4 $。对于 100%的数据：$ 1 \le a,b \le 10^9 $。 解题思路因为$ (a,b) = 1 $，所以$ {a, 2a, 3a, …, (b-1)a} $为模$ b $的完全剩余系。设$ T $是一个$ a, b $无法表示的数且$ T \equiv ka(mod \ b) $，$ (1 \le k \le b-1) $.若$ T \ge ka $，则$ T $一定可以表示为$ ka+nb $，$ (n \ge 0) $，所以$ T &lt; ka $，则此时$ T $最大为$ ka-b $.显然，当$ k $最大时$ T $最大，所以$ T = (b-1)a-b = ab - a - b $. Code123456789#include&lt;cstdio&gt;using namespace std;typedef long long LL;LL a, b;int main()&#123; scanf("%lld%lld", &amp;a, &amp;b); printf("%lld", a * b - a - b); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello, world!]]></title>
    <url>%2F2018%2F04%2F07%2FHello-world-0%2F</url>
    <content type="text"><![CDATA[搞了一个下午+一个晚上，终于把hexo+github博客搭建起来了……（尚待后续优化） 这个博客用于几个板块：OI/ACM 学习笔记（主要），学习总结，随笔，其他 12break?continue!]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
