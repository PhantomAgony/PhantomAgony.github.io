<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[SDOI2011]染色（树链剖分，线段树）]]></title>
    <url>%2F2018%2F04%2F28%2FSDOI2011-%E6%9F%93%E8%89%B2%EF%BC%88%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%EF%BC%8C%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目Description给定一棵有n个节点的无根树和m个操作，操作有2类：1、将节点a到节点b路径上所有点都染成颜色c；2、询问节点a到节点b路径上的颜色段数量（连续相同颜色被认为是同一段），如“112221”由3段组成：“11”、“222”和“1”。请你写一个程序依次完成这m个操作。 Input第一行包含2个整数n和m，分别表示节点数和操作数；第二行包含n个正整数表示n个节点的初始颜色下面 n-1 行每行包含两个整数x和y，表示x和y之间有一条无向边。下面 m 行每行描述一个操作：“C a b c”表示这是一个染色操作，把节点a到节点b路径上所有点（包括a和b）都染成颜色c；“Q a b”表示这是一个询问操作，询问节点a到节点b（包括a和b）路径上的颜色段数量。 Output对于每个询问操作，输出一行答案。 Sample Input1234567891011126 52 2 1 2 1 11 21 32 42 52 6Q 3 5C 2 1 1Q 3 5C 5 1 2Q 3 5 Sample Output123312 HINT$N \leq 10^5, M \leq 10^5$，所有的颜色C为整数且在$[0, 10^9]$之间。 解题思路这道题思路应该是很好想到的——树链剖分+线段树显然，合并两个颜色段时，如果合并点两侧颜色相同，那么颜色段数量为左右两段数量之和再减一，否则就是它们的和。根据这个基本性质——线段树维护3个值：颜色段数量(cnt)、左端颜色(lcol)、右端颜色(rcol)，于是tr[id].cnt = tr[lid].cnt + tr[rid].cnt - (tr[lid].rcol == tr[rid].lcol);树链剖分询问时（即往上“跳”时），记录一下上一次询问的端点颜色，如果本次询问的相应端点颜色在合并点处与上次询问端点颜色相等，就要减一。至此本题解决。 复杂度$O(n\log ^2n)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 100005;int n, m, a[N], u, v, qa, qb, qc;char opt[2];struct Edge&#123; int nxt, to;&#125;edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to)&#123; edge[++edgeNum].nxt = head[from]; edge[edgeNum].to = to; head[from] = edgeNum;&#125;int fa[N], dep[N], size[N], son[N];void dfs1(int x, int f, int depth)&#123; fa[x] = f, dep[x] = depth, size[x] = 1, son[x] = 0; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(edge[i].to == f) continue; dfs1(edge[i].to, x, depth+1); size[x] += size[edge[i].to]; if(size[edge[i].to] &gt; size[son[x]]) son[x] = edge[i].to; &#125;&#125;int belong[N], st[N], ed[N], dfsClock, fun[N];void dfs2(int x, int top)&#123; st[x] = ++dfsClock, fun[dfsClock] = x; belong[x] = top; if(son[x]) dfs2(son[x], top); for(int i = head[x]; i; i = edge[i].nxt)&#123; if(edge[i].to == fa[x] || edge[i].to == son[x]) continue; dfs2(edge[i].to, edge[i].to); &#125; ed[x] = dfsClock;&#125;#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((tr[id].l+tr[id].r)&gt;&gt;1)struct segTree&#123; int l, r, lcol, rcol, cnt, cov; segTree()&#123; l = r = lcol = rcol = cnt = cov = 0; &#125;&#125;tr[N&lt;&lt;2];struct &#123; inline void pushup(int id)&#123; tr[id].cnt = tr[lid].cnt + tr[rid].cnt - (tr[lid].rcol == tr[rid].lcol); tr[id].lcol = tr[lid].lcol; tr[id].rcol = tr[rid].rcol; &#125; inline void pushdown(int id)&#123; if(tr[id].l == tr[id].r) return; if(tr[id].cov)&#123; int t = tr[id].cov; tr[lid].cov = tr[rid].cov = t; tr[lid].lcol = tr[lid].rcol = t; tr[rid].lcol = tr[rid].rcol = t; tr[lid].cnt = tr[rid].cnt = 1; tr[id].cov = 0; &#125; &#125; void build(int id, int l, int r)&#123; tr[id].l = l, tr[id].r = r; if(tr[id].l == tr[id].r)&#123; tr[id].cnt = 1; tr[id].lcol = tr[id].rcol = a[fun[l]]; return; &#125; build(lid, l, mid); build(rid, mid+1, r); pushup(id); &#125; void cover(int id, int l, int r, int c)&#123; pushdown(id); if(tr[id].l == l &amp;&amp; tr[id].r == r)&#123; tr[id].cov = c; tr[id].cnt = 1; tr[id].lcol = tr[id].rcol = c; return; &#125; if(r &lt;= mid) cover(lid, l, r, c); else if(l &gt; mid) cover(rid, l, r, c); else cover(lid, l, mid, c), cover(rid, mid+1, r, c); pushup(id); &#125; segTree query(int id, int l, int r)&#123; pushdown(id); if(tr[id].l == l &amp;&amp; tr[id].r == r) return tr[id]; if(r &lt;= mid) return query(lid, l, r); else if(l &gt; mid) return query(rid, l, r); else&#123; segTree t1 = query(lid, l, mid), t2 = query(rid, mid+1, r), t; t.cnt = t1.cnt + t2.cnt - (t1.rcol == t2.lcol); t.lcol = t1.lcol, t.rcol = t2.rcol; return t; &#125; &#125;&#125;seg;void cover(int u, int v, int c)&#123; while(belong[u] != belong[v])&#123; if(dep[belong[u]] &lt; dep[belong[v]]) swap(u, v); seg.cover(1, st[belong[u]], st[u], c); u = fa[belong[u]]; &#125; if(dep[u] &gt; dep[v]) swap(u, v); seg.cover(1, st[u], st[v], c);&#125;int query(int u, int v)&#123; int ans = 0, lastu = 0, lastv = 0; while(belong[u] != belong[v])&#123; if(dep[belong[u]] &lt; dep[belong[v]]) swap(u, v), swap(lastu, lastv); segTree t = seg.query(1, st[belong[u]], st[u]); ans += t.cnt - (t.rcol == lastu); lastu = t.lcol; u = fa[belong[u]]; &#125; if(dep[u] &gt; dep[v]) swap(u, v), swap(lastu, lastv); segTree t = seg.query(1, st[u], st[v]); ans += t.cnt - (t.lcol == lastu) - (t.rcol == lastv); return ans;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]), a[i]++; for(int i = 1; i &lt; n; i++)&#123; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v); addEdge(v, u); &#125; dfs1(1, 1, 1); dfs2(1, 1); seg.build(1, 1, n); while(m--)&#123; scanf("%s", opt); if(opt[0] == 'C')&#123; scanf("%d%d%d", &amp;qa, &amp;qb, &amp;qc); qc++; cover(qa, qb, qc); &#125; else if(opt[0] == 'Q')&#123; scanf("%d%d", &amp;qa, &amp;qb); printf("%d\n", query(qa, qb)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>SDOI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>图论</tag>
        <tag>树（图论）</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点分治学习笔记]]></title>
    <url>%2F2018%2F04%2F22%2F%E7%82%B9%E5%88%86%E6%B2%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[简介点分治主要解决树上路径问题，其主要思想是把一颗有根树以根为分治点分为一个森林（其实就是各个子树），解决经过当前根的路径后在子树里继续分治，从而将问题“分而治之”。 这里面，根的选择非常重要。为了保证复杂度，我们的分治点应该尽可能的“居中”，所以分治点一般选择正在处理的树的重心。 套路 找到当前树的重心作为根 解决通过这个根的路径的答案（一般有两种方法，一种是通过与子树容斥，一种是直接计算子树贡献） 递归解决子树 实现求重心12345678910111213//root = 0, mxson[0] = INF, sum = n;//root = 0, mxson[0] = INF, sum = size[edge[i].to];void findRoot(int x, int f)&#123; size[x] = 1, mxson[x] = 0; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to] || edge[i].to == f) continue; findRoot(edge[i].to, x); size[x] += size[edge[i].to]; mxson[x] = max(mxson[x], size[edge[i].to]); &#125; mxson[x] = max(mxson[x], sum - size[x]); if(mxson[x] &lt; mxson[root]) root = x;&#125; size[]是子树大小，mxson[]是最大子树大小，root是重心，sum是当前整颗树的大小注意每次 findRoot() 前要初始化 root 和 sum 分治计算1234567891011void solve(int x)&#123; cal(x);//如果此处计算时将子树中一些不合法的路径的贡献也算进去了，那么需要容斥，即在下方*处减掉子树贡献；如果不容斥，就直接利用每颗子树的信息计算答案 vis[x] = 1; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to]) continue; cal(edge[i].to);//* root = 0, sum = size[edge[i].to], mxson[0] = INF; findRoot(edge[i].to, 0); solve(root); &#125;&#125; vis[]标记此点是否计算过，cal()计算以x为根、经过根的路径的答案 注意事项不要再分治时用memset O(n) 地进行初始化，否则点分治好不容易保证的复杂度就被毁了。 练习poj1741 tree题意给一棵树，边有边权，问两点之间的距离小于等于K的点对有多少个。题解点分治时用容斥做：计算以x为根的子树时直接将求得的dis排序后O(n)求答案，然后再减去每个子树中被统计了的不合法答案Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int INF = 1e9;const int N = 10005;int n, k, u, v, p;struct Edge&#123; int nxt, to, dis;&#125;edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to, int dis)&#123; edge[++edgeNum].nxt = head[from]; edge[edgeNum].to = to; edge[edgeNum].dis = dis; head[from] = edgeNum;&#125;bool vis[N];int root, sum, size[N], mxson[N];void findRoot(int x, int f)&#123; size[x] = 1, mxson[x] = 0; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(edge[i].to == f || vis[edge[i].to]) continue; findRoot(edge[i].to, x); size[x] += size[edge[i].to]; mxson[x] = max(mxson[x], size[edge[i].to]); &#125; mxson[x] = max(mxson[x], sum - size[x]); if(mxson[x] &lt; mxson[root]) root = x;&#125;int dis[N], ans;void getDis(int x, int f, int d)&#123; dis[++dis[0]] = d; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(edge[i].to == f || vis[edge[i].to]) continue; getDis(edge[i].to, x, d + edge[i].dis); &#125;&#125;int cal(int x, int d)&#123; int res = 0; for(int i = 1; i &lt;= dis[0]; i++) dis[i] = 0; dis[0] = 0; getDis(x, 0, d); sort(dis+1, dis+dis[0]+1); int l = 1, r = dis[0]; while(l &lt; r)&#123; if(dis[l] + dis[r] &lt;= k) res += r - l, l++; else r--; &#125; return res;&#125;void solve(int x)&#123; ans += cal(x, 0); vis[x] = 1; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to]) continue; ans -= cal(edge[i].to, edge[i].dis); root = 0, mxson[0] = INF, sum = size[edge[i].to]; findRoot(edge[i].to, 0); solve(root); &#125;&#125;void init()&#123; memset(edge, 0, sizeof edge); memset(head, 0, sizeof head); edgeNum = 0; root = sum = ans = 0; memset(size, 0, sizeof size); memset(mxson, 0, sizeof mxson); memset(vis, 0, sizeof vis);&#125;int main()&#123; while(1)&#123; scanf("%d%d", &amp;n, &amp;k); if(n == 0 &amp;&amp; k == 0) break; init(); for(int i = 1; i &lt; n; i++)&#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;p); addEdge(u, v, p); addEdge(v, u, p); &#125; sum = n, root = 0, mxson[0] = INF; findRoot(1, 0); solve(root); printf("%d\n", ans); &#125; return 0;&#125; luogu3806 【模板】点分治1题意给定一棵有n个点的树，多次询问树上距离为k的点对是否存在。题解和上一题差不多，也是容斥，只不过我们把所有k的答案一次性求出来，每次询问O(1)回答。Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;map&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int INF = 1e9;const int N = 10005;int n, m, k[105], u, v, p;struct Edge&#123; int nxt, to, dis;&#125;edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to, int dis)&#123; edge[++edgeNum].nxt = head[from]; edge[edgeNum].to = to; edge[edgeNum].dis = dis; head[from] = edgeNum;&#125;int size[N], mxson[N], dis[N], root, sum;bool vis[N];map&lt;int, int&gt; cnt;void findRoot(int x, int f)&#123; size[x] = 1, mxson[x] = 0; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to] || edge[i].to == f) continue; findRoot(edge[i].to, x); size[x] += size[edge[i].to]; mxson[x] = max(mxson[x], size[edge[i].to]); &#125; mxson[x] = max(mxson[x], sum - size[x]); if(mxson[x] &lt; mxson[root]) root = x;&#125;void getDis(int x, int f, int d)&#123; dis[++dis[0]] = d; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(edge[i].to == f || vis[edge[i].to]) continue; getDis(edge[i].to, x, d + edge[i].dis); &#125;&#125;void cal(int x, int d, int fl)&#123; for(int i = 1; i &lt;= dis[0]; i++) dis[i] = 0; dis[0] = 0; getDis(x, 0, d); sort(dis+1, dis+dis[0]+1); for(int i = 1; i &lt;= dis[0]; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(dis[i] + dis[i] &gt; k[j]) continue; int l = lower_bound(dis+i, dis+dis[0]+1, k[j]-dis[i]) - dis; if(dis[l] + dis[i] != k[j]) continue; int r = upper_bound(dis+i, dis+dis[0]+1, k[j]-dis[i]) - dis; cnt[k[j]] += (r - l) * fl; &#125; &#125;&#125;void solve(int x)&#123; cal(x, 0, 1); vis[x] = 1; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to]) continue; cal(edge[i].to, edge[i].dis, -1); root = 0, sum = size[edge[i].to], mxson[0] = INF; findRoot(edge[i].to, 0); solve(root); &#125;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt; n; i++)&#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;p); addEdge(u, v, p); addEdge(v, u, p); &#125; for(int i = 1; i &lt;= m; i++) scanf("%d", &amp;k[i]); root = 0, sum = n, mxson[0] = INF; findRoot(1, 0); solve(root); for(int i = 1; i &lt;= m; i++) puts(cnt[k[i]] &gt; 0 ? "AYE" : "NAY"); return 0;&#125; [国家集训队] 聪聪可可题意求边权和是3的倍数的点对个数题解思路和上面两道题大同小异，而且更简单了：不用对dis排序，只需记录下距当前根dis为0,1,2的点的个数(cnt)，则答案就是$cnt[0] * cnt[0] + cnt[1] * cnt[2] * 2$当然这样做也要容斥Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 20005;const int INF = 1e9;int n, u, v, p;struct Edge&#123; int nxt, to, dis;&#125;edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to, int dis)&#123; edge[++edgeNum].nxt = head[from]; edge[edgeNum].to = to; edge[edgeNum].dis = dis; head[from] = edgeNum;&#125;int root, mxson[N], sum, size[N];bool vis[N];void findRoot(int x, int f)&#123; size[x] = 1, mxson[x] = 0; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to] || edge[i].to == f) continue; findRoot(edge[i].to, x); size[x] += size[edge[i].to]; mxson[x] = max(mxson[x], size[edge[i].to]); &#125; mxson[x] = max(mxson[x], sum - size[x]); if(mxson[x] &lt; mxson[root]) root = x;&#125;int cnt[3];void getDis(int x, int f, int d)&#123; cnt[d%3]++; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to] || edge[i].to == f) continue; getDis(edge[i].to, x, (d + edge[i].dis) % 3); &#125;&#125;int cal(int x, int d)&#123; cnt[0] = cnt[1] = cnt[2] = 0; getDis(x, 0, d); return cnt[0] * cnt[0] + cnt[1] * cnt[2] * 2;&#125;int ans;void solve(int x)&#123; ans += cal(x, 0); vis[x] = 1; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to]) continue; ans -= cal(edge[i].to, edge[i].dis % 3); root = 0, sum = size[edge[i].to], mxson[0] = INF; findRoot(edge[i].to, 0); solve(root); &#125;&#125;int gcd(int a, int b)&#123; return b == 0 ? a : gcd(b, a % b);&#125;int main()&#123; scanf("%d", &amp;n); for(int i = 1; i &lt; n; i++)&#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;p); addEdge(u, v, p % 3); addEdge(v, u, p % 3); &#125; root = 0, mxson[0] = INF, sum = n; findRoot(1, 0); solve(root); int g = gcd(ans, n*n); printf("%d/%d", ans / g, n * n / g); return 0;&#125; [IOI]Race题意给一棵树，每条边有权。求一条简单路径，权值和等于 K ，且边的数量最小。输出最小边数题解发现这道不能容斥…所以我们想办法通过子树信息直接计算经过分治点的路径的答案记$tmp[i]$为当前子树中，路径长为$i$的最小边数，于是对于当前根$x$，我们每次遍历它的子树，先用$tmp[]$和正在遍历的子树更新答案（代码中的 $updAns()$ 函数），再用正在遍历的这颗子树更新$tmp[]$（代码中的 $updTmp()$ 函数），这样就保证了不会把不合法的路径算进来Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int INF = 1e9;const int N = 200005;int n, k, u, v, p;struct Edge&#123; int nxt, to, dis;&#125;edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to, int dis)&#123; edge[++edgeNum].nxt = head[from]; edge[edgeNum].to = to; edge[edgeNum].dis = dis; head[from] = edgeNum;&#125;int root, mxson[N], size[N], sum;bool vis[N];void findRoot(int x, int f)&#123; size[x] = 1, mxson[x] = 0; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to] || edge[i].to == f) continue; findRoot(edge[i].to, x); size[x] += size[edge[i].to]; mxson[x] = max(mxson[x], size[edge[i].to]); &#125; mxson[x] = max(mxson[x], sum - size[x]); if(mxson[x] &lt; mxson[root]) root = x;&#125;int ans = INF, tmp[1000005];void updTmp(int x, int f, int dis, int d)&#123; if(dis &lt;= k) tmp[dis] = min(tmp[dis], d); for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to] || edge[i].to == f) continue; updTmp(edge[i].to, x, dis + edge[i].dis, d + 1); &#125;&#125;void updAns(int x, int f, int dis, int d)&#123; if(dis &lt;= k) ans = min(ans, d + tmp[k-dis]); for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to] || edge[i].to == f) continue; updAns(edge[i].to, x, dis + edge[i].dis, d + 1); &#125;&#125;void clearTmp(int x, int f, int dis)&#123; if(dis &lt;= k) tmp[dis] = INF; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to] || edge[i].to == f) continue; clearTmp(edge[i].to, x, dis + edge[i].dis); &#125;&#125;void solve(int x)&#123; vis[x] = 1, tmp[0] = 0; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to]) continue; updAns(edge[i].to, x, edge[i].dis, 1); updTmp(edge[i].to, x, edge[i].dis, 1); &#125; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to]) continue; clearTmp(edge[i].to, x, edge[i].dis); &#125; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to]) continue; root = 0, sum = size[edge[i].to]; findRoot(edge[i].to, 0); solve(root); &#125;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;k); for(int i = 1; i &lt; n; i++)&#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;p); addEdge(u+1, v+1, p); addEdge(v+1, u+1, p); &#125; for(int i = 0; i &lt;= k; i++) tmp[i] = INF; root = 0, mxson[0] = INF, sum = n; findRoot(1, 0); solve(root); if(ans == INF) puts("-1"); else printf("%d\n", ans); return 0;&#125; —— 完 ——]]></content>
      <categories>
        <category>OI</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>树（图论）</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2017 D1 T2]时间复杂度（栈，模拟）]]></title>
    <url>%2F2018%2F04%2F14%2FNOIP2017-D1-T2-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%88%E6%A0%88%EF%BC%8C%E6%A8%A1%E6%8B%9F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并 给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序， 于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。 A++语言的循环结构如下：123F i x y 循环体E 其中F i x y表示新建变量 $i$（变量 $i$ 不可与未被销毁的变量重名）并初始化为 $x$， 然后判断 $i$ 和 $y$ 的大小关系，若 $i$ 小于等于 $y$ 则进入循环，否则不进入。每次循环结束后 $i$ 都会被修改成 $i +1$，一旦 $i$ 大于 $y$ 终止循环。 $x$ 和 $y$ 可以是正整数（$x$ 和 $y$ 的大小关系不定）或变量 $n$。$n$ 是一个表示数据规模的变量，在时间复杂度计算中需保留该变量而不能将其视为常数，该数远大于 100。 “E”表示循环体结束。循环体结束时，这个循环体新建的变量也被销毁。 注：本题中为了书写方便，在描述复杂度时，使用大写英文字母“O”表示通常意义下“Θ”的概念。 输入输入文件第一行一个正整数 $t$，表示有 $t$（$t \le 10$）个程序需要计算时间复杂度。 每个程序我们只需抽取其中 F i x y和E即可计算时间复杂度。注意：循环结构允许嵌套。 接下来每个程序的第一行包含一个正整数 $L$ 和一个字符串，$L$ 代表程序行数，字符串表示这个程序的复杂度，O(1)表示常数复杂度，O(n^w)表示复杂度为$n^w$，其中w是一个小于100的正整数（输入中不包含引号），输入保证复杂度只有O(1)和O(n^w) 两种类型。 接下来 $L$ 行代表程序中循环结构中的F i x y或者 E。 程序行若以F开头，表示进入一个循环，之后有空格分离的三个字符（串）i x y， 其中 $i$ 是一个小写字母（保证不为$n$），表示新建的变量名，$x$ 和 $y$ 可能是正整数或 $n$ ，已知若为正整数则一定小于 100。 程序行若以E开头，则表示循环体结束。 输出输出文件共 $t$ 行，对应输入的 $t$ 个程序，每行输出”Yes”或”No”或者”ERR”（输出中不包含引号），若程序实际复杂度与输入给出的复杂度一致则输出”Yes”，不一致则输出”No”，若程序有语法错误（其中语法错误只有: ① F 和 E 不匹配 ②新建的变量与已经存在但未被销毁的变量重复两种情况），则输出”ERR” 。 注意：即使在程序不会执行的循环体中出现了语法错误也会编译错误，要输出 ERR。 样例输入1234567891011121314151617181920212223242526272829303132333482 O(1)F i 1 1E2 O(n^1)F x 1 nE1 O(1)F x 1 n4 O(n^2)F x 5 nF y 10 nEE4 O(n^2)F x 9 nEF y 2 nE4 O(n^1)F x 9 nF y n 4EE4 O(1)F y n 4F x 9 nEE4 O(n^2)F x 1 nF x 1 10EE 样例输出12345678YesYesERRYesNoYesYesERR 输入输出样例解释第一个程序 $i$ 从 1 到 1 是常数复杂度。第二个程序 $x$ 从 1 到 $n$ 是 $n$ 的一次方的复杂度。第三个程序有一个 F 开启循环却没有 E 结束，语法错误。第四个程序二重循环，$n$ 的平方的复杂度。第五个程序两个一重循环，$n$ 的一次方的复杂度。第六个程序第一重循环正常，但第二重循环开始即终止（因为$n$远大于100，100大于4）。第七个程序第一重循环无法进入，故为常数复杂度。第八个程序第二重循环中的变量 $x$ 与第一重循环中的变量重复，出现语法错误②，输出 ERR。 数据规模与约定对于 30%的数据：不存在语法错误，数据保证小明给出的每个程序的前 $L/2$ 行一定为以 F 开头的语句，第 $L/2+1$ 行至第 $L$ 行一定为以 $E$ 开头的语句，$L \le 10$，若 $x$、$y$ 均 为整数，$x$ 一定小于 $y$，且只有 $y$ 有可能为 $n$。对于 50%的数据：不存在语法错误，$L \le 100$，且若 $x$、$y$ 均为整数，$x$ 一定小于 $y$， 且只有 $y$ 有可能为 $n$。对于 70%的数据：不存在语法错误，$L \le 100$。对于 100%的数据：$L \le 100$。 解题思路由于循环必须要让F与E配对，联想到括号匹配问题，所以用栈来模拟。为了方便计算，我在栈里维护了三个值，分别表示当前循环所用变量名、程序执行到当前循环时的复杂度、当前循环是否处于被跳过的循环之中（即程序不会执行到）。在压栈时维护一下这三个值就好了，最后的复杂度即为最大的可被执行到的复杂度。最后，注意一下关于字符串的读入处理就好了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int T, L, kind, w;//kind == 1:O(1); kind == 2: O(n^w)int top, ans;char com[100], opt[100];bool used[1000], err;struct Node&#123; char ch; int c;//执行至此的时间复杂度 bool dir;//是否处于直接跳过的循环中 &#125;sta[1000];void solve()&#123; scanf("%d ", &amp;L); cin.getline(com, 99); if(com[2] == '1') kind = 1; else&#123; int now = 4; while(com[now] &gt;= '0' &amp;&amp; com[now] &lt;= '9')&#123; w = w * 10 + com[now] - '0'; now++; &#125; kind = 2; &#125; for(int i = 1; i &lt;= L; i++)&#123; cin.getline(opt, 99); if(err) continue; if(opt[0] == 'F')&#123; if(used[opt[2]])&#123; err = 1; continue; &#125; used[opt[2]] = 1; int now = 4, l = 0, r = 0, pre = 0, nxt = 0; while((opt[now] &gt;= '0' &amp;&amp; opt[now] &lt;= '9') || opt[now] == 'n')&#123; if(opt[now] == 'n') pre = 1; else l = l * 10 + opt[now] - '0'; now++; &#125; now++; while((opt[now] &gt;= '0' &amp;&amp; opt[now] &lt;= '9') || (opt[now] == 'n'))&#123; if(opt[now] == 'n') nxt = 1; else r = r * 10 + opt[now] - '0'; now++; &#125; if(pre == 1 &amp;&amp; nxt == 1)&#123; sta[top+1] = (Node)&#123;opt[2], sta[top].c, sta[top].dir&#125;; top++; if(sta[top].dir == 0) ans = max(ans, sta[top].c); &#125; else if(pre == 1 &amp;&amp; nxt == 0)&#123; sta[top+1] = (Node)&#123;opt[2], sta[top].c, 1&#125;; top++; &#125; else if(pre == 0 &amp;&amp; nxt == 1)&#123; sta[top+1] = (Node)&#123;opt[2], sta[top].c + 1, sta[top].dir&#125;; top++; if(sta[top].dir == 0) ans = max(ans, sta[top].c); &#125; else if(pre == 0 &amp;&amp; nxt == 0)&#123; if(l &lt;= r)&#123; sta[top+1] = (Node)&#123;opt[2], sta[top].c, sta[top].dir&#125;; top++; if(sta[top].dir == 0) ans = max(ans, sta[top].c); &#125; else&#123; sta[top+1] = (Node)&#123;opt[2], sta[top].c, 1&#125;; top++; &#125; &#125; &#125; else if(opt[0] == 'E')&#123; if(top == 0) err = 1; else&#123; used[sta[top].ch] = 0; top--; &#125; &#125; &#125; if(top) err = 1; if(err)&#123; puts("ERR"); return; &#125; if(kind == 1 &amp;&amp; ans == 0)&#123; puts("Yes"); return; &#125; if(kind == 2 &amp;&amp; w == ans)&#123; puts("Yes"); return; &#125; puts("No"); return;&#125;void init()&#123; memset(sta, 0, sizeof sta); top = 0; memset(com, 0, sizeof com); memset(opt, 0, sizeof opt); memset(used, 0, sizeof used); err = 0; ans = 0; kind = w = 0;&#125;int main()&#123; scanf("%d", &amp;T); while(T--)&#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2017 D1 T1]小凯的疑惑（数论）]]></title>
    <url>%2F2018%2F04%2F14%2FNOIP2017-D1-T1-%E5%B0%8F%E5%87%AF%E7%9A%84%E7%96%91%E6%83%91%EF%BC%88%E6%95%B0%E8%AE%BA%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述小凯手中有两种面值的金币，两种面值均为正整数且彼此互素。每种金币小凯都有 无数个。在不找零的情况下，仅凭这两种金币，有些物品他是无法准确支付的。现在小凯想知道在无法准确支付的物品中，最贵的价值是多少金币？注意：输入数据保证存在小凯无法准确支付的商品。 输入输入数据仅一行，包含两个正整数 $a$ 和 $ b $，它们之间用一个空格隔开，表示小凯手 中金币的面值。 输出输出文件仅一行，一个正整数 $ N $，表示不找零的情况下，小凯用手中的金币不能准确支付的最贵的物品的价值。 样例输入13 7 样例输出111 样例说明小凯手中有面值为3和7的金币无数个，在不找零的前提下无法准确支付价值为1、 2、4、5、8、11 的物品，其中最贵的物品价值为 11，比 11 贵的物品都能买到，比如：$ 12 = 3 \times 4 + 7 \times 0 $$ 13 = 3 \times 2 + 7 \times 1 $$ 14 = 3 \times 0 + 7 \times 2 $$ 15 = 3 \times 5 + 7 \times 0 $ 数据范围与约定对于 30%的数据： $ 1 \le a,b \le 50 $。对于 60%的数据： $ 1 \le a,b \le 10^4 $。对于 100%的数据：$ 1 \le a,b \le 10^9 $。 解题思路因为$ (a,b) = 1 $，所以$ {a, 2a, 3a, …, (b-1)a} $为模$ b $的完全剩余系。设$ T $是一个$ a, b $无法表示的数且$ T \equiv ka(mod \ b) $，$ (1 \le k \le b-1) $.若$ T \ge ka $，则$ T $一定可以表示为$ ka+nb $，$ (n \ge 0) $，所以$ T &lt; ka $，则此时$ T $最大为$ ka-b $.显然，当$ k $最大时$ T $最大，所以$ T = (b-1)a-b = ab - a - b $. Code123456789#include&lt;cstdio&gt;using namespace std;typedef long long LL;LL a, b;int main()&#123; scanf("%lld%lld", &amp;a, &amp;b); printf("%lld", a * b - a - b); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello, world!]]></title>
    <url>%2F2018%2F04%2F07%2FHello-world-0%2F</url>
    <content type="text"><![CDATA[搞了一个下午+一个晚上，终于把hexo+github博客搭建起来了……（尚待后续优化） 这个博客用于几个板块：OI/ACM 学习笔记（主要），学习总结，随笔，其他 12break?continue!]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
