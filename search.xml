<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[NOIP2017 D2 T3]列队（线段树/平衡树）]]></title>
    <url>%2F2018%2F04%2F30%2FNOIP2017-D2-T3-%E5%88%97%E9%98%9F%EF%BC%88%E7%BA%BF%E6%AE%B5%E6%A0%91-%E5%B9%B3%E8%A1%A1%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述Sylvia 是一个热爱学习的女♂孩子。前段时间，Sylvia 参加了学校的军训。众所周知，军训的时候需要站方阵。Sylvia 所在的方阵中有$n \times m$名学生，方阵的行数为 $n$，列数为 $m$。为了便于管理，教官在训练开始时，按照从前到后，从左到右的顺序给方阵中 的学生从 1 到 $n \times m$ 编上了号码（参见后面的样例）。即：初始时，第 $i$ 行第 $j$ 列 的学生的编号是$(i-1)\times m + j$。然而在练习方阵的时候，经常会有学生因为各种各样的事情需要离队。在一天 中，一共发生了 $q$件这样的离队事件。每一次离队事件可以用数对$(x,y) (1 \le x \le n, 1 \le y \le m)$描述，表示第 $x$ 行第 $y$ 列的学生离队。在有学生离队后，队伍中出现了一个空位。为了队伍的整齐，教官会依次下达 这样的两条指令： 向左看齐。这时第一列保持不动，所有学生向左填补空缺。不难发现在这条 指令之后，空位在第 $x$ 行第 $m$ 列。 向前看齐。这时第一行保持不动，所有学生向前填补空缺。不难发现在这条 指令之后，空位在第 $n$ 行第 $m$ 列。 教官规定不能有两个或更多学生同时离队。即在前一个离队的学生归队之后， 下一个学生才能离队。因此在每一个离队的学生要归队时，队伍中有且仅有第 $n$ 行 第 $m$ 列一个空位，这时这个学生会自然地填补到这个位置。因为站方阵真的很无聊，所以 Sylvia 想要计算每一次离队事件中，离队的同学 的编号是多少。注意：每一个同学的编号不会随着离队事件的发生而改变，在发生离队事件后 方阵中同学的编号可能是乱序的。 输入输入共 $q+1$行。第 1 行包含 3 个用空格分隔的正整数 $n, m, q$，表示方阵大小是 $n$ 行 $m$ 列，一共发 生了 $q$ 次事件。接下来 $q$ 行按照事件发生顺序描述了 $q$ 件事件。每一行是两个整数 $x, y$，用一个空 格分隔，表示这个离队事件中离队的学生当时排在第 $x$ 行第 $y$ 列。 输出按照事件输入的顺序，每一个事件输出一行一个整数，表示这个离队事件中离队学 生的编号。 输入样例12342 2 31 12 21 2 输出样例123114 数据规模与约定$n,m,q \leq 3 \times 10^5$数据保证每一个事件满足 $1 \le x \le n,1 \le y \le m$ 解题思路一道数据结构的好题。首先我们发现，每次操作只会更改某一行和最后一列的状态，那么我们可以单独把最后一列拿出来用一个数据结构维护，再用$n$个数据结构维护每一行的前$m-1$个元素。那用什么数据结构好呢？ 一、线段树线段树是最容易想到的，共开$n+1$颗线段树，前$n$颗维护每行前$m-1$个元素，第$n+1$颗维护最后一列的元素。每次对$(x,y)$操作都可以转化为一个基本操作：从一颗线段树里面拿出一个元素加到一颗线段树的末尾，具体来说： 如果$y = m$，只需要从“列线段树”里拿出第$x$个元素加到它本身末尾 否则，从第$x$颗“行线段树”里拿出第$y$个元素加到“列线段树”末尾，再从“列线段树”里拿出第$x$个元素加到“行线段树”末尾 所谓的“拿出”操作就是一个在线段树上二分查找的过程，为此我们要在线段树每个节点上记录一个size，表示当前节点表示的区间里面还剩多少个元素。另外，每颗线段树要多开$q$的区间长度（想想操作过程就明白了）。 但是，以上并不是这道题的难点，这道题的特殊之处在于你无法直接开满$n+1$颗线段树！怎么办呢，我们可以动态开点来解决，也就是说当你要用某个点时再开它（想想主席树）。这样我们只需要$NlogN$的空间就够了。 时间复杂度 $O(q\log (n+q))$ 二、平衡树既然线段树可以，平衡树当然也可以了！同样的思路：每次操作都可以转化为从一颗平衡树上二分查找第k大的值，把它加到一颗平衡树的末尾。 怎么解决空间问题？由于有一些人至始至终都站在一起，我们可以在平衡树上只用一个节点表示这个区间$[l,r]$（编号从$l$到$r$的人），当我们发现这个区间中的某个人（如编号为$k$的人）要离队时，再把它split成两个小区间（$[l,k-1],[k+1,r]$），输出$k$，这样就能保证空间复杂度为 $NlogN$。 时间复杂度$O(q\log n)$ 三、树状数组有待学习… Code#1（线段树）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 300005;int n, m, q, qx, qy, p[N], root[N];LL t;struct segTree&#123; int son[2]; LL val, size;&#125;tr[N*30];struct OPT_segTree&#123; int cnt; inline int newNode(int l, int r, int kind)&#123; cnt++; int temp = (kind == 0 ? m - 1 : n); if(l &lt;= temp &amp;&amp; r &lt;= temp) tr[cnt].size = r - l + 1; else if(l &lt;= temp &amp;&amp; r &gt; temp) tr[cnt].size = temp - l + 1; else if(l &gt; temp &amp;&amp; r &gt; temp) tr[cnt].size = 0; return cnt; &#125; inline void pushup(int id)&#123; tr[id].size = tr[tr[id].son[0]].size + tr[tr[id].son[1]].size; &#125; LL getKth(int id, int l, int r, LL k, int kind)&#123; if(l == r)&#123; if(!tr[id].val)&#123; if(kind == 0) tr[id].val = 1ll * (qx - 1) * m + l; else tr[id].val = 1ll * l * m; &#125; tr[id].size = 0; return tr[id].val; &#125; int mid = (l + r) &gt;&gt; 1; if(!tr[id].son[0]) tr[id].son[0] = newNode(l, mid, kind); if(!tr[id].son[1]) tr[id].son[1] = newNode(mid+1, r, kind); LL res = 0; if(tr[tr[id].son[0]].size &gt;= k) res = getKth(tr[id].son[0], l, mid, k, kind); else res = getKth(tr[id].son[1], mid+1, r, k - tr[tr[id].son[0]].size, kind); pushup(id); return res; &#125; void insert(int id, int l, int r, int pos, LL val, int kind)&#123; if(l == r)&#123; tr[id].val = val; tr[id].size = 1; return; &#125; int mid = (l + r) &gt;&gt; 1; if(!tr[id].son[0]) tr[id].son[0] = newNode(l, mid, kind); if(!tr[id].son[1]) tr[id].son[1] = newNode(mid+1, r, kind); if(pos &lt;= mid) insert(tr[id].son[0], l, mid, pos, val, kind); else insert(tr[id].son[1], mid+1, r, pos, val, kind); pushup(id); &#125;&#125;Seg;int main()&#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;q); for(int i = 1; i &lt;= n; i++) p[i] = m - 1; p[n+1] = n; for(int i = 1; i &lt;= n; i++) root[i] = Seg.newNode(1, m - 1 + q, 0); root[n+1] = Seg.newNode(1, n + q, 1); for(int i = 1; i &lt;= q; i++)&#123; scanf("%d%d", &amp;qx, &amp;qy); if(qy == m)&#123; printf("%lld\n", t = Seg.getKth(root[n+1], 1, n + q, qx, 1)); Seg.insert(root[n+1], 1, n + q, ++p[n+1], t, 1); &#125; else&#123; printf("%lld\n", t = Seg.getKth(root[qx], 1, m - 1 + q, qy, 0)); Seg.insert(root[n+1], 1, n + q, ++p[n+1], t, 1); t = Seg.getKth(root[n+1], 1, n + q, qx, 1); Seg.insert(root[qx], 1, m - 1 + q, ++p[qx], t, 0); &#125; &#125; return 0;&#125; Code#2（Splay）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;cstdio&gt;using namespace std;typedef long long LL;const int N = 300005;int qx, qy, rt[N];LL t, n, m, q;struct Splay&#123; int son[2], fa; LL val, l, r, size;&#125;tr[N*30];struct OPT_Splay&#123; int cnt; inline void pushup(int id)&#123; tr[id].size = tr[id].r - tr[id].l + 1; if(tr[id].son[0]) tr[id].size += tr[tr[id].son[0]].size; if(tr[id].son[1]) tr[id].size += tr[tr[id].son[1]].size; &#125; inline int newNode(LL l, LL r)&#123; cnt++; tr[cnt].fa = tr[cnt].son[0] = tr[cnt].son[1] = 0; tr[cnt].size = (tr[cnt].r = r) - (tr[cnt].l = l) + 1; return cnt; &#125; inline void rotate(int x, int kind)&#123; int y = tr[x].fa, z = tr[y].fa, A = tr[y].son[kind], B = tr[x].son[kind], C = tr[x].son[!kind]; tr[x].son[kind] = y, tr[x].fa = z; tr[y].fa = x, tr[y].son[!kind] = B; tr[z].son[tr[z].son[1] == y] = x, tr[B].fa = y; pushup(y), pushup(x); &#125; inline void splay(int &amp;root, int x, int goal)&#123; if(x == goal) return; while(tr[x].fa != goal)&#123; int y = tr[x].fa, z = tr[y].fa; int isrson1 = tr[y].son[1] == x, isrson2 = tr[z].son[1] == y; if(z == goal) rotate(x, !isrson1); else&#123; if(isrson1 == isrson2) rotate(y, !isrson2); else rotate(x, !isrson1); rotate(x, !isrson2); &#125; &#125; if(goal == 0) root = x; &#125; inline int selectLast(int &amp;root)&#123; int now = root; while(tr[now].son[1]) now = tr[now].son[1]; return now; &#125; inline void insert(int &amp;root, LL val)&#123; int temp = newNode(val, val); int pos = selectLast(root); tr[pos].son[1] = temp; tr[temp].fa = pos; splay(root, temp, 0); &#125; LL split(int &amp;root, int now, LL k)&#123; splay(root, now, 0); k += tr[now].l - 1; int temp = newNode(k+1, tr[now].r); tr[now].r = k - 1; if(!tr[now].son[1])&#123; tr[now].son[1] = temp; tr[temp].fa = now; &#125; else&#123; tr[temp].son[1] = tr[now].son[1]; tr[tr[temp].son[1]].fa = temp; tr[now].son[1] = temp; tr[temp].fa = now; &#125; pushup(temp), pushup(now); return k; &#125; inline LL getKth(int &amp;root, LL k)&#123; int now = root; while(1)&#123; if(k &lt;= tr[tr[now].son[0]].size) now = tr[now].son[0]; else&#123; k -= tr[tr[now].son[0]].size; if(k &lt;= tr[now].r - tr[now].l + 1) return split(root, now, k); else&#123; k -= (tr[now].r - tr[now].l + 1); now = tr[now].son[1]; &#125; &#125; &#125; &#125;&#125;BST;int main()&#123; scanf("%lld%lld%lld", &amp;n, &amp;m, &amp;q); for(int i = 1; i &lt;= n; i++) rt[i] = BST.newNode((i - 1) * m + 1, i * m - 1); rt[n+1] = BST.newNode(m, m); for(int i = 2; i &lt;= n; i++) BST.insert(rt[n+1], i * m); while(q--)&#123; scanf("%d%d", &amp;qx, &amp;qy); if(qy == m)&#123; printf("%lld\n", t = BST.getKth(rt[n+1], qx)); BST.insert(rt[n+1], t); &#125; else&#123; printf("%lld\n", t = BST.getKth(rt[qx], qy)); BST.insert(rt[n+1], t); BST.insert(rt[qx], BST.getKth(rt[n+1], qx)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
        <category>平衡树</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2017 D2 T2]宝藏（状压dp）]]></title>
    <url>%2F2018%2F04%2F30%2FNOIP2017-D2-T2-%E5%AE%9D%E8%97%8F%EF%BC%88%E7%8A%B6%E5%8E%8Bdp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述参与考古挖掘的小明得到了一份藏宝图，藏宝图上标出了 $n$ 个深埋在地下的宝藏屋， 也给出了这 $n$ 个宝藏屋之间可供开发的 $m$ 条道路和它们的长度。 小明决心亲自前往挖掘所有宝藏屋中的宝藏。但是，每个宝藏屋距离地面都很远， 也就是说，从地面打通一条到某个宝藏屋的道路是很困难的，而开发宝藏屋之间的道路 则相对容易很多。 小明的决心感动了考古挖掘的赞助商，赞助商决定免费赞助他打通一条从地面到某 个宝藏屋的通道，通往哪个宝藏屋则由小明来决定。 在此基础上，小明还需要考虑如何开凿宝藏屋之间的道路。已经开凿出的道路可以 任意通行不消耗代价。每开凿出一条新道路，小明就会与考古队一起挖掘出由该条道路 所能到达的宝藏屋的宝藏。另外，小明不想开发无用道路，即两个已经被挖掘过的宝藏 屋之间的道路无需再开发。新开发一条道路的代价是： L \times K$L$代表这条道路的长度，$K$代表从赞助商帮你打通的宝藏屋到这条道路起点的宝藏屋所经过的 宝藏屋的数量（包括赞助商帮你打通的宝藏屋和这条道路起点的宝藏屋） 。 请你编写程序为小明选定由赞助商打通的宝藏屋和之后开凿的道路，使得工程总代价最小，并输出这个最小值。 输入第一行两个用空格分离的正整数 $n$ 和 $m$，代表宝藏屋的个数和道路数。 接下来 $m$ 行，每行三个用空格分离的正整数，分别是由一条道路连接的两个宝藏 屋的编号（编号为 $1$~$n$），和这条道路的长度 $v$。 输出输出共一行，一个正整数，表示最小的总代价。 样例输入样例输入11234564 5 1 2 1 1 3 3 1 4 1 2 3 4 3 4 1 样例输入21234564 5 1 2 1 1 3 3 1 4 1 2 3 4 3 4 2 样例输出样例输出114 样例输出215 数据规模与约定对于 20% 的数据： 保证输入是一棵树，$1 \le n \le 8$ , $v \le 5000$ 且所有的 v 都相等。对于 40% 的数据： $1 \le n \le 8$，$0 \le m \le 1000$ , $v \le 5000$ 且所有的 v 都相等。对于 70% 的数据： $1 \le n \le 8$，$0 \le m \le 1000$，$v \le 5000$对于 100% 的数据： $1 \le n \le 12$，$0 \le m \le 1000$ , $v \le 500000$ 解题思路首先，很容易发现打通后的道路一定是一棵树，并且，若以起点为根并令其深度为$0$，则题目中的 $K$ 即为这条路所连向的点的深度。 观察数据范围，$n \le 12$，显然是状压dp： dp状态：$dp[i][S]$ 表示考虑到树的第$i$层，前$i$层已选的点的集合为$S$（二进制状压）的最小代价。 dp方程（刷表法）： 已知$dp[i][S]$时，可枚举所有由不在$S$中的点构成的集合作为第$i+1$层，则状态转移为dp[i][S] \to dp[i+1][S|S'] + (i+1) \times \Sigma \ min\{G[a][b]|a \in S , b \in S',S \cap S' = \emptyset \} 简单一点，就是dp[i][S] \to dp[i+1][S|S'] + (i+1) \times sval[S'][S] \} 其中$sval[A][B]$表示集合A到集合B的最短距离，即集合A中所有点到集合B的最短距离之和。可以先预处理出每个点到每个集合的最短距离$pval[i][S]$（也就是点$i$到集合$S$中所有点的距离的最小值），然后用$pval[i][B]$更新$sval[A][B]$。 dp顺序：由dp方程可得：从小到大枚举层数，再枚举集合即可 边界条件：枚举根节点，设为$root$，则$dp[0][1&lt;&lt;(root-1)] = 0$ 状压相关技巧 若$S$是$U$的子集，则$S$关于$U$的补集：$S ^\wedge U$ 判断点$k$是否在集合$S$中（即$S$的第$k-1$位是否为$1$）：S &amp; (1 &lt;&lt; (k-1)) ！= 0 ? &quot;Yes&quot; : &quot;No&quot;; 枚举$S$的子集：for(int i = S; i; i = (i - 1) &amp; S){...} Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int INF = 1e7;const int N = 13;int n, m, g[N][N], u, v, p, U;LL dp[N][1&lt;&lt;N], ans = 1e14, sval[1&lt;&lt;N][1&lt;&lt;N], pval[N][1&lt;&lt;N];void init(int root)&#123; for(int i = 0; i &lt;= n; i++) for(int j = 0; j &lt;= U; j++) dp[i][j] = INF; dp[0][1&lt;&lt;(root-1)] = 0;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); U = (1 &lt;&lt; n) - 1; for(int i = 1; i &lt;= n; i++) //initialize g[i][j] for(int j = 1; j &lt;= n; j++) if(i ^ j) g[i][j] = INF; for(int i = 1; i &lt;= n; i++) for(int j = 0; j &lt;= U; j++) pval[i][j] = INF; for(int i = 0; i &lt;= U; i++) for(int j = 0; j &lt;= U; j++) sval[i][j] = INF; while(m--)&#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;p); g[u][v] = min(g[u][v], p); g[v][u] = min(g[v][u], p); &#125; for(int i = 1; i &lt;= n; i++) //initialize pval[i][S] for(int j = 0; j &lt;= U; j++) for(int k = 1; k &lt;= n; k++) if(j &amp; (1 &lt;&lt; (k - 1))) pval[i][j] = min(pval[i][j], 1ll*g[i][k]); for(int i = 0; i &lt;= U; i++)&#123; //initialize sval[A][B] int C = i ^ U; for(int s = C; s; s = (s - 1) &amp; C)&#123; LL temp = 0; for(int j = 1; j &lt;= n; j++) if(s &amp; (1 &lt;&lt; (j - 1))) temp += pval[j][i]; sval[s][i] = temp &gt;= INF ? INF : temp; &#125; &#125; for(int root = 1; root &lt;= n; root++)&#123; //dp init(root); for(int i = 0; i &lt; n; i++) for(int S = 0; S &lt;= U; S++) if(dp[i][S] != INF)&#123; int C = S ^ U; for(int s = C; s; s = (s - 1) &amp; C) dp[i+1][S|s] = min(dp[i+1][S|s], dp[i][S] + (i + 1) * sval[s][S]); &#125; for(int i = 0; i &lt; n; i++) ans = min(ans, dp[i][U]); &#125; printf("%lld", ans); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>状压dp</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2017 D2 T1]奶酪（并查集）]]></title>
    <url>%2F2018%2F04%2F30%2FNOIP2017-D2-T1-%E5%A5%B6%E9%85%AA%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述现有一块大奶酪，它的高度为 $h$，它的长度和宽度我们可以认为是无限大的，奶酪中间有许多半径相同的球形空洞。我们可以在这块奶酪中建立空间坐标系，在坐标系中，奶酪的下表面为$z=0$，奶酪的上表面为$z = h$。现在，奶酪的下表面有一只小老鼠 Jerry，它知道奶酪中所有空洞的球心所在的坐 标。如果两个空洞相切或是相交，则 Jerry 可以从其中一个空洞跑到另一个空洞，特别地，如果一个空洞与下表面相切或是相交，Jerry 则可以从奶酪下表面跑进空洞；如果一个空洞与上表面相切或是相交，Jerry 则可以从空洞跑到奶酪上表面。位于奶酪下表面的 Jerry 想知道，在不破坏奶酪的情况下，能否利用已有的空洞跑到奶酪的上表面去?空间内两点$P_1(x_1,y_1,z_1)$、$P2(x_2,y_2,z_2)$的距离公式如下： \mathrm{dist}(P_1,P_2)=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}输入每个输入文件包含多组数据。输入文件的第一行，包含一个正整数 $T$，代表该输入文件中所含的数据组数。接下来是 $T$ 组数据，每组数据的格式如下： 第一行包含三个正整数 $n,h$ 和 $r$，两个数之间以一个空格分开，分别代表奶酪中空洞的数量，奶酪的高度和空洞的半径。接下来的 $n$ 行，每行包含三个整数 $x,y,z$，两个数之间以一个空格分开，表示空洞球心坐标为$(x,y,z)$。 输出输出文件包含 $T$ 行，分别对应 $T$ 组数据的答案，如果在第 $i$ 组数据中，Jerry 能从下表面跑到上表面，则输出 “Yes”，如果不能，则输出 “No” （均不包含引号）。 样例输入123456789103 2 4 1 0 0 1 0 0 3 2 5 1 0 0 1 0 0 4 2 5 2 0 0 2 2 0 4 样例输出123YesNoYes 数据规模与约定对于 20%的数据，$n = 1$，$1 \le h,r \le 10,000$，坐标的绝对值不超过 10,000。 对于 40%的数据，$1 \le n \le 8$， $1 \le h,r \le 10,000$，坐标的绝对值不超过 10,000。 对于80%的数据， $1 \le n \le 1,000$， $1 \le h , r \le 10,000$，坐标的绝对值不超过10,000。 对于 100%的数据，$1 \le n \le 1,000$，$1 \le h , r \le 1,000,000,000$，$T \le 20$，坐标的绝对值不超过 1,000,000,000。 解题思路设下底面为点$S=n+1$，上底面为点$T=n+2$，枚举两个点看它们是否连通，连通即将它们用并查集并起来，最后看$S$与$T$是否连通即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;typedef long long LL;typedef long double LB;const int N = 1005;int CASES, n, h, S, T;LL r;struct Node&#123; int x, y, z;&#125;node[N];inline LB dist(int a, int b)&#123; return sqrt((LB)(node[a].x-node[b].x)*(node[a].x-node[b].x)+(LB)(node[a].y-node[b].y)*(node[a].y-node[b].y)+(LB)(node[a].z-node[b].z)*(node[a].z-node[b].z));&#125;int fa[N];void init()&#123; for(int i = 1; i &lt;= n+2; i++) fa[i] = i;&#125;int findfa(int x)&#123; if(fa[x] != x) fa[x] = findfa(fa[x]); return fa[x];&#125;void unionn(int x, int y)&#123; fa[findfa(y)] = findfa(x);&#125;int main()&#123; scanf("%d", &amp;CASES); while(CASES--)&#123; scanf("%d%d%lld", &amp;n, &amp;h, &amp;r); init(); S = n + 1, T = n + 2; for(int i = 1; i &lt;= n; i++)&#123; scanf("%d%d%d", &amp;node[i].x, &amp;node[i].y, &amp;node[i].z); for(int j = 1; j &lt; i; j++)&#123; if(dist(i, j) &lt;= 2 * r &amp;&amp; findfa(i) != findfa(j)) unionn(i, j); &#125; if(node[i].z + r &gt;= h) unionn(i, T); if(node[i].z - r &lt;= 0) unionn(i, S); &#125; if(findfa(T) == findfa(S)) puts("Yes"); else puts("No"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普通平衡树/文艺平衡树/二逼平衡树]]></title>
    <url>%2F2018%2F04%2F30%2F%E6%99%AE%E9%80%9A%E5%B9%B3%E8%A1%A1%E6%A0%91-%E6%96%87%E8%89%BA%E5%B9%B3%E8%A1%A1%E6%A0%91-%E4%BA%8C%E9%80%BC%E5%B9%B3%E8%A1%A1%E6%A0%91%2F</url>
    <content type="text"><![CDATA[普通平衡树题目链接：luogu3369bzoj3224 解题思路平衡树模板题，我分别用了 [非旋Treap] 和 [Splay] AC了本题。 一、Splay每个节点表示一个值，同时记录该点及其子树大小、该点表示的值的出现次数、左右儿子、父节点。 插入：将x前驱旋至根，x后继旋至根的右儿子，那么根的左儿子的右儿子即为要插入的位置，如果此位置上无数，则新建一个节点；否则该位置的出现次数和大小加1。 注意：为了避免找不到x前驱和后继，应事先插入一个值为-INF和值为INF的节点。 删除：将x前驱旋至根，x后继旋至根的右儿子，那么根的左儿子的右儿子即为要删除的节点，如果此节点大小为1，直接删除；否则该位置的出现次数和大小减1。 查x排名：将x旋至根，则x排名为根的左儿子大小+1 查排名为x的数：从根向下查找，如果当前节点的左儿子大小+1=x，则返回当前节点的值；否则，如果当前节点的左儿子大小$\geq$x，则向其右儿子查找；否则，向其左儿子查找。 求x前驱：从根向下查找，如果当前节点的值小于等于x，更新ans并向其右儿子查找；否则，向其左儿子查找。更新时，不断取max即可。 求x后继：从根向下查找，如果当前节点的值大于等于x，更新ans并向其左儿子查找；否则，向其右儿子查找。更新时，不断取min即可。 时间复杂度：每次操作 $O(log_2n)$ Code#1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int INF = 0x7fffffff;const int N = 100005;int n, opt, q;int cnt = 0, root = 0;struct Splay_tree&#123; int fa, son[2], size, val, times;&#125;tr[N];inline void pushup(int x)&#123; if(x)&#123; tr[x].size = tr[x].times; if(tr[x].son[0]) tr[x].size += tr[tr[x].son[0]].size; if(tr[x].son[1]) tr[x].size += tr[tr[x].son[1]].size; &#125;&#125;inline void rotate(int x, int kind)&#123; int y = tr[x].fa, z = tr[y].fa, A = tr[y].son[kind], B = tr[x].son[kind], C = tr[x].son[!kind]; tr[x].son[kind] = y, tr[x].fa = z; tr[y].son[!kind] = B, tr[y].fa = x, tr[B].fa = y; tr[z].son[tr[z].son[1] == y] = x; pushup(y), pushup(x);&#125;inline void splay(int x, int goal)&#123; if(x == goal) return; while(tr[x].fa != goal)&#123; int y = tr[x].fa, z = tr[y].fa; int isrson1 = tr[y].son[1] == x, isrson2 = tr[z].son[1] == y; if(z == goal) rotate(x, !isrson1); else&#123; if(isrson1 == isrson2) rotate(y, !isrson2); else rotate(x, !isrson1); rotate(x, !isrson2); &#125; &#125; if(goal == 0) root = x;&#125;inline int select(int x)&#123; int now = root; while(now)&#123; if(tr[now].val == x) break; else if(tr[now].val &lt; x) now = tr[now].son[1]; else if(tr[now].val &gt; x) now = tr[now].son[0]; &#125; if(!now) return -1; return now;&#125;inline int getPre(int x)&#123; int now = root, ans = -INF; while(now)&#123; if(tr[now].val &lt; x)&#123; ans = max(ans, tr[now].val); now = tr[now].son[1]; &#125; else now = tr[now].son[0]; &#125; return ans;&#125;inline int getSub(int x)&#123; int now = root, ans = INF; while(now)&#123; if(tr[now].val &gt; x)&#123; ans = min(ans, tr[now].val); now = tr[now].son[0]; &#125; else now = tr[now].son[1]; &#125; return ans;&#125;inline int getRank(int x)&#123; int now = root, ans = 0; while(now)&#123; if(tr[now].val == x)&#123; ans += tr[tr[now].son[0]].size + 1; break; &#125; else if(tr[now].val &lt; x)&#123; ans += tr[tr[now].son[0]].size + tr[now].times; now = tr[now].son[1]; &#125; else now = tr[now].son[0]; &#125; return ans - 1;&#125;inline int newNode(int val, int f)&#123; ++cnt; tr[cnt].val = val; tr[cnt].fa = f; tr[cnt].son[0] = tr[cnt].son[1] = 0; tr[cnt].size = tr[cnt].times = 1; return cnt;&#125;inline void insert(int x)&#123; splay(select(getPre(x)), 0); splay(select(getSub(x)), root); int t = tr[tr[root].son[1]].son[0]; if(!t) tr[tr[root].son[1]].son[0] = newNode(x, tr[root].son[1]); else tr[t].times++, tr[t].size++; pushup(tr[root].son[1]); pushup(root);&#125;inline void del(int x)&#123; splay(select(getPre(x)), 0); splay(select(getSub(x)), root); int t = tr[tr[root].son[1]].son[0]; if(!t || tr[t].times == 0) return; tr[t].times--, tr[t].size--; if(tr[t].times == 0) tr[tr[root].son[1]].son[0] = 0; pushup(tr[root].son[1]); pushup(root);&#125;inline int findRank(int x)&#123; int now = root; while(now)&#123; if(tr[tr[now].son[0]].size + 1 &lt;= x &amp;&amp; x &lt;= tr[tr[now].son[0]].size + tr[now].times) break; else if(tr[tr[now].son[0]].size + 1 &gt; x) now = tr[now].son[0]; else if(tr[tr[now].son[0]].size + tr[now].times &lt; x)&#123; x -= tr[tr[now].son[0]].size + tr[now].times; now = tr[now].son[1]; &#125; &#125; return tr[now].val;&#125;int main()&#123; scanf("%d", &amp;n); root = newNode(-INF, 0); tr[root].son[1] = newNode(INF, root), pushup(root); while(n--)&#123; scanf("%d%d", &amp;opt, &amp;q); if(opt == 1) insert(q); else if(opt == 2) del(q); else if(opt == 3) printf("%d\n", getRank(q)); else if(opt == 4) printf("%d\n", findRank(q+1)); else if(opt == 5) printf("%d\n", getPre(q)); else if(opt == 6) printf("%d\n", getSub(q)); &#125; return 0;&#125; 二、非旋Treap每个节点表示一个值，同时记录该点及其子树大小、左右儿子。 插入：从x处split，新建一个值为x的节点，再将三部分merge起来。（注：从x处分开：x在前一部分，下同） 删除：从x、x+1处split成三部分（记为l、t、r），将t的左右儿子merge起来，这样就删除了一个节点，再将三部分merge起来。 查x排名：从x-1处split，则x排名为前一部分的大小+1 查排名为x的数：同Splay 求x前驱：同Splay 求x后继：同Splay 时间复杂度：每次操作 $O(log_2n)$ Code#2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int INF = 1e9;const int N = 100005;int n, opt, q;struct Treap&#123; int val, son[2], size, hp;&#125;tr[N];struct OPT_Treap&#123; int cnt, root; inline int newNode(int val)&#123; cnt++; tr[cnt].val = val; tr[cnt].hp = rand(); tr[cnt].son[0] = tr[cnt].son[1] = 0; tr[cnt].size = 1; return cnt; &#125; inline void pushup(int id)&#123; tr[id].size = 1; if(tr[id].son[0]) tr[id].size += tr[tr[id].son[0]].size; if(tr[id].son[1]) tr[id].size += tr[tr[id].son[1]].size; &#125; inline void pushdown(int id)&#123; return; &#125; int merge(int a, int b)&#123; if(a == 0) return b; if(b == 0) return a; if(tr[a].hp &lt;= tr[b].hp)&#123; pushdown(a); tr[a].son[1] = merge(tr[a].son[1], b); pushup(a); return a; &#125; else&#123; pushdown(b); tr[b].son[0] = merge(a, tr[b].son[0]); pushup(b); return b; &#125; &#125; void split(int id, int k, int &amp;x, int &amp;y)&#123; if(!id)&#123; x = 0, y = 0; return; &#125; pushdown(id); if(tr[id].val &gt; k) y = id, split(tr[id].son[0], k, x, tr[id].son[0]); else x = id, split(tr[id].son[1], k, tr[id].son[1], y); pushup(id); &#125; inline void insert(int val)&#123; int l = 0, r = 0; split(root, val, l, r); int t = newNode(val); root = merge(merge(l, t), r); &#125; inline void del(int val)&#123; int l = 0, r = 0, t = 0; split(root, val - 1, l, t); split(t, val, t, r); t = merge(tr[t].son[0], tr[t].son[1]); root = merge(merge(l, t), r); &#125; inline int getRank(int x)&#123; int ans = 0, l = 0, r = 0; split(root, x-1, l, r); ans = tr[l].size + 1; root = merge(l, r); return ans; &#125; inline int getKth(int k)&#123; int now = root; while(now)&#123; if(tr[tr[now].son[0]].size + 1 == k) return tr[now].val; else if(tr[tr[now].son[0]].size &gt;= k) now = tr[now].son[0]; else k -= (tr[tr[now].son[0]].size + 1), now = tr[now].son[1]; &#125; return -INF; &#125; inline int getPre(int x)&#123; int ans = -INF, now = root; while(now)&#123; if(tr[now].val &gt;= x) now = tr[now].son[0]; else&#123; ans = max(ans, tr[now].val); now = tr[now].son[1]; &#125; &#125; return ans; &#125; inline int getSub(int x)&#123; int ans = INF, now = root; while(now)&#123; if(tr[now].val &lt;= x) now = tr[now].son[1]; else&#123; ans = min(ans, tr[now].val); now = tr[now].son[0]; &#125; &#125; return ans; &#125;&#125;BST;int main()&#123; srand(200127); scanf("%d", &amp;n); BST.root = BST.newNode(INF); while(n--)&#123; scanf("%d%d", &amp;opt, &amp;q); if(opt == 1) BST.insert(q); else if(opt == 2) BST.del(q); else if(opt == 3) printf("%d\n", BST.getRank(q)); else if(opt == 4) printf("%d\n", BST.getKth(q)); else if(opt == 5) printf("%d\n", BST.getPre(q)); else if(opt == 6) printf("%d\n", BST.getSub(q)); &#125; return 0;&#125; 文艺平衡树题目链接：luogu3391bzoj3223 解题思路一、Splay这道题只有区间翻转操作，线段树不好维护，只有用平衡树了。对于一次$[l,r]$的区间翻转，把$l-1$旋至根，$r+1$旋至根的右儿子，那么$[l,r]$就在根的右儿子的左儿子处了。和线段树一样，我们可以将它的左右儿子互换后打上一个翻转标记(rev ^= 1)，之后再pushdown。 Code#3123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int INF = 0x7fffffff;const int N = 100005;int n, m, ql, qr;int cnt, root;struct Splay_tree&#123; int fa, son[2], size, val; bool rev;&#125;tr[N];inline void pushup(int x)&#123; if(x)&#123; tr[x].size = 1; if(tr[x].son[0]) tr[x].size += tr[tr[x].son[0]].size; if(tr[x].son[1]) tr[x].size += tr[tr[x].son[1]].size; &#125;&#125;inline void pushdown(int x)&#123; if(tr[x].rev)&#123; if(tr[x].son[0])&#123; tr[tr[x].son[0]].rev ^= 1; swap(tr[tr[x].son[0]].son[0], tr[tr[x].son[0]].son[1]); &#125; if(tr[x].son[1])&#123; tr[tr[x].son[1]].rev ^= 1; swap(tr[tr[x].son[1]].son[0], tr[tr[x].son[1]].son[1]); &#125; tr[x].rev = 0; &#125;&#125;inline void rotate(int x, int kind)&#123; int y = tr[x].fa, z = tr[y].fa, A = tr[y].son[kind], B = tr[x].son[kind], C = tr[x].son[!kind]; tr[x].son[kind] = y, tr[x].fa = z; tr[y].son[!kind] = B, tr[y].fa = x; tr[z].son[tr[z].son[1] == y] = x; tr[B].fa = y; pushup(y), pushup(x);&#125;inline void splay(int x, int goal)&#123; if(x == goal) return; while(tr[x].fa != goal)&#123; int y = tr[x].fa, z = tr[y].fa; pushdown(z), pushdown(y), pushdown(x); int isrson1 = tr[y].son[1] == x, isrson2 = tr[z].son[1] == y; if(z == goal) rotate(x, !isrson1); else&#123; if(isrson1 == isrson2) rotate(y, !isrson2); else rotate(x, !isrson1); rotate(x, !isrson2); &#125; &#125; if(goal == 0) root = x;&#125;inline int newNode(int val, int f)&#123; cnt++; tr[cnt].val = val; tr[cnt].fa = f; tr[cnt].son[0] = tr[cnt].son[1] = 0; tr[cnt].size = 1; return cnt;&#125;int select(int x)&#123; int now = root; pushdown(now); while(tr[tr[now].son[0]].size + 1 != x)&#123; if(tr[tr[now].son[0]].size + 1 &gt; x) now = tr[now].son[0]; else&#123; x -= tr[tr[now].son[0]].size + 1; now = tr[now].son[1]; &#125; pushdown(now); &#125; return now;&#125;inline void reverse(int l, int r)&#123; splay(select(l-1), 0); splay(select(r+1), root); int t = tr[tr[root].son[1]].son[0]; tr[t].rev ^= 1; swap(tr[t].son[0], tr[t].son[1]);&#125;int build(int l, int r, int f)&#123; if(l &gt; r) return 0; int mid = (l + r) &gt;&gt; 1, x = ++cnt; tr[x].val = mid - 1; tr[x].size = 1; tr[x].fa = f; tr[x].rev = 0; tr[x].son[0] = build(l, mid-1, x); tr[x].son[1] = build(mid+1, r, x); pushup(x); return x;&#125;void print(int x)&#123; pushdown(x); if(tr[x].son[0]) print(tr[x].son[0]); if(tr[x].val &gt;= 1 &amp;&amp; tr[x].val &lt;= n) printf("%d ", tr[x].val); if(tr[x].son[1]) print(tr[x].son[1]);&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); root = build(1, n+2, 0); while(m--)&#123; scanf("%d%d", &amp;ql, &amp;qr); reverse(ql+1, qr+1); &#125; print(root); return 0;&#125; 二、非旋Treap同上。 Code#4123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int INF = 1e9;const int N = 100005;int n, m, ql, qr;struct Treap&#123; int val, size, son[2], hp; bool rev;&#125;tr[N];struct OPT_Treap&#123; int cnt, root; inline int newNode(int val)&#123; cnt++; tr[cnt].val = val; tr[cnt].hp = rand(); tr[cnt].size = 1; tr[cnt].son[0] = tr[cnt].son[1] = 0; tr[cnt].rev = 0; return cnt; &#125; inline void pushup(int id)&#123; if(!id) return; tr[id].size = 1; if(tr[id].son[0]) tr[id].size += tr[tr[id].son[0]].size; if(tr[id].son[1]) tr[id].size += tr[tr[id].son[1]].size; &#125; inline void pushdown(int id)&#123; if(!tr[id].rev) return; if(tr[id].son[0])&#123; int t = tr[id].son[0]; tr[t].rev ^= 1; swap(tr[t].son[0], tr[t].son[1]); &#125; if(tr[id].son[1])&#123; int t = tr[id].son[1]; tr[t].rev ^= 1; swap(tr[t].son[0], tr[t].son[1]); &#125; tr[id].rev ^= 1; &#125; int merge(int a, int b)&#123; if(a == 0) return b; if(b == 0) return a; if(tr[a].hp &lt;= tr[b].hp)&#123; pushdown(a); tr[a].son[1] = merge(tr[a].son[1], b); pushup(a); return a; &#125; else&#123; pushdown(b); tr[b].son[0] = merge(a, tr[b].son[0]); pushup(b); return b; &#125; &#125; void split(int id, int k, int &amp;x, int &amp;y)&#123; if(!id)&#123; x = 0, y = 0; return; &#125; pushdown(id); if(tr[tr[id].son[0]].size &gt;= k) y = id, split(tr[id].son[0], k, x, tr[id].son[0]); else x = id, split(tr[id].son[1], k - tr[tr[id].son[0]].size - 1, tr[id].son[1], y); pushup(id); &#125; inline void reverse(int l, int r)&#123; int L, t, R; split(root, l - 1, L, t); split(t, r - l + 1, t, R); tr[t].rev ^= 1; swap(tr[t].son[0], tr[t].son[1]); root = merge(merge(L, t), R); &#125; inline int build(int l, int r)&#123; if(l &gt; r) return 0; int mid = (l + r) &gt;&gt; 1; int t = newNode(mid); tr[t].son[0] = build(l, mid - 1); tr[t].son[1] = build(mid + 1, r); pushup(t); return t; &#125;&#125;BST;void print(int x)&#123; BST.pushdown(x); if(tr[x].son[0]) print(tr[x].son[0]); printf("%d ", tr[x].val); if(tr[x].son[1]) print(tr[x].son[1]);&#125;int main()&#123; srand(200127); scanf("%d%d", &amp;n, &amp;m); BST.root = BST.build(1, n); while(m--)&#123; scanf("%d%d", &amp;ql, &amp;qr); BST.reverse(ql, qr); &#125; print(BST.root); return 0;&#125; 二逼平衡树题目链接：luogu3380bzoj3196 解题思路一、线段树套Splay这道题与普通平衡树唯一的不同就在于所有查询都是区间查询，那么我们需要在平衡树外面套一层线段树以供区间查询，即线段树套平衡树。当然，并非真的要在每个线段树节点内建一颗平衡树，存一下在这个节点的平衡树的根的编号就行了。 查询区间内k的排名：在线段树上递归找查询的区间，在相应节点上的平衡树上查询比k小的数的个数，回溯时将所有答案相加得到了区间内比k小的数的个数，最后+1就是排名； 查询区间内排名为k的值：这个要麻烦一点，由于不同线段树节点上的答案不能进行合并，只能考虑二分答案，问题转化为二分出的答案在区间内的排名问题，即第一问； 修改某位置的值：修改即先删除原值，再插入新值；在线段树上找到该节点，对所经路线上所有线段树里的平衡树进行删除插入操作； 查询k在区间内的前驱：同第一问，只不过在更新答案时不是相加，而是取max； 查询k在区间内的后继：同第一问，只不过在更新答案时不是相加，而是取min。 Code#5123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((A[id].l+A[id].r)&gt;&gt;1)using namespace std;const int INF = 0x7fffffff;const int N = 50005;int n, m, a[N], opt, ql, qr, qk, qpos, tmp;struct splay&#123; int size, times, val, son[2], fa;&#125;B[(int)4e6];struct segTree&#123; int l, r, root;&#125;A[N&lt;&lt;2];struct OPT_splay&#123; int cnt; inline void pushup(int x)&#123; if(x)&#123; B[x].size = B[x].times; if(B[x].son[0]) B[x].size += B[B[x].son[0]].size; if(B[x].son[1]) B[x].size += B[B[x].son[1]].size; &#125; &#125; inline void rotate(int x, int kind)&#123; int y = B[x].fa, z = B[y].fa, a = B[y].son[kind], b = B[x].son[kind], c = B[x].son[!kind]; B[x].fa = z, B[x].son[kind] = y; B[y].fa = x, B[y].son[!kind] = b; B[z].son[B[z].son[1] == y] = x; B[b].fa = y; pushup(y), pushup(x); &#125; inline void splay(int x, int goal, int id)&#123; if(x == goal) return; while(B[x].fa != goal)&#123; int y = B[x].fa, z = B[y].fa; int isrson1 = B[y].son[1] == x, isrson2 = B[z].son[1] == y; if(z == goal) rotate(x, !isrson1); else&#123; if(isrson1 == isrson2) rotate(y, !isrson2); else rotate(x, !isrson1); rotate(x, !isrson2); &#125; &#125; if(goal == 0) A[id].root = x; &#125; inline int newNode(int val, int fa)&#123; cnt++; B[cnt].fa = fa; B[cnt].val = val; B[cnt].size = B[cnt].times = 1; B[cnt].son[0] = B[cnt].son[1] = 0; return cnt; &#125; inline int getPre(int x, int id)&#123; int now = A[id].root, res = -INF; while(now)&#123; if(B[now].val &lt; x)&#123; res = max(res, B[now].val); now = B[now].son[1]; &#125; else now = B[now].son[0]; &#125; return res; &#125; inline int getSub(int x, int id)&#123; int now = A[id].root, res = INF; while(now)&#123; if(B[now].val &gt; x)&#123; res = min(res, B[now].val); now = B[now].son[0]; &#125; else now = B[now].son[1]; &#125; return res; &#125; inline int select(int x, int id)&#123; int now = A[id].root; while(now)&#123; if(B[now].val == x) break; else if(B[now].val &gt; x) now = B[now].son[0]; else if(B[now].val &lt; x) now = B[now].son[1]; &#125; if(!now) return -1; return now; &#125; inline int getRank(int x, int id)&#123; if(select(x, id) != -1) splay(select(x, id), 0, id); else splay(select(getSub(x, id), id), 0, id); return B[B[A[id].root].son[0]].size; &#125; inline void insert(int val, int id)&#123; splay(select(getPre(val, id), id), 0, id); splay(select(getSub(val, id), id), A[id].root, id); int t = B[B[A[id].root].son[1]].son[0]; if(!t) B[B[A[id].root].son[1]].son[0] = newNode(val, B[A[id].root].son[1]); else B[t].times++, B[t].size++; pushup(B[A[id].root].son[1]); pushup(A[id].root); &#125; inline void del(int val, int id)&#123; splay(select(getPre(val, id), id), 0, id); splay(select(getSub(val, id), id), A[id].root, id); int t = B[B[A[id].root].son[1]].son[0]; if(!t || B[t].times == 0) return; B[t].times--, B[t].size--; if(B[t].times == 0) B[B[A[id].root].son[1]].son[0] = 0; pushup(B[A[id].root].son[1]); pushup(A[id].root); &#125;&#125;Splay;struct OPT_segTree&#123; void build(int id, int l, int r)&#123; A[id].root = Splay.newNode(-INF, 0); B[A[id].root].son[1] = Splay.newNode(INF, A[id].root); A[id].l = l, A[id].r = r; if(A[id].l == A[id].r) return; build(lid, l, mid); build(rid, mid+1, r); &#125; void insert(int id, int pos, int val)&#123; Splay.insert(val, id); if(A[id].l == A[id].r) return; if(pos &lt;= mid) insert(lid, pos, val); else insert(rid, pos, val); &#125; int getRank(int id, int l, int r, int x)&#123; if(A[id].l == l &amp;&amp; A[id].r == r) return Splay.getRank(x, id) - 1; if(r &lt;= mid) return getRank(lid, l, r, x); else if(l &gt; mid) return getRank(rid, l, r, x); else return getRank(lid, l, mid, x) + getRank(rid, mid+1, r, x); &#125; int getKth(int l, int r, int k)&#123; int ans = -1, L = 0, R = 1e8; while(L &lt;= R)&#123; int Mid = (L + R) &gt;&gt; 1; int t1 = getRank(1, l, r, Mid) + 1; int t2 = getRank(1, l, r, Mid+1); if(t1 &lt;= k &amp;&amp; k &lt;= t2)&#123; ans = Mid; break; &#125; if(t2 &lt; k) L = Mid+1; else if(t1 &gt; k) R = Mid-1; &#125; return ans; &#125; void modify(int id, int pos, int val)&#123; Splay.del(a[pos], id); Splay.insert(val, id); if(A[id].l == A[id].r) return; if(pos &lt;= mid) modify(lid, pos, val); else modify(rid, pos, val); &#125; int getPre(int id, int l, int r, int x)&#123; if(A[id].l == l &amp;&amp; A[id].r == r) return Splay.getPre(x, id); if(r &lt;= mid) return getPre(lid, l, r, x); else if(l &gt; mid) return getPre(rid, l, r, x); else return max(getPre(lid, l, mid, x), getPre(rid, mid+1, r, x)); &#125; int getSub(int id, int l, int r, int x)&#123; if(A[id].l == l &amp;&amp; A[id].r == r) return Splay.getSub(x, id); if(r &lt;= mid) return getSub(lid, l, r, x); else if(l &gt; mid) return getSub(rid, l, r, x); else return min(getSub(lid, l, mid, x), getSub(rid, mid+1, r, x)); &#125;&#125;Seg;int main()&#123; scanf("%d%d", &amp;n, &amp;m); Seg.build(1, 1, n); for(int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;a[i]); Seg.insert(1, i, a[i]); &#125; while(m--)&#123; scanf("%d", &amp;opt); if(opt == 3) scanf("%d%d", &amp;qpos, &amp;qk); else scanf("%d%d%d", &amp;ql, &amp;qr, &amp;qk); if(opt == 1) printf("%d\n", Seg.getRank(1, ql, qr, qk) + 1); else if(opt == 2) printf("%d\n", Seg.getKth(ql, qr, qk)); else if(opt == 3) Seg.modify(1, qpos, qk), a[qpos] = qk; else if(opt == 4) printf("%d\n", Seg.getPre(1, ql, qr, qk)); else if(opt == 5) printf("%d\n", Seg.getSub(1, ql, qr, qk)); &#125; return 0;&#125; 二、线段树套非旋Treap同上。 Code#6123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((A[id].l + A[id].r) &gt;&gt; 1)using namespace std;const int INF = 0x7fffffff;const int N = 50005;int n, m, opt, ql, qr, qk, qpos, a[N];struct Treap&#123; int val, son[2], size, hp;&#125;B[(int)4e6];struct segTree&#123; int l, r, root;&#125;A[N&lt;&lt;2];struct OPT_Treap&#123; int cnt; inline int newNode(int val)&#123; cnt++; B[cnt].val = val; B[cnt].son[0] = B[cnt].son[1] = 0; B[cnt].size = 1; B[cnt].hp = rand(); return cnt; &#125; inline void pushup(int id)&#123; if(!id) return; B[id].size = 1; if(B[id].son[0]) B[id].size += B[B[id].son[0]].size; if(B[id].son[1]) B[id].size += B[B[id].son[1]].size; &#125; int merge(int a, int b)&#123; if(a == 0) return b; if(b == 0) return a; if(B[a].hp &lt;= B[b].hp)&#123; B[a].son[1] = merge(B[a].son[1], b); pushup(a); return a; &#125; else&#123; B[b].son[0] = merge(a, B[b].son[0]); pushup(b); return b; &#125; &#125; void split(int id, int k, int &amp;x, int &amp;y)&#123; if(!id)&#123; x = 0, y = 0; return; &#125; if(B[id].val &gt; k) y = id, split(B[id].son[0], k, x, B[id].son[0]); else x = id, split(B[id].son[1], k, B[id].son[1], y); pushup(id); &#125; inline void insert(int &amp;rt, int val)&#123; int l = 0, r = 0; split(rt, val, l, r); int t = newNode(val); rt = merge(merge(l, t), r); &#125; inline void del(int &amp;rt, int val)&#123; int l = 0, r = 0, t = 0; split(rt, val - 1, l, t); split(t, val, t, r); t = merge(B[t].son[0], B[t].son[1]); rt = merge(merge(l, t), r); &#125; inline int getRank(int &amp;rt, int x)&#123; int l = 0, r = 0; split(rt, x - 1, l, r); int ans = B[l].size + 1; rt = merge(l, r); return ans; &#125; inline int getPre(int &amp;rt, int x)&#123; int now = rt, ans = -INF; while(now)&#123; if(B[now].val &lt; x)&#123; ans = max(ans, B[now].val); now = B[now].son[1]; &#125; else now = B[now].son[0]; &#125; return ans; &#125; inline int getSub(int &amp;rt, int x)&#123; int now = rt, ans = INF; while(now)&#123; if(B[now].val &gt; x)&#123; ans = min(ans, B[now].val); now = B[now].son[0]; &#125; else now = B[now].son[1]; &#125; return ans; &#125;&#125;BST;struct OPT_segTree&#123; void build(int id, int l, int r)&#123; A[id].l = l, A[id].r = r; A[id].root = BST.newNode(INF); if(A[id].l == A[id].r) return; build(lid, l, mid); build(rid, mid+1, r); &#125; void insert(int id, int pos, int val)&#123; BST.insert(A[id].root, val); if(A[id].l == A[id].r) return; if(pos &lt;= mid) insert(lid, pos, val); else insert(rid, pos, val); &#125; void modify(int id, int pos, int val)&#123; BST.del(A[id].root, a[pos]); BST.insert(A[id].root, val); if(A[id].l == A[id].r) return; if(pos &lt;= mid) modify(lid, pos, val); else modify(rid, pos, val); &#125; int query(int id, int l, int r, int x, int kind)&#123; if(A[id].l == l &amp;&amp; A[id].r == r)&#123; if(kind == 0) return BST.getRank(A[id].root, x); if(kind == 1) return BST.getPre(A[id].root, x); if(kind == 2) return BST.getSub(A[id].root, x); &#125; if(r &lt;= mid) return query(lid, l, r, x, kind); else if(l &gt; mid) return query(rid, l, r, x, kind); else&#123; if(kind == 0) return query(lid, l, mid, x, kind) + query(rid, mid+1, r, x, kind) - 1; if(kind == 1) return max(query(lid, l, mid, x, kind), query(rid, mid+1, r, x, kind)); if(kind == 2) return min(query(lid, l, mid, x, kind), query(rid, mid+1, r, x, kind)); &#125; &#125; int getKth(int l, int r, int k)&#123; int L = 0, R = 1e8, ans = 0; while(L &lt;= R)&#123; int Mid = (L + R) &gt;&gt; 1; int t1 = query(1, l, r, Mid, 0); int t2 = query(1, l, r, Mid+1, 0) - 1; if(t1 &lt;= k &amp;&amp; k &lt;= t2)&#123; ans = Mid; break; &#125; else if(t2 &lt; k) L = Mid + 1; else if(t1 &gt; k) R = Mid - 1; &#125; return ans; &#125;&#125;Seg;int main()&#123; srand(200127); scanf("%d%d", &amp;n, &amp;m); BST.cnt = 0; Seg.build(1, 1, n); for(int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;a[i]); Seg.insert(1, i, a[i]); &#125; while(m--)&#123; scanf("%d", &amp;opt); if(opt == 3) scanf("%d%d", &amp;qpos, &amp;qk); else scanf("%d%d%d", &amp;ql, &amp;qr, &amp;qk); if(opt == 1) printf("%d\n", Seg.query(1, ql, qr, qk, 0)); else if(opt == 2) printf("%d\n", Seg.getKth(ql, qr, qk)); else if(opt == 3) Seg.modify(1, qpos, qk), a[qpos] = qk; else if(opt == 4) printf("%d\n", Seg.query(1, ql, qr, qk, 1)); else if(opt == 5) printf("%d\n", Seg.query(1, ql, qr, qk, 2)); &#125; return 0;&#125; 三、树状数组套值域线段树（带修改主席树）hmm…这道题其实可以不用平衡树做，因为要求第k大，自然而然想到主席树可以做到，但这道题有修改操作，普通的维护前缀和的主席树修改一次就要把后面所有树都改了，所以修改一次的时间复杂度就是$O(NlogN)$的，显然不行。于是，带修改主席树应运而生：我们不再让值域线段树们维护前缀和了，而是让它们维护树状数组上对应的约$logN$个点，这样一次修改的时间复杂度就降到了$O(log_2^2N)$。 查询区间内k的排名：相当于找比k小的数有多少个（答案是个数+1）。在值域线段树上二分查找k时，如果往右儿子走，就把左儿子大小加进答案里去就行了； 查询区间内排名为k的值：找到树状数组里面相关的值域线段树（存进一个数组，见代码中的A[]和B[]），算出当前点左儿子大小，再决定是向左还是向右二分下去； 修改某位置的值：修改即先删除原值，再插入新值；找到树状数组里面相关的值域线段树，对每棵树都进行删除和插入操作； 查询k在区间内的前驱：查询区间内比k小的数有多少个，如果没有，输出-INF；否则输出区间内相应排名的值； 查询k在区间内的后继：查询区间内比k大的数有多少个，如果没有，输出INF；否则输出区间内相应排名的值。 涉及到值域线段树一般都要离散化，以保证空间；同时，这道题还必须动态开点才能保证空间。 Code#7纪念我的第一份超过200行的代码…123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int INF = 0x7fffffff;const int N = 50005;int n, m, a[N], t[N&lt;&lt;1], f[N&lt;&lt;1], MX, A[20], B[20];//因为有询问操作，t[]和f[]空间一定要开够!int root[N], cnt;struct Query&#123; int opt, l, r, k, pos;&#125;q[N];struct segTree&#123; int size, son[2];&#125;tr[N*15*15];inline void readin()&#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]), t[++t[0]] = a[i]; for(int i = 1; i &lt;= m; i++)&#123; scanf("%d", &amp;q[i].opt); if(q[i].opt != 3)&#123; scanf("%d%d%d", &amp;q[i].l, &amp;q[i].r, &amp;q[i].k); if(q[i].opt != 2) t[++t[0]] = q[i].k; &#125; else&#123; scanf("%d%d", &amp;q[i].pos, &amp;q[i].k); t[++t[0]] = q[i].k; &#125; &#125;&#125;inline void disc()&#123; sort(t+1, t+t[0]+1); int len = unique(t+1, t+t[0]+1) - (t+1); for(int i = 1; i &lt;= n; i++)&#123; int temp = lower_bound(t+1, t+len+1, a[i]) - t; f[temp] = a[i], a[i] = temp; MX = max(MX, temp); &#125; for(int i = 1; i &lt;= m; i++)&#123; if(q[i].opt == 2) continue; int temp = lower_bound(t+1, t+len+1, q[i].k) - t; f[temp] = q[i].k, q[i].k = temp; MX = max(MX, temp); &#125; f[MX+1] = -INF; f[MX+2] = INF;&#125;inline int lowbit(int x)&#123; return x &amp; -x; &#125;inline void init1(int x, int X[])&#123; X[0] = 0; for(int i = x; i; i -= lowbit(i))&#123; if(!root[i]) root[i] = ++cnt; X[++X[0]] = root[i]; &#125;&#125;inline void init2(int x, int X[])&#123; X[0] = 0; for(int i = x; i &lt;= n; i += lowbit(i))&#123; if(!root[i]) root[i] = ++cnt; X[++X[0]] = root[i]; &#125;&#125;inline void pushup(int id)&#123; tr[id].size = tr[tr[id].son[0]].size + tr[tr[id].son[1]].size;&#125;void insert(int &amp;id, int l, int r, int val)&#123; if(!id) id = ++cnt; if(l == r)&#123; tr[id].size++; return; &#125; int mid = (l + r) &gt;&gt; 1; if(val &lt;= mid) insert(tr[id].son[0], l, mid, val); else insert(tr[id].son[1], mid+1, r, val); pushup(id);&#125;void del(int &amp;id, int l, int r, int val)&#123; if(!id) id = ++cnt; if(l == r)&#123; if(tr[id].size &gt; 0) tr[id].size--; return; &#125; int mid = (l + r) &gt;&gt; 1; if(val &lt;= mid) del(tr[id].son[0], l, mid, val); else del(tr[id].son[1], mid+1, r, val); pushup(id);&#125;int getSmaller(int l, int r, int k)&#123; if(l == r) return 0; int mid = (l + r) &gt;&gt; 1; if(k &lt;= mid)&#123; for(int i = 1; i &lt;= A[0]; i++)&#123; if(!tr[A[i]].son[0]) tr[A[i]].son[0] = ++cnt; A[i] = tr[A[i]].son[0]; &#125; for(int i = 1; i &lt;= B[0]; i++)&#123; if(!tr[B[i]].son[0]) tr[B[i]].son[0] = ++cnt; B[i] = tr[B[i]].son[0]; &#125; return getSmaller(l, mid, k); &#125; else&#123; int res = 0; for(int i = 1; i &lt;= A[0]; i++)&#123; if(!tr[A[i]].son[1]) tr[A[i]].son[1] = ++cnt; res -= tr[tr[A[i]].son[0]].size; A[i] = tr[A[i]].son[1]; &#125; for(int i = 1; i &lt;= B[0]; i++)&#123; if(!tr[B[i]].son[1]) tr[B[i]].son[1] = ++cnt; res += tr[tr[B[i]].son[0]].size; B[i] = tr[B[i]].son[1]; &#125; return res + getSmaller(mid+1, r, k); &#125;&#125;int getBigger(int l, int r, int k)&#123; if(l == r) return 0; int mid = (l + r) &gt;&gt; 1; if(k &lt;= mid)&#123; int res = 0; for(int i = 1; i &lt;= A[0]; i++)&#123; if(!tr[A[i]].son[0]) tr[A[i]].son[0] = ++cnt; res -= tr[tr[A[i]].son[1]].size; A[i] = tr[A[i]].son[0]; &#125; for(int i = 1; i &lt;= B[0]; i++)&#123; if(!tr[B[i]].son[0]) tr[B[i]].son[0] = ++cnt; res += tr[tr[B[i]].son[1]].size; B[i] = tr[B[i]].son[0]; &#125; return res + getBigger(l, mid, k); &#125; else&#123; for(int i = 1; i &lt;= A[0]; i++)&#123; if(!tr[A[i]].son[1]) tr[A[i]].son[1] = ++cnt; A[i] = tr[A[i]].son[1]; &#125; for(int i = 1; i &lt;= B[0]; i++)&#123; if(!tr[B[i]].son[1]) tr[B[i]].son[1] = ++cnt; B[i] = tr[B[i]].son[1]; &#125; return getBigger(mid+1, r, k); &#125;&#125;int getKth(int l, int r, int k)&#123; if(l == r) return l; int lsize = 0; for(int i = 1; i &lt;= A[0]; i++) lsize -= tr[tr[A[i]].son[0]].size; for(int i = 1; i &lt;= B[0]; i++) lsize += tr[tr[B[i]].son[0]].size; int mid = (l + r) &gt;&gt; 1; if(lsize &gt;= k)&#123; for(int i = 1; i &lt;= A[0]; i++)&#123; if(!tr[A[i]].son[0]) tr[A[i]].son[0] = ++cnt; A[i] = tr[A[i]].son[0]; &#125; for(int i = 1; i &lt;= B[0]; i++)&#123; if(!tr[B[i]].son[0]) tr[B[i]].son[0] = ++cnt; B[i] = tr[B[i]].son[0]; &#125; return getKth(l, mid, k); &#125; else&#123; for(int i = 1; i &lt;= A[0]; i++)&#123; if(!tr[A[i]].son[1]) tr[A[i]].son[1] = ++cnt; A[i] = tr[A[i]].son[1]; &#125; for(int i = 1; i &lt;= B[0]; i++)&#123; if(!tr[B[i]].son[1]) tr[B[i]].son[1] = ++cnt; B[i] = tr[B[i]].son[1]; &#125; return getKth(mid+1, r, k - lsize); &#125;&#125;inline int getPre(int ql, int qr, int k)&#123; init1(ql-1, A), init1(qr, B); int rank = getSmaller(1, MX, k) + 1; init1(ql-1, A), init1(qr, B); if(rank == 1) return MX+1; else return getKth(1, MX, rank-1);&#125;inline int getSub(int ql, int qr, int k)&#123; init1(ql-1, A), init1(qr, B); int rank = getBigger(1, MX, k) + 1; init1(ql-1, A), init1(qr, B); if(rank == 1) return MX+2; else return getKth(1, MX, qr - ql + 3 - rank);&#125;int main()&#123; readin(); disc(); for(int i = 1; i &lt;= n; i++)&#123; init2(i, A); for(int j = 1; j &lt;= A[0]; j++) insert(A[j], 1, MX, a[i]); &#125; for(int i = 1; i &lt;= m; i++)&#123; switch(q[i].opt)&#123; case 1: init1(q[i].l-1, A); init1(q[i].r, B); printf("%d\n", getSmaller(1, MX, q[i].k) + 1); break; case 2: init1(q[i].l-1, A); init1(q[i].r, B); printf("%d\n", f[getKth(1, MX, q[i].k)]); break; case 3:&#123; init2(q[i].pos, A); for(int j = 1; j &lt;= A[0]; j++)&#123; del(A[j], 1, MX, a[q[i].pos]); insert(A[j], 1, MX, q[i].k); &#125; a[q[i].pos] = q[i].k; break; &#125; case 4: printf("%d\n", f[getPre(q[i].l, q[i].r, q[i].k)]); break; case 5: printf("%d\n", f[getSub(q[i].l, q[i].r, q[i].k)]); break; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>平衡树</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ZJOI2008]树的统计（树链剖分，线段树）]]></title>
    <url>%2F2018%2F04%2F29%2FZJOI2008-%E6%A0%91%E7%9A%84%E7%BB%9F%E8%AE%A1%EF%BC%88%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%EF%BC%8C%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述一棵树上有n个节点，编号分别为1到n，每个节点都有一个权值w。我们将以下面的形式来要求你对这棵树完成一些操作：I. CHANGE u t : 把结点u的权值改为tII. QMAX u v: 询问从点u到点v的路径上的节点的最大权值III. QSUM u v: 询问从点u到点v的路径上的节点的权值和注意：从点u到点v的路径上的节点包括u和v本身 输入格式输入文件的第一行为一个整数n，表示节点的个数。接下来n – 1行，每行2个整数a和b，表示节点a和节点b之间有一条边相连。接下来一行n个整数，第i个整数wi表示节点i的权值。接下来1行，为一个整数q，表示操作的总数。接下来q行，每行一个操作，以“CHANGE u t”或者“QMAX u v”或者“QSUM u v”的形式给出。 输出格式对于每个“QMAX”或者“QSUM”的操作，每行输出一个整数表示要求输出的结果。 输入样例12345678910111213141516171841 22 34 14 2 1 312QMAX 3 4QMAX 3 3QMAX 3 2QMAX 2 3QSUM 3 4QSUM 2 1CHANGE 1 5QMAX 3 4CHANGE 3 6QMAX 3 4QMAX 2 4QSUM 3 4 输出样例12345678910412210656516 说明对于100％的数据，保证$1 \leq n \leq 30000，0 \leq q \leq 200000$；中途操作中保证每个节点的权值w在$-30000$到$30000$之间。 解题思路这是一道树链剖分的模板题了。注意权值有可能为负数，所以求最大值时要初始化为-INF 复杂度$O(n \log ^2n)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const LL INF = 1e16;const int N = 30005;int n, u, v, q;char opt[10];LL a[N];struct Edge&#123; int nxt, to;&#125;edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to)&#123; edge[++edgeNum].nxt = head[from]; edge[edgeNum].to = to; head[from] = edgeNum;&#125;int size[N], fa[N], dep[N], son[N];void dfs1(int x, int f, int depth)&#123; size[x] = 1, fa[x] = f, dep[x] = depth, son[x] = 0; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(edge[i].to == f) continue; dfs1(edge[i].to, x, depth+1); size[x] += size[edge[i].to]; if(size[edge[i].to] &gt; size[son[x]]) son[x] = edge[i].to; &#125;&#125;int st[N], ed[N], belong[N], dfsClock, fun[N];void dfs2(int x, int top)&#123; st[x] = ++dfsClock, fun[dfsClock] = x; belong[x] = top; if(son[x]) dfs2(son[x], top); for(int i = head[x]; i; i = edge[i].nxt)&#123; if(edge[i].to == fa[x] || edge[i].to == son[x]) continue; dfs2(edge[i].to, edge[i].to); &#125; ed[x] = dfsClock;&#125;#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((tr[id].l+tr[id].r)&gt;&gt;1)struct segTree&#123; int l, r; LL mx, sum; segTree()&#123; l = r = 0; sum = 0ll; mx = -INF; &#125;&#125;tr[N&lt;&lt;2];struct &#123; inline void pushup(int id)&#123; tr[id].mx = max(tr[lid].mx, tr[rid].mx); tr[id].sum = tr[lid].sum + tr[rid].sum; &#125; void build(int id, int l, int r)&#123; tr[id].l = l, tr[id].r = r; if(tr[id].l == tr[id].r)&#123; tr[id].mx = tr[id].sum = a[fun[l]]; return; &#125; build(lid, l, mid); build(rid, mid+1, r); pushup(id); &#125; LL query(int id, int l, int r, int k)&#123; if(tr[id].l == l &amp;&amp; tr[id].r == r) return k == 0 ? tr[id].mx : tr[id].sum; if(r &lt;= mid) return query(lid, l, r, k); else if(l &gt; mid) return query(rid, l, r, k); else return k == 0 ? max(query(lid, l, mid, k), query(rid, mid+1, r, k)) : query(lid, l, mid, k) + query(rid, mid+1, r, k); &#125; void modify(int id, int pos, LL v)&#123; if(tr[id].l == tr[id].r)&#123; tr[id].sum = tr[id].mx = v; return; &#125; if(pos &lt;= mid) modify(lid, pos, v); else modify(rid, pos, v); pushup(id); &#125;&#125;seg;LL query(int u, int v, int k)&#123; LL res = k == 0 ? -INF : 0; while(belong[u] != belong[v])&#123; if(dep[belong[u]] &lt; dep[belong[v]]) swap(u, v); res = k == 0 ? max(res, seg.query(1, st[belong[u]], st[u], 0)) : res + seg.query(1, st[belong[u]], st[u], 1); u = fa[belong[u]]; &#125; if(dep[u] &gt; dep[v]) swap(u, v); res = k == 0 ? max(res, seg.query(1, st[u], st[v], 0)) : res + seg.query(1, st[u], st[v], 1); return res;&#125;int main()&#123; scanf("%d", &amp;n); for(int i = 1; i &lt; n; i++)&#123; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v); addEdge(v, u); &#125; for(int i = 1; i &lt;= n; i++) scanf("%lld", &amp;a[i]); dfs1(1, 1, 1); dfs2(1, 1); seg.build(1, 1, n); scanf("%d", &amp;q); while(q--)&#123; scanf("%s%d%d", opt, &amp;u, &amp;v); if(opt[0] == 'C') seg.modify(1, st[u], 1ll*v); else if(opt[1] == 'M') printf("%lld\n", query(u, v, 0)); else if(opt[1] == 'S') printf("%lld\n", query(u, v, 1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
        <category>图论</category>
        <category>树</category>
        <category>树链剖分</category>
      </categories>
      <tags>
        <tag>ZJOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDOI2011]染色（树链剖分，线段树）]]></title>
    <url>%2F2018%2F04%2F28%2FSDOI2011-%E6%9F%93%E8%89%B2%EF%BC%88%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%EF%BC%8C%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目Description给定一棵有n个节点的无根树和m个操作，操作有2类：1、将节点a到节点b路径上所有点都染成颜色c；2、询问节点a到节点b路径上的颜色段数量（连续相同颜色被认为是同一段），如“112221”由3段组成：“11”、“222”和“1”。请你写一个程序依次完成这m个操作。 Input第一行包含2个整数n和m，分别表示节点数和操作数；第二行包含n个正整数表示n个节点的初始颜色下面 n-1 行每行包含两个整数x和y，表示x和y之间有一条无向边。下面 m 行每行描述一个操作：“C a b c”表示这是一个染色操作，把节点a到节点b路径上所有点（包括a和b）都染成颜色c；“Q a b”表示这是一个询问操作，询问节点a到节点b（包括a和b）路径上的颜色段数量。 Output对于每个询问操作，输出一行答案。 Sample Input1234567891011126 52 2 1 2 1 11 21 32 42 52 6Q 3 5C 2 1 1Q 3 5C 5 1 2Q 3 5 Sample Output123312 HINT$N \leq 10^5, M \leq 10^5$，所有的颜色C为整数且在$[0, 10^9]$之间。 解题思路这道题思路应该是很好想到的——树链剖分+线段树显然，合并两个颜色段时，如果合并点两侧颜色相同，那么颜色段数量为左右两段数量之和再减一，否则就是它们的和。根据这个基本性质——线段树维护3个值：颜色段数量(cnt)、左端颜色(lcol)、右端颜色(rcol)，于是tr[id].cnt = tr[lid].cnt + tr[rid].cnt - (tr[lid].rcol == tr[rid].lcol);树链剖分询问时（即往上“跳”时），记录一下上一次询问的端点颜色，如果本次询问的相应端点颜色在合并点处与上次询问端点颜色相等，就要减一。至此本题解决。 复杂度$O(n\log ^2n)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 100005;int n, m, a[N], u, v, qa, qb, qc;char opt[2];struct Edge&#123; int nxt, to;&#125;edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to)&#123; edge[++edgeNum].nxt = head[from]; edge[edgeNum].to = to; head[from] = edgeNum;&#125;int fa[N], dep[N], size[N], son[N];void dfs1(int x, int f, int depth)&#123; fa[x] = f, dep[x] = depth, size[x] = 1, son[x] = 0; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(edge[i].to == f) continue; dfs1(edge[i].to, x, depth+1); size[x] += size[edge[i].to]; if(size[edge[i].to] &gt; size[son[x]]) son[x] = edge[i].to; &#125;&#125;int belong[N], st[N], ed[N], dfsClock, fun[N];void dfs2(int x, int top)&#123; st[x] = ++dfsClock, fun[dfsClock] = x; belong[x] = top; if(son[x]) dfs2(son[x], top); for(int i = head[x]; i; i = edge[i].nxt)&#123; if(edge[i].to == fa[x] || edge[i].to == son[x]) continue; dfs2(edge[i].to, edge[i].to); &#125; ed[x] = dfsClock;&#125;#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((tr[id].l+tr[id].r)&gt;&gt;1)struct segTree&#123; int l, r, lcol, rcol, cnt, cov; segTree()&#123; l = r = lcol = rcol = cnt = cov = 0; &#125;&#125;tr[N&lt;&lt;2];struct &#123; inline void pushup(int id)&#123; tr[id].cnt = tr[lid].cnt + tr[rid].cnt - (tr[lid].rcol == tr[rid].lcol); tr[id].lcol = tr[lid].lcol; tr[id].rcol = tr[rid].rcol; &#125; inline void pushdown(int id)&#123; if(tr[id].l == tr[id].r) return; if(tr[id].cov)&#123; int t = tr[id].cov; tr[lid].cov = tr[rid].cov = t; tr[lid].lcol = tr[lid].rcol = t; tr[rid].lcol = tr[rid].rcol = t; tr[lid].cnt = tr[rid].cnt = 1; tr[id].cov = 0; &#125; &#125; void build(int id, int l, int r)&#123; tr[id].l = l, tr[id].r = r; if(tr[id].l == tr[id].r)&#123; tr[id].cnt = 1; tr[id].lcol = tr[id].rcol = a[fun[l]]; return; &#125; build(lid, l, mid); build(rid, mid+1, r); pushup(id); &#125; void cover(int id, int l, int r, int c)&#123; pushdown(id); if(tr[id].l == l &amp;&amp; tr[id].r == r)&#123; tr[id].cov = c; tr[id].cnt = 1; tr[id].lcol = tr[id].rcol = c; return; &#125; if(r &lt;= mid) cover(lid, l, r, c); else if(l &gt; mid) cover(rid, l, r, c); else cover(lid, l, mid, c), cover(rid, mid+1, r, c); pushup(id); &#125; segTree query(int id, int l, int r)&#123; pushdown(id); if(tr[id].l == l &amp;&amp; tr[id].r == r) return tr[id]; if(r &lt;= mid) return query(lid, l, r); else if(l &gt; mid) return query(rid, l, r); else&#123; segTree t1 = query(lid, l, mid), t2 = query(rid, mid+1, r), t; t.cnt = t1.cnt + t2.cnt - (t1.rcol == t2.lcol); t.lcol = t1.lcol, t.rcol = t2.rcol; return t; &#125; &#125;&#125;seg;void cover(int u, int v, int c)&#123; while(belong[u] != belong[v])&#123; if(dep[belong[u]] &lt; dep[belong[v]]) swap(u, v); seg.cover(1, st[belong[u]], st[u], c); u = fa[belong[u]]; &#125; if(dep[u] &gt; dep[v]) swap(u, v); seg.cover(1, st[u], st[v], c);&#125;int query(int u, int v)&#123; int ans = 0, lastu = 0, lastv = 0; while(belong[u] != belong[v])&#123; if(dep[belong[u]] &lt; dep[belong[v]]) swap(u, v), swap(lastu, lastv); segTree t = seg.query(1, st[belong[u]], st[u]); ans += t.cnt - (t.rcol == lastu); lastu = t.lcol; u = fa[belong[u]]; &#125; if(dep[u] &gt; dep[v]) swap(u, v), swap(lastu, lastv); segTree t = seg.query(1, st[u], st[v]); ans += t.cnt - (t.lcol == lastu) - (t.rcol == lastv); return ans;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]), a[i]++; for(int i = 1; i &lt; n; i++)&#123; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v); addEdge(v, u); &#125; dfs1(1, 1, 1); dfs2(1, 1); seg.build(1, 1, n); while(m--)&#123; scanf("%s", opt); if(opt[0] == 'C')&#123; scanf("%d%d%d", &amp;qa, &amp;qb, &amp;qc); qc++; cover(qa, qb, qc); &#125; else if(opt[0] == 'Q')&#123; scanf("%d%d", &amp;qa, &amp;qb); printf("%d\n", query(qa, qb)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
        <category>图论</category>
        <category>树</category>
        <category>树链剖分</category>
      </categories>
      <tags>
        <tag>SDOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点分治学习笔记]]></title>
    <url>%2F2018%2F04%2F22%2F%E7%82%B9%E5%88%86%E6%B2%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[简介点分治主要解决树上路径问题，其主要思想是把一颗有根树以根为分治点分为一个森林（其实就是各个子树），解决经过当前根的路径后在子树里继续分治，从而将问题“分而治之”。 这里面，根的选择非常重要。为了保证复杂度，我们的分治点应该尽可能的“居中”，所以分治点一般选择正在处理的树的重心。 套路 找到当前树的重心作为根 解决通过这个根的路径的答案（一般有两种方法，一种是通过与子树容斥，一种是直接计算子树贡献） 递归解决子树 实现求重心12345678910111213//root = 0, mxson[0] = INF, sum = n;//root = 0, mxson[0] = INF, sum = size[edge[i].to];void findRoot(int x, int f)&#123; size[x] = 1, mxson[x] = 0; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to] || edge[i].to == f) continue; findRoot(edge[i].to, x); size[x] += size[edge[i].to]; mxson[x] = max(mxson[x], size[edge[i].to]); &#125; mxson[x] = max(mxson[x], sum - size[x]); if(mxson[x] &lt; mxson[root]) root = x;&#125; size[]是子树大小，mxson[]是最大子树大小，root是重心，sum是当前整颗树的大小注意每次 findRoot() 前要初始化 root 和 sum 分治计算1234567891011void solve(int x)&#123; cal(x);//如果此处计算时将子树中一些不合法的路径的贡献也算进去了，那么需要容斥，即在下方*处减掉子树贡献；如果不容斥，就直接利用每颗子树的信息计算答案 vis[x] = 1; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to]) continue; cal(edge[i].to);//* root = 0, sum = size[edge[i].to], mxson[0] = INF; findRoot(edge[i].to, 0); solve(root); &#125;&#125; vis[]标记此点是否计算过，cal()计算以x为根、经过根的路径的答案 注意事项不要再分治时用memset O(n) 地进行初始化，否则点分治好不容易保证的复杂度就被毁了。 练习poj1741 tree题意给一棵树，边有边权，问两点之间的距离小于等于K的点对有多少个。题解点分治时用容斥做：计算以x为根的子树时直接将求得的dis排序后O(n)求答案，然后再减去每个子树中被统计了的不合法答案Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int INF = 1e9;const int N = 10005;int n, k, u, v, p;struct Edge&#123; int nxt, to, dis;&#125;edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to, int dis)&#123; edge[++edgeNum].nxt = head[from]; edge[edgeNum].to = to; edge[edgeNum].dis = dis; head[from] = edgeNum;&#125;bool vis[N];int root, sum, size[N], mxson[N];void findRoot(int x, int f)&#123; size[x] = 1, mxson[x] = 0; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(edge[i].to == f || vis[edge[i].to]) continue; findRoot(edge[i].to, x); size[x] += size[edge[i].to]; mxson[x] = max(mxson[x], size[edge[i].to]); &#125; mxson[x] = max(mxson[x], sum - size[x]); if(mxson[x] &lt; mxson[root]) root = x;&#125;int dis[N], ans;void getDis(int x, int f, int d)&#123; dis[++dis[0]] = d; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(edge[i].to == f || vis[edge[i].to]) continue; getDis(edge[i].to, x, d + edge[i].dis); &#125;&#125;int cal(int x, int d)&#123; int res = 0; for(int i = 1; i &lt;= dis[0]; i++) dis[i] = 0; dis[0] = 0; getDis(x, 0, d); sort(dis+1, dis+dis[0]+1); int l = 1, r = dis[0]; while(l &lt; r)&#123; if(dis[l] + dis[r] &lt;= k) res += r - l, l++; else r--; &#125; return res;&#125;void solve(int x)&#123; ans += cal(x, 0); vis[x] = 1; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to]) continue; ans -= cal(edge[i].to, edge[i].dis); root = 0, mxson[0] = INF, sum = size[edge[i].to]; findRoot(edge[i].to, 0); solve(root); &#125;&#125;void init()&#123; memset(edge, 0, sizeof edge); memset(head, 0, sizeof head); edgeNum = 0; root = sum = ans = 0; memset(size, 0, sizeof size); memset(mxson, 0, sizeof mxson); memset(vis, 0, sizeof vis);&#125;int main()&#123; while(1)&#123; scanf("%d%d", &amp;n, &amp;k); if(n == 0 &amp;&amp; k == 0) break; init(); for(int i = 1; i &lt; n; i++)&#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;p); addEdge(u, v, p); addEdge(v, u, p); &#125; sum = n, root = 0, mxson[0] = INF; findRoot(1, 0); solve(root); printf("%d\n", ans); &#125; return 0;&#125; luogu3806 【模板】点分治1题意给定一棵有n个点的树，多次询问树上距离为k的点对是否存在。题解和上一题差不多，也是容斥，只不过我们把所有k的答案一次性求出来，每次询问O(1)回答。Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;map&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int INF = 1e9;const int N = 10005;int n, m, k[105], u, v, p;struct Edge&#123; int nxt, to, dis;&#125;edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to, int dis)&#123; edge[++edgeNum].nxt = head[from]; edge[edgeNum].to = to; edge[edgeNum].dis = dis; head[from] = edgeNum;&#125;int size[N], mxson[N], dis[N], root, sum;bool vis[N];map&lt;int, int&gt; cnt;void findRoot(int x, int f)&#123; size[x] = 1, mxson[x] = 0; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to] || edge[i].to == f) continue; findRoot(edge[i].to, x); size[x] += size[edge[i].to]; mxson[x] = max(mxson[x], size[edge[i].to]); &#125; mxson[x] = max(mxson[x], sum - size[x]); if(mxson[x] &lt; mxson[root]) root = x;&#125;void getDis(int x, int f, int d)&#123; dis[++dis[0]] = d; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(edge[i].to == f || vis[edge[i].to]) continue; getDis(edge[i].to, x, d + edge[i].dis); &#125;&#125;void cal(int x, int d, int fl)&#123; for(int i = 1; i &lt;= dis[0]; i++) dis[i] = 0; dis[0] = 0; getDis(x, 0, d); sort(dis+1, dis+dis[0]+1); for(int i = 1; i &lt;= dis[0]; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(dis[i] + dis[i] &gt; k[j]) continue; int l = lower_bound(dis+i, dis+dis[0]+1, k[j]-dis[i]) - dis; if(dis[l] + dis[i] != k[j]) continue; int r = upper_bound(dis+i, dis+dis[0]+1, k[j]-dis[i]) - dis; cnt[k[j]] += (r - l) * fl; &#125; &#125;&#125;void solve(int x)&#123; cal(x, 0, 1); vis[x] = 1; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to]) continue; cal(edge[i].to, edge[i].dis, -1); root = 0, sum = size[edge[i].to], mxson[0] = INF; findRoot(edge[i].to, 0); solve(root); &#125;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt; n; i++)&#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;p); addEdge(u, v, p); addEdge(v, u, p); &#125; for(int i = 1; i &lt;= m; i++) scanf("%d", &amp;k[i]); root = 0, sum = n, mxson[0] = INF; findRoot(1, 0); solve(root); for(int i = 1; i &lt;= m; i++) puts(cnt[k[i]] &gt; 0 ? "AYE" : "NAY"); return 0;&#125; [国家集训队] 聪聪可可题意求边权和是3的倍数的点对个数题解思路和上面两道题大同小异，而且更简单了：不用对dis排序，只需记录下距当前根dis为0,1,2的点的个数(cnt)，则答案就是$cnt[0] * cnt[0] + cnt[1] * cnt[2] * 2$当然这样做也要容斥Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 20005;const int INF = 1e9;int n, u, v, p;struct Edge&#123; int nxt, to, dis;&#125;edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to, int dis)&#123; edge[++edgeNum].nxt = head[from]; edge[edgeNum].to = to; edge[edgeNum].dis = dis; head[from] = edgeNum;&#125;int root, mxson[N], sum, size[N];bool vis[N];void findRoot(int x, int f)&#123; size[x] = 1, mxson[x] = 0; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to] || edge[i].to == f) continue; findRoot(edge[i].to, x); size[x] += size[edge[i].to]; mxson[x] = max(mxson[x], size[edge[i].to]); &#125; mxson[x] = max(mxson[x], sum - size[x]); if(mxson[x] &lt; mxson[root]) root = x;&#125;int cnt[3];void getDis(int x, int f, int d)&#123; cnt[d%3]++; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to] || edge[i].to == f) continue; getDis(edge[i].to, x, (d + edge[i].dis) % 3); &#125;&#125;int cal(int x, int d)&#123; cnt[0] = cnt[1] = cnt[2] = 0; getDis(x, 0, d); return cnt[0] * cnt[0] + cnt[1] * cnt[2] * 2;&#125;int ans;void solve(int x)&#123; ans += cal(x, 0); vis[x] = 1; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to]) continue; ans -= cal(edge[i].to, edge[i].dis % 3); root = 0, sum = size[edge[i].to], mxson[0] = INF; findRoot(edge[i].to, 0); solve(root); &#125;&#125;int gcd(int a, int b)&#123; return b == 0 ? a : gcd(b, a % b);&#125;int main()&#123; scanf("%d", &amp;n); for(int i = 1; i &lt; n; i++)&#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;p); addEdge(u, v, p % 3); addEdge(v, u, p % 3); &#125; root = 0, mxson[0] = INF, sum = n; findRoot(1, 0); solve(root); int g = gcd(ans, n*n); printf("%d/%d", ans / g, n * n / g); return 0;&#125; [IOI]Race题意给一棵树，每条边有权。求一条简单路径，权值和等于 K ，且边的数量最小。输出最小边数题解发现这道不能容斥…所以我们想办法通过子树信息直接计算经过分治点的路径的答案记$tmp[i]$为当前子树中，路径长为$i$的最小边数，于是对于当前根$x$，我们每次遍历它的子树，先用$tmp[]$和正在遍历的子树更新答案（代码中的 $updAns()$ 函数），再用正在遍历的这颗子树更新$tmp[]$（代码中的 $updTmp()$ 函数），这样就保证了不会把不合法的路径算进来Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int INF = 1e9;const int N = 200005;int n, k, u, v, p;struct Edge&#123; int nxt, to, dis;&#125;edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to, int dis)&#123; edge[++edgeNum].nxt = head[from]; edge[edgeNum].to = to; edge[edgeNum].dis = dis; head[from] = edgeNum;&#125;int root, mxson[N], size[N], sum;bool vis[N];void findRoot(int x, int f)&#123; size[x] = 1, mxson[x] = 0; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to] || edge[i].to == f) continue; findRoot(edge[i].to, x); size[x] += size[edge[i].to]; mxson[x] = max(mxson[x], size[edge[i].to]); &#125; mxson[x] = max(mxson[x], sum - size[x]); if(mxson[x] &lt; mxson[root]) root = x;&#125;int ans = INF, tmp[1000005];void updTmp(int x, int f, int dis, int d)&#123; if(dis &lt;= k) tmp[dis] = min(tmp[dis], d); for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to] || edge[i].to == f) continue; updTmp(edge[i].to, x, dis + edge[i].dis, d + 1); &#125;&#125;void updAns(int x, int f, int dis, int d)&#123; if(dis &lt;= k) ans = min(ans, d + tmp[k-dis]); for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to] || edge[i].to == f) continue; updAns(edge[i].to, x, dis + edge[i].dis, d + 1); &#125;&#125;void clearTmp(int x, int f, int dis)&#123; if(dis &lt;= k) tmp[dis] = INF; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to] || edge[i].to == f) continue; clearTmp(edge[i].to, x, dis + edge[i].dis); &#125;&#125;void solve(int x)&#123; vis[x] = 1, tmp[0] = 0; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to]) continue; updAns(edge[i].to, x, edge[i].dis, 1); updTmp(edge[i].to, x, edge[i].dis, 1); &#125; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to]) continue; clearTmp(edge[i].to, x, edge[i].dis); &#125; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to]) continue; root = 0, sum = size[edge[i].to]; findRoot(edge[i].to, 0); solve(root); &#125;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;k); for(int i = 1; i &lt; n; i++)&#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;p); addEdge(u+1, v+1, p); addEdge(v+1, u+1, p); &#125; for(int i = 0; i &lt;= k; i++) tmp[i] = INF; root = 0, mxson[0] = INF, sum = n; findRoot(1, 0); solve(root); if(ans == INF) puts("-1"); else printf("%d\n", ans); return 0;&#125; —— 完 ——]]></content>
      <categories>
        <category>图论</category>
        <category>树</category>
        <category>点分治</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2017 D1 T2]时间复杂度（栈，模拟）]]></title>
    <url>%2F2018%2F04%2F14%2FNOIP2017-D1-T2-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%88%E6%A0%88%EF%BC%8C%E6%A8%A1%E6%8B%9F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并 给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序， 于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。 A++语言的循环结构如下：123F i x y 循环体E 其中F i x y表示新建变量 $i$（变量 $i$ 不可与未被销毁的变量重名）并初始化为 $x$， 然后判断 $i$ 和 $y$ 的大小关系，若 $i$ 小于等于 $y$ 则进入循环，否则不进入。每次循环结束后 $i$ 都会被修改成 $i +1$，一旦 $i$ 大于 $y$ 终止循环。 $x$ 和 $y$ 可以是正整数（$x$ 和 $y$ 的大小关系不定）或变量 $n$。$n$ 是一个表示数据规模的变量，在时间复杂度计算中需保留该变量而不能将其视为常数，该数远大于 100。 “E”表示循环体结束。循环体结束时，这个循环体新建的变量也被销毁。 注：本题中为了书写方便，在描述复杂度时，使用大写英文字母“O”表示通常意义下“Θ”的概念。 输入输入文件第一行一个正整数 $t$，表示有 $t$（$t \le 10$）个程序需要计算时间复杂度。 每个程序我们只需抽取其中 F i x y和E即可计算时间复杂度。注意：循环结构允许嵌套。 接下来每个程序的第一行包含一个正整数 $L$ 和一个字符串，$L$ 代表程序行数，字符串表示这个程序的复杂度，O(1)表示常数复杂度，O(n^w)表示复杂度为$n^w$，其中w是一个小于100的正整数（输入中不包含引号），输入保证复杂度只有O(1)和O(n^w) 两种类型。 接下来 $L$ 行代表程序中循环结构中的F i x y或者 E。 程序行若以F开头，表示进入一个循环，之后有空格分离的三个字符（串）i x y， 其中 $i$ 是一个小写字母（保证不为$n$），表示新建的变量名，$x$ 和 $y$ 可能是正整数或 $n$ ，已知若为正整数则一定小于 100。 程序行若以E开头，则表示循环体结束。 输出输出文件共 $t$ 行，对应输入的 $t$ 个程序，每行输出”Yes”或”No”或者”ERR”（输出中不包含引号），若程序实际复杂度与输入给出的复杂度一致则输出”Yes”，不一致则输出”No”，若程序有语法错误（其中语法错误只有: ① F 和 E 不匹配 ②新建的变量与已经存在但未被销毁的变量重复两种情况），则输出”ERR” 。 注意：即使在程序不会执行的循环体中出现了语法错误也会编译错误，要输出 ERR。 样例输入1234567891011121314151617181920212223242526272829303132333482 O(1)F i 1 1E2 O(n^1)F x 1 nE1 O(1)F x 1 n4 O(n^2)F x 5 nF y 10 nEE4 O(n^2)F x 9 nEF y 2 nE4 O(n^1)F x 9 nF y n 4EE4 O(1)F y n 4F x 9 nEE4 O(n^2)F x 1 nF x 1 10EE 样例输出12345678YesYesERRYesNoYesYesERR 输入输出样例解释第一个程序 $i$ 从 1 到 1 是常数复杂度。第二个程序 $x$ 从 1 到 $n$ 是 $n$ 的一次方的复杂度。第三个程序有一个 F 开启循环却没有 E 结束，语法错误。第四个程序二重循环，$n$ 的平方的复杂度。第五个程序两个一重循环，$n$ 的一次方的复杂度。第六个程序第一重循环正常，但第二重循环开始即终止（因为$n$远大于100，100大于4）。第七个程序第一重循环无法进入，故为常数复杂度。第八个程序第二重循环中的变量 $x$ 与第一重循环中的变量重复，出现语法错误②，输出 ERR。 数据规模与约定对于 30%的数据：不存在语法错误，数据保证小明给出的每个程序的前 $L/2$ 行一定为以 F 开头的语句，第 $L/2+1$ 行至第 $L$ 行一定为以 $E$ 开头的语句，$L \le 10$，若 $x$、$y$ 均 为整数，$x$ 一定小于 $y$，且只有 $y$ 有可能为 $n$。对于 50%的数据：不存在语法错误，$L \le 100$，且若 $x$、$y$ 均为整数，$x$ 一定小于 $y$， 且只有 $y$ 有可能为 $n$。对于 70%的数据：不存在语法错误，$L \le 100$。对于 100%的数据：$L \le 100$。 解题思路由于循环必须要让F与E配对，联想到括号匹配问题，所以用栈来模拟。为了方便计算，我在栈里维护了三个值，分别表示当前循环所用变量名、程序执行到当前循环时的复杂度、当前循环是否处于被跳过的循环之中（即程序不会执行到）。在压栈时维护一下这三个值就好了，最后的复杂度即为最大的可被执行到的复杂度。最后，注意一下关于字符串的读入处理就好了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int T, L, kind, w;//kind == 1:O(1); kind == 2: O(n^w)int top, ans;char com[100], opt[100];bool used[1000], err;struct Node&#123; char ch; int c;//执行至此的时间复杂度 bool dir;//是否处于直接跳过的循环中 &#125;sta[1000];void solve()&#123; scanf("%d ", &amp;L); cin.getline(com, 99); if(com[2] == '1') kind = 1; else&#123; int now = 4; while(com[now] &gt;= '0' &amp;&amp; com[now] &lt;= '9')&#123; w = w * 10 + com[now] - '0'; now++; &#125; kind = 2; &#125; for(int i = 1; i &lt;= L; i++)&#123; cin.getline(opt, 99); if(err) continue; if(opt[0] == 'F')&#123; if(used[opt[2]])&#123; err = 1; continue; &#125; used[opt[2]] = 1; int now = 4, l = 0, r = 0, pre = 0, nxt = 0; while((opt[now] &gt;= '0' &amp;&amp; opt[now] &lt;= '9') || opt[now] == 'n')&#123; if(opt[now] == 'n') pre = 1; else l = l * 10 + opt[now] - '0'; now++; &#125; now++; while((opt[now] &gt;= '0' &amp;&amp; opt[now] &lt;= '9') || (opt[now] == 'n'))&#123; if(opt[now] == 'n') nxt = 1; else r = r * 10 + opt[now] - '0'; now++; &#125; if(pre == 1 &amp;&amp; nxt == 1)&#123; sta[top+1] = (Node)&#123;opt[2], sta[top].c, sta[top].dir&#125;; top++; if(sta[top].dir == 0) ans = max(ans, sta[top].c); &#125; else if(pre == 1 &amp;&amp; nxt == 0)&#123; sta[top+1] = (Node)&#123;opt[2], sta[top].c, 1&#125;; top++; &#125; else if(pre == 0 &amp;&amp; nxt == 1)&#123; sta[top+1] = (Node)&#123;opt[2], sta[top].c + 1, sta[top].dir&#125;; top++; if(sta[top].dir == 0) ans = max(ans, sta[top].c); &#125; else if(pre == 0 &amp;&amp; nxt == 0)&#123; if(l &lt;= r)&#123; sta[top+1] = (Node)&#123;opt[2], sta[top].c, sta[top].dir&#125;; top++; if(sta[top].dir == 0) ans = max(ans, sta[top].c); &#125; else&#123; sta[top+1] = (Node)&#123;opt[2], sta[top].c, 1&#125;; top++; &#125; &#125; &#125; else if(opt[0] == 'E')&#123; if(top == 0) err = 1; else&#123; used[sta[top].ch] = 0; top--; &#125; &#125; &#125; if(top) err = 1; if(err)&#123; puts("ERR"); return; &#125; if(kind == 1 &amp;&amp; ans == 0)&#123; puts("Yes"); return; &#125; if(kind == 2 &amp;&amp; w == ans)&#123; puts("Yes"); return; &#125; puts("No"); return;&#125;void init()&#123; memset(sta, 0, sizeof sta); top = 0; memset(com, 0, sizeof com); memset(opt, 0, sizeof opt); memset(used, 0, sizeof used); err = 0; ans = 0; kind = w = 0;&#125;int main()&#123; scanf("%d", &amp;T); while(T--)&#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>模拟</category>
        <category>数据结构</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2017 D1 T1]小凯的疑惑（数论）]]></title>
    <url>%2F2018%2F04%2F14%2FNOIP2017-D1-T1-%E5%B0%8F%E5%87%AF%E7%9A%84%E7%96%91%E6%83%91%EF%BC%88%E6%95%B0%E8%AE%BA%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述小凯手中有两种面值的金币，两种面值均为正整数且彼此互素。每种金币小凯都有 无数个。在不找零的情况下，仅凭这两种金币，有些物品他是无法准确支付的。现在小凯想知道在无法准确支付的物品中，最贵的价值是多少金币？注意：输入数据保证存在小凯无法准确支付的商品。 输入输入数据仅一行，包含两个正整数 $a$ 和 $ b $，它们之间用一个空格隔开，表示小凯手 中金币的面值。 输出输出文件仅一行，一个正整数 $ N $，表示不找零的情况下，小凯用手中的金币不能准确支付的最贵的物品的价值。 样例输入13 7 样例输出111 样例说明小凯手中有面值为3和7的金币无数个，在不找零的前提下无法准确支付价值为1、 2、4、5、8、11 的物品，其中最贵的物品价值为 11，比 11 贵的物品都能买到，比如：$ 12 = 3 \times 4 + 7 \times 0 $$ 13 = 3 \times 2 + 7 \times 1 $$ 14 = 3 \times 0 + 7 \times 2 $$ 15 = 3 \times 5 + 7 \times 0 $ 数据范围与约定对于 30%的数据： $ 1 \le a,b \le 50 $。对于 60%的数据： $ 1 \le a,b \le 10^4 $。对于 100%的数据：$ 1 \le a,b \le 10^9 $。 解题思路因为$ (a,b) = 1 $，所以$ {a, 2a, 3a, …, (b-1)a} $为模$ b $的完全剩余系。设$ T $是一个$ a, b $无法表示的数且$ T \equiv ka(mod \ b) $，$ (1 \le k \le b-1) $.若$ T \ge ka $，则$ T $一定可以表示为$ ka+nb $，$ (n \ge 0) $，所以$ T &lt; ka $，则此时$ T $最大为$ ka-b $.显然，当$ k $最大时$ T $最大，所以$ T = (b-1)a-b = ab - a - b $. Code123456789#include&lt;cstdio&gt;using namespace std;typedef long long LL;LL a, b;int main()&#123; scanf("%lld%lld", &amp;a, &amp;b); printf("%lld", a * b - a - b); return 0;&#125;]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello, world!]]></title>
    <url>%2F2018%2F04%2F07%2FHello-world-0%2F</url>
    <content type="text"><![CDATA[搞了一个下午+一个晚上，终于把hexo+github博客搭建起来了……（尚待后续优化） 这个博客用于几个板块：OI/ACM 学习笔记（主要），学习总结，随笔，其他 12break?continue!]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
