<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如梦，初醒]]></title>
    <url>%2F2018%2F11%2F09%2F%E5%A6%82%E6%A2%A6%EF%BC%8C%E5%88%9D%E9%86%92%2F</url>
    <content type="text"><![CDATA[终于，结束了。仿佛一夜长梦初醒，不舍，却也无可奈何。 曾经的踌躇满志，曾经的意气风发，随着 NOIP2018 终声的响起，终是和那些失败的苦涩一同被封存在了那一段回不去的年华。向来缘浅，奈何情深…… （一）青涩的邂逅2016年，8月，成都七中夏令营。我知道，这里是梦开始的地方。但我没想过，这里也是梦结束的地方。还记得当时盯着竞赛志愿表，犹豫着、彳亍着——到底选择那一科竞赛呢？数学，初中早就领教过厉害了；物理，不曾深入了解过；化学生物信息，还没有听说过呢！也不知道纠结了多久，我终于选择了信息学竞赛。至今，我还一直庆幸于命运让我与 OI 邂逅。是的，我一直相信这是命运的安排，如果不是那一刹那的抉择，我现在也就不会在电脑上敲下这段文字。 仅仅3个月后，我迎来了第一次 NOIP。去电子科大的路上，我一路默念的，仅仅是最基础的 dfs，但这已经是我当时所学过的最“高深”的算法了。初来乍到，进校门后确是绕了不少弯路，最后沿着一条一路栽着银杏的大道走向考场——银杏叶撒了一地，给道路铺上了一条金黄的毯子，脚踩在银杏叶上发出沙沙的响声，甚是惬意。T1 是一道简单的模拟，是我当时唯一会做的题（虽然代码仍然有一个 BUG），剩下的时间就去研究 T2 了。说是“研究”，是因为我连什么是树都不知道。我认认真真地敲完“研究成果”后，反复检查各种文件名，然后耐心地等待考试结束。第二天也大抵如此。于是我的第一次 NOIP 在懵懵懂懂中落下了帷幕。最后查分，165，省二，确实意外。毕竟刚学2个月，本也不抱奢望，省二无疑给予了我鼓舞与信心。可求知从无坦途，事实证明，OI 这条路还很漫长而艰辛。 （二）路漫漫随后一年里，陆陆续续地学了不少算法，刷了不少题，考了不少试。渐渐地，我发现 OI 与其他竞赛相比，有着独一无二的特点——一个错误的程序说不准也可以 AC，一个正确的代码搞不好会被卡掉；一些奇技淫巧可以增加不少分，一个点打成了逗号可以让你调试几个小时…… OI 的趣味性大抵如此。有时，看着满页绿色的 AC 和红色的 WA，夹杂着 TLE 与 RE，不禁感慨于调试的艰难或是 1A 的喜悦——这是每一个 OIer 必经的道路，也是每一个 OIer 热爱 OI 的原因。 转眼又是一年 NOIP，我以为我已经准备好了，可当我看到 Day1T1 时我才意识到，这一年我还不够努力。大概是没有 D1T1 失分的心理准备，最终满盘皆输。我自然沮丧了好一阵子——难道一年的努力就此陨灭，一年的付出只能换来两手空空？周围的人，考得好的如 zsy，继续深造去了；其他人，要么带着遗憾，要么带着满足，陆续结束了竞赛生涯。只有我久久盯着屏幕上冰冷的分数，试图拨开迷雾，找到未来的方向。我失落，我愤懑，我有所不甘。我不愿放弃，我决定继续走下去。有趣的是，NOIP 的失利似乎给了我十足的动力，考后的几个月我学到的，比考前冲刺还多。也许我想弥补曾经懒惰的代价，好歹算是一个慰藉。我也知道，高三就不能进入省队了，一等奖似乎也争取不到理想高校的自主招生资格。可不知为何，我不愿就此离开。 （三）梦醒时分两年OI，未曾有什么成就。可为什么总是放不下这份执念？大概 OI 已然成为了一种情怀。那是看见命令行闪烁出 $Hello World$ 时的新奇，是接触到一个新的算法时的喜悦，是调试了一个下午终于 AC 的释然，是自己想出正解时的自豪。那也是对爆零的恐惧，是对满屏 WA 与 RE 的无奈，是 rating 单调下降时的急切，是发挥失常时的忧伤。总之，我对 OI 投入了太多感情，丝丝情愫，岂是一朝一夕可以忘却？ 但是这一天终究是来了。NOIP2018，注定是我的终点站。第一天，天气仍是微冷，我第三次踏进了熟悉的校门。湖中央的喷泉却没有工作，银杏的金黄似乎也有些黯淡。科技楼门口仍然是扎堆的学生，只不过又多了些新的面孔，少了些旧的面孔。我站在一旁静静地看着他们——他们是否知道，自己将是未来 NOI 的金牌，又或者将在今天失意而告别 OI？我感觉我与考场紧张的气氛格格不入——我并非为功名而来，自不必为成功与否而焦虑。我只不过想对去年的失利有一个交代，顺便了却一桩心愿。考试过程从略吧，毕竟学习重心早就在文化课上了，大概尽力把能得的分拿了，没有什么遗憾。第二天，初冬的天竟然有些回暖，虽然还是一层薄云笼罩着早晨的天空，却依稀可见云层后迫不及待想要倾泻而下的阳光。我告诉我自己，今天将是我与 OI 最后的交集，可当我坐在考场上的时候，我竟没有丝毫离别的伤感。最后五分钟，仍然像往常那样仔细检查了文件名，然后静静地等待这一切的结束。结果已经不在重要了，我已到达了终点，尽管这个句号不是多么的圆满，但也不留遗憾。 （wait to be continued…)]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[luogu P1266]速度限制（二维spfa）]]></title>
    <url>%2F2018%2F09%2F24%2Fluogu-P1266-%E9%80%9F%E5%BA%A6%E9%99%90%E5%88%B6%EF%BC%88%E4%BA%8C%E7%BB%B4spfa%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述在这个繁忙的社会中，我们往往不再去选择最短的道路，而是选择最快的路线。开车时每条道路的限速成为最关键的问题。不幸的是，有一些限速的标志丢失了，因此你无法得知应该开多快。一种可以辩解的解决方案是，按照原来的速度行驶。你的任务是计算两地间的最快路线。 你将获得一份现代化城市的道路交通信息。为了使问题简化，地图只包括路口和道路。每条道路是有向的，只连接了两条道路，并且最多只有一块限速标志，位于路的起点。两地A和B，最多只有一条道路从A连接到B。你可以假设加速能够在瞬间完成并且不会有交通堵塞等情况影响你。当然，你的车速不能超过当前的速度限制。 输入第一行是3个整数N，M和D(2&lt;＝N&lt;=150)，表示道路的数目，用0..N-1标记。M是道路的总数，D表示你的目的地。 接下来的M行，每行描述一条道路，每行有4个整数A(0≤A&lt;N)，B(0≤B&lt;N)，V(0≤V≤500)and L(1≤L≤500)，这条路是从A到B的，速度限制是V，长度为L。如果V是0，表示这条路的限速未知。 如果V不为0，则经过该路的时间T=L/V。否则T=L/Vold，Vold是你到达该路口前的速度。开始时你位于0点，并且速度为70。 输出输出文件仅一行整数，表示从0到D经过的城市。 输出的顺序必须按照你经过这些城市的顺序，以0开始，以D结束。仅有一条最快路线。 输入样例123456789101112131415166 15 10 1 25 680 2 30 500 5 0 1011 2 70 771 3 35 422 0 0 222 1 40 862 3 0 232 4 45 403 1 64 143 5 0 234 1 95 85 1 0 845 2 90 645 3 36 40 输出样例10 5 2 3 1 解题思路设 $tim[i][j]$ 表示到达 $i$ 点时速度为 $j$ 的最短时间，以之代替 $dis[i]$ 跑 spfa 即可。 （ps:用了 map 和 pair 果真有点慢…） Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned int UI;typedef long long LL;typedef unsigned long long ULL;typedef pair&lt;int,int&gt; pii;typedef pair&lt;LL, LL&gt; pll;#define mp make_pair#define pb push_back#define lb lower_bound#define ub upper_bound#define fir first#define sec second#define fo0(i,a,b) for(int i=(a);i&lt;(b);i++)#define fo1(i,a,b) for(int i=(a);i&lt;=(b);i++)#define fd0(i,a,b) for(int i=(a)-1;i&gt;=(b);i--)#define fd1(i,a,b) for(int i=(a);i&gt;=(b);i--)#define mset(a,b) memset(a,(b),sizeof(a))#define mcpy(a,b) memcpy(a,b,sizeof(a))template&lt;typename T&gt; inline void in(T &amp;x)&#123;x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')fl=-1;ch=getchar();&#125;while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();&#125;x*=fl;&#125;template&lt;typename T&gt; void out(T x)&#123;if(x&lt;0)&#123;putchar('-');x=-x;&#125;if(x/10)out(x/10);putchar(x%10+'0');&#125;template&lt;typename T&gt; inline void outln(T x)&#123;out(x);putchar(10);&#125;template&lt;typename T&gt; inline void outsp(T x)&#123;out(x);putchar(' ');&#125;template&lt;typename T&gt; inline T gcd(T a, T b)&#123;T t;if(a&gt;b)&#123;while(b)&#123;t=b;b=a%b;a=t;&#125;return a;&#125;else&#123;while(a)&#123;t=a;a=b%a;b=t;&#125;return b;&#125;&#125;template&lt;typename T&gt; inline T lcm(T a, T b)&#123;return a/gcd(a,b)*b;&#125;const int N = 155;int n, m, d, u, v, w, p;struct Edge&#123; int nxt, from, to, v, len;&#125;edge[N*N];int head[N], edgeNum;void addEdge(int from, int to, int v, int len)&#123; edge[++edgeNum] = (Edge)&#123;head[from], from, to, v, len&#125;; head[from] = edgeNum;&#125;double tim[N][505];bool inq[N][505];map&lt;pii, pii&gt; pre;void spfa()&#123; queue&lt;pii&gt; q; q.push(&#123;1, 70&#125;); inq[1][70] = 1; tim[1][70] = 0; pre[&#123;1, 70&#125;] = &#123;0, 0&#125;; while(!q.empty())&#123; pii cur = q.front(); q.pop(); inq[cur.fir][cur.sec] = 0; int x = cur.fir, sp = cur.sec; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(edge[i].v == 0)&#123; if(tim[edge[i].to][sp] &gt; tim[x][sp] + (double)edge[i].len / sp)&#123; tim[edge[i].to][sp] = tim[x][sp] + (double)edge[i].len / sp; pre[&#123;edge[i].to, sp&#125;] = &#123;x, sp&#125;; if(!inq[edge[i].to][sp])&#123; q.push(&#123;edge[i].to, sp&#125;); inq[edge[i].to][sp] = 1; &#125; &#125; &#125; else&#123; if(tim[edge[i].to][edge[i].v] &gt; tim[x][sp] + (double)edge[i].len / edge[i].v)&#123; tim[edge[i].to][edge[i].v] = tim[x][sp] + (double)edge[i].len / edge[i].v; pre[&#123;edge[i].to, edge[i].v&#125;] = &#123;x, sp&#125;; if(!inq[edge[i].to][edge[i].v])&#123; q.push(&#123;edge[i].to, edge[i].v&#125;); inq[edge[i].to][edge[i].v] = 1; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; in(n); in(m); in(d); d++; fo1(i, 1, m)&#123; in(u); in(v); in(w); in(p); addEdge(u+1, v+1, w, p); &#125; fo1(i, 1, n) fo1(j, 1, 500) tim[i][j] = 1e9; spfa(); double ans = 1e9; pii mark; fo1(i, 1, 500)&#123; if(ans &gt; tim[d][i])&#123; ans = tim[d][i]; mark = &#123;d, i&#125;; &#125; &#125; stack&lt;int&gt; sta; while(mark.fir)&#123; sta.push(mark.fir); mark = pre[mark]; &#125; while(!sta.empty())&#123; outsp(sta.top()-1); sta.pop(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>luogu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces 867.E] Buy Low Sell High（堆）]]></title>
    <url>%2F2018%2F08%2F26%2FCodeforces-867-E-Buy-Low-Sell-High%EF%BC%88%E5%A0%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[E. Buy Low Sell Hightime limit per test:2 secondsmemory limit per test:256 megabytesinput:standard inputoutput:standard outputYou can perfectly predict the price of a certain stock for the next $N$ days. You would like to profit on this knowledge, but only want to transact one share of stock per day. That is, each day you will either buy one share, sell one share, or do nothing. Initially you own zero shares, and you cannot sell shares when you don’t own any. At the end of the $N$ days you would like to again own zero shares, but want to have as much money as possible. InputInput begins with an integer $N$ $(2≤N≤3·10^5)$, the number of days. Following this is a line with exactly $N$ integers $p_1,p_2,…,p_N$ $(1≤p_i≤10^6)$. The price of one share of stock on the $i$-th day is given by $p_i$. OutputPrint the maximum amount of money you can end up with at the end of $N$ days. Examples input output 910 5 4 7 9 12 6 2 10 20 203 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 2 3 8 4 41 NoteIn the first example, buy a share at $5$, buy another at $4$, sell one at $9$ and another at $12$. Then buy at $2$ and sell at $10$. The total profit is $-5-4+9+12-2+10=20$. 解题思路挺经典的一道题。在 $a$ 处买入并在 $b$ 处卖出等效于在 $a$ 处买入、在 $c$ 处卖出并在 $c$ 处买入、再在 $b$ 处卖出。看起来很傻但是把题变简单了：只要能赚钱就卖，如果以后发现更好的差价就反悔，回到之前卖掉的地方买回来再卖出去。程序实现很巧妙，维护一个小根堆，如果当前元素小于堆顶就插进堆中；否则，弹出堆顶元素，答案加上差价，并将当前元素入堆两次。这样，当它第一次被弹出时相当于反悔了一次，第二次被弹出就表示真的把它卖了出去。 时间复杂度：$O(n\log n)$ Code1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;//此处省略 define 的一些东西和读入输出优化const int N = 300005;int n, p;LL ans;priority_queue&lt; int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;int main()&#123; in(n); fo1(i, 1, n)&#123; in(p); if(q.empty() || p &lt;= q.top()) q.push(p); else&#123; ans += 1ll * p - q.top(); q.pop(); q.push(p); q.push(p); &#125; &#125; outln(ans); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>堆/优先队列</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 CCPC 网络选拔赛（部分题解）]]></title>
    <url>%2F2018%2F08%2F26%2F2018-CCPC-%E7%BD%91%E7%BB%9C%E9%80%89%E6%8B%94%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[Buy and Resell解题思路这道题和 Codeforces 867E基本相同：Codeforces867E题解但是这道题要求输出最少买卖操作数，其实就是让我们尽可能地多反悔，由分析，第一次弹出是反悔，第二次弹出是真的买卖，于是优先队列里加一个元素个数的信息，把元素个数大的放在前面（这样下一次弹出时就是反悔操作了）。 Code展开代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned int UI;typedef long long LL;typedef unsigned long long ULL;typedef pair&lt;int,int&gt; pii;typedef pair&lt;LL, LL&gt; pll;#define mp make_pair#define pb push_back#define fir first#define sec second#define fo0(i,a,b) for(int i=(a);i&lt;(b);i++)#define fo1(i,a,b) for(int i=(a);i&lt;=(b);i++)#define fd0(i,a,b) for(int i=(a);i&gt;(b);i--)#define fd1(i,a,b) for(int i=(a);i&gt;=(b);i--)#define mset(a,b) memset(a,(b),sizeof(a))#define max(a,b) (a &gt; b ? a : b)#define min(a,b) (a &lt; b ? a : b)#define abs(a) (a &lt; 0 ? -a : a)#define fabs(a) (a &lt; 0 ? -a : 0)template&lt;typename T&gt; inline void in(T &amp;x)&#123; x = 0; int fl = 1; char ch = getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')fl=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();&#125; x*=fl;&#125;template&lt;typename T&gt; void out(T x)&#123;if(x&lt;0)&#123;putchar('-');x=-x;&#125;if(x/10)out(x/10);putchar(x%10+'0');&#125;template&lt;typename T&gt; inline void outln(T x)&#123;out(x);putchar(10);&#125;template&lt;typename T&gt; inline void outsp(T x)&#123;out(x);putchar(' ');&#125;template&lt;typename T&gt; inline T gcd(T a, T b)&#123;T t;if(a&gt;b)&#123;while(b)&#123;t=b;b=a%b;a=t;&#125;return a;&#125;else&#123;while(a)&#123;t=a;a=b%a;b=t;&#125;return b;&#125;&#125;template&lt;typename T&gt; inline T lcm(T a, T b)&#123;return a/gcd(a,b)*b;&#125;const int N = 100005;int CASES, n, p;LL ans, tim;struct Node&#123; int p, num; bool operator &lt; (const Node &amp;a) const&#123; if(p == a.p) return num &gt; a.num; return p &lt; a.p; &#125;&#125;;multiset&lt;Node&gt; s;inline void init()&#123; ans = tim = 0; s.clear();&#125;int main()&#123; in(CASES); while(CASES--)&#123; init(); in(n); fo1(i, 1, n)&#123; in(p); Node cur = *s.begin(); if(s.empty() || p &lt;= cur.p) s.insert((Node)&#123;p, 1&#125;); else&#123; ans += 1ll * p - cur.p; if(cur.num == 1)&#123; tim++; s.erase(s.begin()); &#125; else&#123; s.erase(s.begin()); cur.num--; s.insert(cur); &#125; s.insert((Node)&#123;p, 2&#125;); &#125; &#125; outsp(ans); outln(tim*2); &#125; return 0;&#125; Dream ( hdu6440 )解题思路定义 $a+b$ 为 $(a+b) \mod p$定义 $a\cdot b$ 为 $a\cdot b \mod p$ Code展开代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned int UI;typedef long long LL;typedef unsigned long long ULL;typedef pair&lt;int,int&gt; pii;typedef pair&lt;LL, LL&gt; pll;#define mp make_pair#define pb push_back#define fir first#define sec second#define fo0(i,a,b) for(int i=(a);i&lt;(b);i++)#define fo1(i,a,b) for(int i=(a);i&lt;=(b);i++)#define fd0(i,a,b) for(int i=(a);i&gt;(b);i--)#define fd1(i,a,b) for(int i=(a);i&gt;=(b);i--)#define mset(a,b) memset(a,(b),sizeof(a))#define max(a,b) (a &gt; b ? a : b)#define min(a,b) (a &lt; b ? a : b)#define abs(a) (a &lt; 0 ? -a : a)#define fabs(a) (a &lt; 0 ? -a : 0)template&lt;typename T&gt; inline void in(T &amp;x)&#123; x = 0; int fl = 1; char ch = getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')fl=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();&#125; x*=fl;&#125;template&lt;typename T&gt; void out(T x)&#123;if(x&lt;0)&#123;putchar('-');x=-x;&#125;if(x/10)out(x/10);putchar(x%10+'0');&#125;template&lt;typename T&gt; inline void outln(T x)&#123;out(x);putchar(10);&#125;template&lt;typename T&gt; inline void outsp(T x)&#123;out(x);putchar(' ');&#125;template&lt;typename T&gt; inline T gcd(T a, T b)&#123;T t;if(a&gt;b)&#123;while(b)&#123;t=b;b=a%b;a=t;&#125;return a;&#125;else&#123;while(a)&#123;t=a;a=b%a;b=t;&#125;return b;&#125;&#125;template&lt;typename T&gt; inline T lcm(T a, T b)&#123;return a/gcd(a,b)*b;&#125;int T, p;int main()&#123; in(T); while(T--)&#123; in(p); fo0(i, 0, p)&#123; fo0(j, 0, p) outsp((i + j) % p); putchar(10); &#125; fo0(i, 0, p)&#123; fo0(j, 0, p) outsp((i * j) % p); putchar(10); &#125; &#125; return 0;&#125; Find Integer ( hdu6441 )解题思路 $n&gt;2$：由费马大定理，$n&gt;2$ 时方程无整数解。 $n=0$：$1+1=1$，不可能 $n=1$：略 $n=2$：$a^2=c^2-b^2=(c-b)(c+b)$当 $a$ 为奇数时，令 $c-b=1,c+b=a^2$；当 $a$ 为偶数时，令 $c-b=2,c+b=a^2/2$ Code展开代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned int UI;typedef long long LL;typedef unsigned long long ULL;typedef pair&lt;int,int&gt; pii;typedef pair&lt;LL, LL&gt; pll;#define mp make_pair#define pb push_back#define fir first#define sec second#define fo0(i,a,b) for(int i=(a);i&lt;(b);i++)#define fo1(i,a,b) for(int i=(a);i&lt;=(b);i++)#define fd0(i,a,b) for(int i=(a);i&gt;(b);i--)#define fd1(i,a,b) for(int i=(a);i&gt;=(b);i--)#define mset(a,b) memset(a,(b),sizeof(a))#define max(a,b) (a &gt; b ? a : b)#define min(a,b) (a &lt; b ? a : b)#define abs(a) (a &lt; 0 ? -a : a)#define fabs(a) (a &lt; 0 ? -a : 0)template&lt;typename T&gt; inline void in(T &amp;x)&#123; x = 0; int fl = 1; char ch = getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')fl=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();&#125; x*=fl;&#125;template&lt;typename T&gt; void out(T x)&#123;if(x&lt;0)&#123;putchar('-');x=-x;&#125;if(x/10)out(x/10);putchar(x%10+'0');&#125;template&lt;typename T&gt; inline void outln(T x)&#123;out(x);putchar(10);&#125;template&lt;typename T&gt; inline void outsp(T x)&#123;out(x);putchar(' ');&#125;template&lt;typename T&gt; inline T gcd(T a, T b)&#123;T t;if(a&gt;b)&#123;while(b)&#123;t=b;b=a%b;a=t;&#125;return a;&#125;else&#123;while(a)&#123;t=a;a=b%a;b=t;&#125;return b;&#125;&#125;template&lt;typename T&gt; inline T lcm(T a, T b)&#123;return a/gcd(a,b)*b;&#125;int CASES;LL n, a;int main()&#123; in(CASES); while(CASES--)&#123; in(n); in(a); if(n &gt; 2 || n == 0) puts("-1 -1"); else if(n == 1)&#123; outsp(1); outln(a+1); continue; &#125; else if(n == 2)&#123; if(a % 2)&#123; outsp((a*a-1)/2); outln((a*a+1)/2); &#125; else&#123; outsp(a*a/4-1); outln(a*a/4+1); &#125; &#125; &#125; return 0;&#125; Tree and Permutation ( hdu6446 )解题思路单独计算每一条边的贡献： 设这条边一侧有 $a$ 个节点，另一侧有 $b$ 个节点，那么从两侧各选出一个节点连起来时就会经过该边一次，共有 $C_a^1\times C_b^1\times A_2^2 = 2\cdot a\cdot b$ 种选法。（注意顺序不同也要算进去） 将选出来的两个点绑在一起与其他所有点做全排列求得这两个点一起出现的次数，共 $A_{n-1}^{n-1} = (n-1)!$ 次。 故该条边对答案的贡献为 $len\cdot 2\cdot a\cdot b\cdot (n-1)!$最后把所有边的贡献加起来即可。 Code展开代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned int UI;typedef long long LL;typedef unsigned long long ULL;typedef pair&lt;int,int&gt; pii;typedef pair&lt;LL, LL&gt; pll;#define mp make_pair#define pb push_back#define fir first#define sec second#define fo0(i,a,b) for(int i=(a);i&lt;(b);i++)#define fo1(i,a,b) for(int i=(a);i&lt;=(b);i++)#define fd0(i,a,b) for(int i=(a);i&gt;(b);i--)#define fd1(i,a,b) for(int i=(a);i&gt;=(b);i--)#define mset(a,b) memset(a,(b),sizeof(a))#define max(a,b) (a &gt; b ? a : b)#define min(a,b) (a &lt; b ? a : b)#define abs(a) (a &lt; 0 ? -a : a)#define fabs(a) (a &lt; 0 ? -a : 0)template&lt;typename T&gt; inline void in(T &amp;x)&#123; x = 0; int fl = 1; char ch = getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')fl=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();&#125; x*=fl;&#125;template&lt;typename T&gt; void out(T x)&#123;if(x&lt;0)&#123;putchar('-');x=-x;&#125;if(x/10)out(x/10);putchar(x%10+'0');&#125;template&lt;typename T&gt; inline void outln(T x)&#123;out(x);putchar(10);&#125;template&lt;typename T&gt; inline void outsp(T x)&#123;out(x);putchar(' ');&#125;template&lt;typename T&gt; inline T gcd(T a, T b)&#123;T t;if(a&gt;b)&#123;while(b)&#123;t=b;b=a%b;a=t;&#125;return a;&#125;else&#123;while(a)&#123;t=a;a=b%a;b=t;&#125;return b;&#125;&#125;template&lt;typename T&gt; inline T lcm(T a, T b)&#123;return a/gcd(a,b)*b;&#125;const int N = 100005;const LL MOD = 1e9+7;int n, u, v, p;LL ans, fac[N];struct Edge&#123; int nxt, to, len;&#125;edge[N&lt;&lt;1];int head[N], edgeNum = 0;inline void addEdge(int from, int to, int len)&#123; edge[++edgeNum] = (Edge)&#123;head[from], to, len&#125;; head[from] = edgeNum;&#125;int size[N], a[N&lt;&lt;1], b[N&lt;&lt;1];void dfs(int x, int f)&#123; size[x] = 1; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(edge[i].to == f) continue; dfs(edge[i].to, x); size[x] += (a[i] = size[edge[i].to]); b[i] = n - size[edge[i].to]; &#125;&#125;void init()&#123; edgeNum = 0; mset(head, 0); mset(edge, 0); mset(size, 0); mset(a, 0); mset(b, 0); ans = 0;&#125;int main()&#123; fac[0] = 1; fo1(i, 1, 100000) fac[i] = fac[i-1] * i % MOD; while(scanf("%d", &amp;n) != EOF)&#123; init(); fo0(i, 1, n)&#123; in(u); in(v); in(p); addEdge(u, v, p); addEdge(v, u, p); &#125; dfs(1, 0); for(int i = 1; i &lt;= edgeNum; i += 2) (ans += 1ll * edge[i].len * a[i] % MOD * b[i] * 2 % MOD) %= MOD; ans = (ans * fac[n-1]) % MOD; outln(ans); &#125; return 0;&#125; YJJ’s Salesman ( hdu6447 )解题思路对于两个点 $A$ 和 $B$，只要 $B$ 在 $A$ 的严格右上方，那么从 $A$ 走到 $B$ 就可以得到 $v_B$ 的收益。所以先以 $x$ 为第一关键字从小到大、$y$ 为第二关键字从大到小排序（这样可以保证dp时转移合法），然后可以dp。设 $dp[i]$ 表示到走到第 $i$ 个点的最大收益，那么转移方程为： dp[i] = \max\limits_{j]]></content>
      <tags>
        <tag>CCPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces 1017.D] The Wu（位运算，meet in the middle）]]></title>
    <url>%2F2018%2F08%2F24%2FCodeforces-1017-D-The-Wu%EF%BC%88%E4%BD%8D%E8%BF%90%E7%AE%97%EF%BC%8Cmeet-in-the-middle%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接 解题思路观察数据范围，发现 $n\leqslant 12$，即最多有 $2^{12}=4096$ 种字符串，所以输入的 $s$ 和 $t$ 肯定有很多重复的。那么可以先预处理出 $4096\times 4096$ 的所有情况的”Wu value”，又由于 $k \leqslant 100$，再预处理出所有的答案，询问时 $O(1)$ 回答即可。算一下复杂度：$O(n\cdot 2^n\cdot 2^n + 2^n\cdot k) \approx O(2e8)$，这道题时间限制2s，好像可以卡过——事实上是，codeforces评测机太快了，用时最多的点仅有592ms。$qwq$ 可是追求卓越的我们并不甘心就此止步，于是 meet in the middle 再度粉墨登场。观察上面的复杂度，发现 $4096\times 4096=16777216$，只不过再乘以一个 $n$ 就变成 $2e8$了，所以可以想办法不乘 $n$。预处理出一半长度的字符串，最多 $2^6=64$ 种，然后再用这 $64$ 种情况预处理 $4096\times 4096$ 所有情况即可。复杂度 $O(\frac{n}{2}\cdot 2^{\frac{n}{2}}\cdot 2^{\frac{n}{2}} + 2^n \cdot 2^n + k\cdot 2^n) \approx O(2e7)$（好吧，再加点常数） codeforces 上最多389ms CodeCode#1 O(2e7)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;#define fo0(i,a,b) for(int i=(a);i&lt;(b);i++)#define fo1(i,a,b) for(int i=(a);i&lt;=(b);i++)#define fd0(i,a,b) for(int i=(a);i&gt;(b);i--)#define fd1(i,a,b) for(int i=(a);i&gt;=(b);i--)//此处省略 define 的一些东西和读入输出优化int n, m, q, k, w[20], v1[70][70], v2[70][70], val, cnt[4100], ans[4100][105];char s[20];inline int trans(char s[])&#123; int res = 0; fd1(i, n, 1) res = (res &lt;&lt; 1) + s[i] - '0'; return res;&#125;int main()&#123; in(n); in(m); in(q); fo0(i, 0, n) in(w[i]); fo1(i, 1, m)&#123; scanf("%s", s+1); cnt[trans(s)]++; &#125; fo0(i, 0, 1 &lt;&lt; (n/2)) fo0(j, 0, 1 &lt;&lt; (n/2)) fo0(b, 0, n/2)&#123; v1[i][j] += w[b] * ((i&gt;&gt;b&amp;1) == (j&gt;&gt;b&amp;1)); v2[i][j] += w[b+(n+1)/2] * ((i&gt;&gt;b&amp;1) == (j&gt;&gt;b&amp;1)); &#125; fo0(i, 0, 1 &lt;&lt; n)&#123; fo0(j, 0, 1 &lt;&lt; n)&#123; int t = (1 &lt;&lt; (n / 2)) - 1; val = v1[i&amp;t][j&amp;t] + v2[i&gt;&gt;((n+1)/2)][j&gt;&gt;((n+1)/2)]; if(n &amp; 1) val += w[n/2] * ((i&gt;&gt;(n/2)&amp;1) == (j&gt;&gt;(n/2)&amp;1)); if(val &lt;= 100) ans[i][val] += cnt[j]; &#125; &#125; fo0(i, 0, 1 &lt;&lt; n) fo1(j, 1, 100) ans[i][j] += ans[i][j-1]; while(q--)&#123; scanf("%s", s+1); in(k); outln(ans[trans(s)][k]); &#125; return 0;&#125; Code#2 O(2e8)123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;#define fo0(i,a,b) for(int i=(a);i&lt;(b);i++)#define fo1(i,a,b) for(int i=(a);i&lt;=(b);i++)#define fd0(i,a,b) for(int i=(a);i&gt;(b);i--)#define fd1(i,a,b) for(int i=(a);i&gt;=(b);i--)//此处省略 define 的一些东西和读入输出优化int n, m, q, k, w[20], val, cnt[4100], ans[4100][105];char s[20];inline int trans(char s[])&#123; int res = 0; fd1(i, n, 1) res = (res &lt;&lt; 1) + s[i] - '0'; return res;&#125;int main()&#123; in(n); in(m); in(q); fo0(i, 0, n) in(w[i]); fo1(i, 1, m)&#123; scanf("%s", s+1); cnt[trans(s)]++; &#125; fo0(i, 0, 1 &lt;&lt; n)&#123; fo0(j, 0, 1 &lt;&lt; n)&#123; val = 0; fo0(b, 0, n) val += w[b] * ((i&gt;&gt;b&amp;1) == (j&gt;&gt;b&amp;1)); if(val &lt;= 100) ans[i][val] += cnt[j]; &#125; &#125; fo0(i, 0, 1 &lt;&lt; n) fo1(j, 1, 100) ans[i][j] += ans[i][j-1]; while(q--)&#123; scanf("%s", s+1); in(k); outln(ans[trans(s)][k]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>位运算</category>
        <category>meet in the middle</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces 242.E] XOR on Segment（线段树）]]></title>
    <url>%2F2018%2F08%2F23%2FCodeforces-242-E-XOR-on-Segment%EF%BC%88%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[E. XOR on Segmenttime limit per test:4 secondsmemory limit per test:256 megabytesinput:standard inputoutput:standard output You’ve got an array $a$, consisting of $n$ integers $a_1,a_2,…,a_n$. You are allowed to perform two operations on this array: Calculate the sum of current array elements on the segment $[l,r]$, that is, count value $a_l+a_{l+1}+…+a_r$. Apply the xor operation with a given number $x$ to each array element on the segment $[l,r]$, that is, execute $a_l=a_l \oplus x,a_{l+1} = a_{l+1} \oplus x,…,a_r=a_r\oplus x$. This operation changes exactly $r-l+1$ array elements. Expression $x\oplus y$ means applying bitwise xor operation to numbers $x$ and $y$. The given operation exists in all modern programming languages, for example in language C++ and Java it is marked as “^”, in Pascal — as “xor”. You’ve got a list of m operations of the indicated type. Your task is to perform all given operations, for each sum query you should print the result you get. InputThe first line contains integer $n$ $(1≤n≤10^5)$ — the size of the array. The second line contains space-separated integers $a_1,a_2,…,a_n$ $(0≤a_i≤10^6)$ — the original array. The third line contains integer $m$ $(1≤m≤5·10^4)$ — the number of operations with the array. The $i$-th of the following $m$ lines first contains an integer $t_i$ $(1≤t_i≤2)$ — the type of the i-th query. If $t_i=1$, then this is the query of the sum, if $t_i=2$, then this is the query to change array elements. If the $i$-th operation is of type $1$, then next follow two integers $l_i,r_i$ $(1≤l_i≤r_i≤n)$. If the $i$-th operation is of type $2$, then next follow three integers $l_i,r_i,x_i$ $(1≤l_i≤r_i≤n,1≤x_i≤10^6)$. The numbers on the lines are separated by single spaces. OutputFor each query of type $1$ print in a single line the sum of numbers on the given segment. Print the answers to the queries in the order in which the queries go in the input. Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams, or the %I64d specifier. Examples input output 54 10 3 13 781 2 42 1 3 31 2 41 3 32 2 5 51 1 52 1 2 101 2 3 262203411 64 7 4 0 7 352 2 3 81 1 52 3 5 12 4 5 61 2 3 3828 解题思路由于 $x\leqslant10^6$，即 $x$ 不超过20位，可以每一位都开一个线段树，总共开二十个线段树。异或操作即是区间取反（$0$ 变成 $1$，$1$ 变成 $0$），询问操作转化为求区间$1$的个数。如图，以样例1为例，竖着一个虚线框即开成一个线段树。 时间复杂度 $O(20\cdot n\log n)$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;using namespace std;//此处省了略 define 的一些东西和读入输出优化const int N = 100005;int n, m, opt, ql, qr;LL a, qx, pow2[N];struct SegmentTree&#123;#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((tr[num][id].l + tr[num][id].r) &gt;&gt; 1)#define len(id) (tr[num][id].r - tr[num][id].l + 1) struct segTree&#123; int l, r; LL cnt; bool rev; &#125;tr[25][N&lt;&lt;2]; inline markRev(int num, int id)&#123; tr[num][id].rev ^= 1; tr[num][id].cnt = len(id) - tr[num][id].cnt; &#125; inline void pushup(int num, int id)&#123; tr[num][id].cnt = tr[num][lid].cnt + tr[num][rid].cnt; &#125; inline void pushdown(int num, int id)&#123; if(tr[num][id].l == tr[num][id].r) return; if(tr[num][id].rev)&#123; markRev(num, lid); markRev(num, rid); tr[num][id].rev = 0; &#125; &#125; void build(int num, int id, int l, int r)&#123; tr[num][id].l = l, tr[num][id].r = r; if(l == r) return; build(num, lid, l, mid); build(num, rid, mid+1, r); pushup(num, id); &#125; LL query(int num, int id, int l, int r)&#123; pushdown(num, id); if(tr[num][id].l == l &amp;&amp; tr[num][id].r == r) return tr[num][id].cnt; if(r &lt;= mid) return query(num, lid, l, r); else if(l &gt; mid) return query(num, rid, l, r); else return query(num, lid, l, mid) + query(num, rid, mid+1, r); &#125; void change(int num, int id, int l, int r)&#123; pushdown(num, id); if(tr[num][id].l == l &amp;&amp; tr[num][id].r == r)&#123; markRev(num, id); return; &#125; if(r &lt;= mid) change(num, lid, l, r); else if(l &gt; mid) change(num, rid, l, r); else change(num, lid, l, mid), change(num, rid, mid+1, r); pushup(num, id); &#125;&#125;seg;int main()&#123; pow2[0] = 1; fo1(j, 1, 20) pow2[j] = pow2[j-1] * 2; in(n); fo1(j, 0, 20) seg.build(j, 1, 1, n); fo1(i, 1, n)&#123; in(a); fo1(j, 0, 20) if((a &gt;&gt; j) &amp; 1 == 1) seg.change(j, 1, i, i); &#125; in(m); while(m--)&#123; in(opt); in(ql); in(qr); if(opt == 1)&#123; LL ans = 0; fo1(j, 0, 20) ans += seg.query(j, 1, ql, qr) * pow2[j]; outln(ans); &#125; else&#123; in(qx); fo1(j, 0, 20) if((qx &gt;&gt; j) &amp; 1 == 1) seg.change(j, 1, ql, qr); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces 1006.F] Xor-Paths（meet in the middle）]]></title>
    <url>%2F2018%2F08%2F22%2FCodeforces-1006-F-Xor-Paths%EF%BC%88meet-in-the-middle%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接 解题思路最暴力的搜索很容易实现，但是从 $(1,1)$ 到 $(n,m)$ 有 $C_{n+m-2}^{n-1}$ 种走法，大概是 $10^{11}$ 左右的复杂度，显然会 TLE。我们可以用 meet in the middle 来优化搜索。具体的，从 $(1,1)$ 搜索到一个折半点就停止搜索，再从 $(n.n)$ 搜索到折半点，然后用折半点的信息统计答案。折半点可以选择 $x+y=(n+m)/2$ 的点以保证搜索深度。对于这道题，在每一个折半点处开一个map，统计第一次搜索后得到的异或值及其出现次数；第二次搜索到同一个折半点时，统计符合答案的异或值的次数即可。运用 meet in the middle，把这道题的时间复杂度降到了 $10^5$ 数量级。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;//此处省略 define 的一些东西和读入输出优化const int N = 25;int n, m;LL k, a[N][N], ans;map&lt;LL, LL&gt; v[N][N];void dfs1(int x, int y, LL val)&#123; if(x + y == (n + m) / 2 + 1)&#123; v[x][y][val]++; return; &#125; if(x + 1 &lt;= n) dfs1(x + 1, y, val ^ a[x + 1][y]); if(y + 1 &lt;= m) dfs1(x, y + 1, val ^ a[x][y + 1]);&#125;void dfs2(int x, int y, LL val)&#123; if(x + y == (n + m) / 2 + 1)&#123; ans += v[x][y][val ^ a[x][y] ^ k]; return; &#125; if(x - 1 &gt;= 1) dfs2(x - 1, y, val ^ a[x - 1][y]); if(y - 1 &gt;= 1) dfs2(x, y - 1, val ^ a[x][y - 1]);&#125;int main()&#123; in(n); in(m); in(k); fo1(i, 1, n) fo1(j, 1, m) in(a[i][j]); dfs1(1, 1, a[1][1]); dfs2(n, m, a[n][m]); out(ans); return 0;&#125;]]></content>
      <categories>
        <category>搜索</category>
        <category>meet in the middle</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ZJOI2005]午餐（dp，贪心）]]></title>
    <url>%2F2018%2F08%2F21%2FZJOI2005-%E5%8D%88%E9%A4%90%EF%BC%88dp%EF%BC%8C%E8%B4%AA%E5%BF%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述上午的训练结束了，THU ACM小组集体去吃午餐，他们一行N人来到了著名的十食堂。这里有两个打饭的窗口，每个窗口同一时刻只能给一个人打饭。由于每个人的口味（以及胃口）不同，所以他们要吃的菜各有不同，打饭所要花费的时间是因人而异的。另外每个人吃饭的速度也不尽相同，所以吃饭花费的时间也是可能有所不同的。 THU ACM小组的吃饭计划是这样的：先把所有的人分成两队，并安排好每队中各人的排列顺序，然后一号队伍到一号窗口去排队打饭，二号队伍到二号窗口去排队打饭。每个人打完饭后立刻开始吃，所有人都吃完饭后立刻集合去六教地下室进行下午的训练。 现在给定了每个人的打饭时间和吃饭时间，要求安排一种最佳的分队和排队方案使得所有人都吃完饭的时间尽量早。 假设THU ACM小组在时刻0到达十食堂，而且食堂里面没有其他吃饭的同学（只有打饭的师傅）。每个人必须而且只能被分在一个队伍里。两个窗口是并行操作互不影响的，而且每个人打饭的时间是和窗口无关的，打完饭之后立刻就开始吃饭，中间没有延迟。 现在给定N个人各自的打饭时间和吃饭时间，要求输出最佳方案下所有人吃完饭的时刻。 输入第一行一个整数N，代表总共有N个人。 以下N行，每行两个整数 Ai，Bi。依次代表第i个人的打饭时间和吃饭时间。 输出一个整数T，代表所有人吃完饭的最早时刻。 输入样例12345652 27 71 36 48 5 输出样例117 说明所有输入数据均为不超过200的正整数。 解题思路乍一看人的顺序不定，好像无从下手，这时就需要靠贪心排一个序。先考虑只有一个窗口的情况：画一个图（蓝色打饭时间，绿色吃饭时间）容易发现答案是所有打饭时间之和（定值）加上虚线右边支出来的一截的最大长度，所以我们要尽量让支出来的长度小。这可以贪心实现，并且贪心策略很简单：按吃饭时间从大到小排序即可。因为吃饭时间长的就更容易支出去，理所当然的应该尽可能往前放。 所以其实一个窗口的答案是可以通过贪心排序确定下来的，那么现在题目的变数就只有两个窗口如何选择了，我们就此dp。dp状态里，我们显然需要知道已经排到第几个人了，还要知道两个队伍的信息。综合考虑后发现，我们只需要第一个队伍总共打饭时间即可，因为哪些人去了第一个队伍并不重要，此时我们可以通过简单计算算出第二个队伍总共打饭时间，于是我们定义 $dp[i][j]$ 为前 $i$ 个人中，第一个队伍总共打饭时间为 $j$ 的最小集合时间。由此推出： dp状态：$dp[i][j]$ 为前 $i$ 个人中，第一个队伍总共打饭时间为 $j$ 的最小集合时间 dp方程：$dp[i][j] = min( max(dp[i-1][j-p[i].a], j + p[i].b), max(dp[i-1][j], sum[i] - j + p[i].b) );$即分别考虑第 $i$ 个去第一个还是第二个窗口。$sum[i]$ 表示前 $i$ 个人的总共打饭时间 dp顺序：由转移方程可得：依次for i = 1 to n，for j = 0 to sum[i] 即可 边界条件：dp[0][0] = 0，其他初始状态为INF 时间复杂度：$O(N^3)$ Code123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;//此处省略了 define 的一些东西和输入输出优化const int N = 205;const int INF = 1e9;int n, dp[N][N*N], sum[N], ans = INF;struct Person&#123; int a, b;&#125;p[N];bool cmp(Person x, Person y)&#123; return x.b &gt; y.b; &#125;int main()&#123; in(n); fo1(i, 1, n)&#123; in(p[i].a); in(p[i].b); &#125; sort(p+1, p+n+1, cmp); mset(dp, 0x3f); dp[0][0] = 0; fo1(i, 1, n)&#123; sum[i] = sum[i-1] + p[i].a; fo1(j, 0, sum[i])&#123; if(j &gt;= p[i].a) dp[i][j] = min(dp[i][j], max(dp[i-1][j-p[i].a], j + p[i].b)); dp[i][j] = min(dp[i][j], max(dp[i-1][j], sum[i] - j + p[i].b)); &#125; &#125; fo1(i, 0, sum[n]) ans = min(ans, dp[n][i]); outln(ans); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>贪心</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>ZJOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces 1023.E]Down or Right（交互题）]]></title>
    <url>%2F2018%2F08%2F19%2FCodeforces-1023-E-Down-or-Right%EF%BC%88%E4%BA%A4%E4%BA%92%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[E. Down or Righttime limit per test: 1 secondmemory limit per test: 256 megabytesinput: standard inputoutput: standard outputThis is an interactive problem. Bob lives in a square grid of size $n×n$, with rows numbered $1$ through $n$ from top to bottom, and columns numbered $1$ through $n$ from left to right. Every cell is either allowed or blocked, but you don’t know the exact description of the grid. You are given only an integer $n$.Bob can move through allowed cells but only in some limited directions. When Bob is in an allowed cell in the grid, he can move down or right to an adjacent cell, if it is allowed.You can ask at most $4\cdot n$ queries of form “? $r_1$ $c_1$ $r_2$ $c_2$” ($1≤r_1≤r_2≤n$, $1≤c_1≤c_2≤n$). The answer will be “YES” if Bob can get from a cell $(r_1,c_1)$ to a cell $(r_2,c_2)$, and “NO” otherwise. In particular, if one of the two cells (or both) is a blocked cell then the answer is “NO” for sure. Since Bob doesn’t like short trips, you can only ask queries with the manhattan distance between the two cells at least $n-1$, i.e. the following condition must be satisfied: $(r_2-r_1)+(c_2-c_1)≥n-1$.It’s guaranteed that Bob can get from the top-left corner $(1,1)$ to the bottom-right corner $(n,n)$ and your task is to find a way to do it. You should print the answer in form “! S” where $S$ is a string of length $2\cdot n-2$ consisting of characters ‘D’ and ‘R’, denoting moves down and right respectively. The down move increases the first coordinate by $1$, the right move increases the second coordinate by $1$. If there are multiple solutions, any of them will be accepted. You should terminate immediately after printing the solution. InputThe only line of the input contains an integer $n$ $(2≤n≤500)$ — the size of the grid. OutputWhen you are ready to print the answer, print a single line containing “! S” where where $S$ is a string of length $2\cdot n-2$ consisting of characters ‘D’ and ‘R’, denoting moves down and right respectively. The path should be a valid path going from the cell $(1,1)$ to the cell $(n,n)$ passing only through allowed cells. InteractionYou can ask at most $4\cdot n$ queries. To ask a query, print a line containing “? $r_1$ $c_1$ $r_2$ $c_2$” ($1≤r_1≤r_2≤n$, $1≤c_1≤c_2≤n$). After that you should read a single line containing “YES” or “NO” depending on the answer of the query. “YES” means Bob can go from the cell $(r_1,c_1)$ to the cell $(r_2,c_2)$, “NO” means the opposite. Note that the grid is fixed before the start of your solution and does not depend on your queries. After printing a query do not forget to output end of line and flush the output. Otherwise you will get Idleness limit exceeded or other negative verdict. To do this, use: fflush(stdout) or cout.flush() in C++; System.out.flush() in Java; flush(output) in Pascal; stdout.flush() in Python; see documentation for other languages. Answer “BAD” instead of “YES” or “NO” means that you made an invalid query. Exit immediately after receiving “BAD” and you will see Wrong answer verdict. Otherwise you can get an arbitrary verdict because your solution will continue to read from a closed stream. Example input output 4YESNOYESYES ? 1 1 4 4? 1 2 4 3? 4 1 4 4? 1 4 4 4! RDRRDD 解题思路从 $(1,1)$ 尽可能向下走，即询问? x y n n，到达对角线为止；再从 $(n,n)$ 尽可能向左走，即询问? 1 1 x y，到达对角线为止。这样，两次到达的对角线一定是同一个点。询问次数为 $2\cdot n$。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;int n;char ans[5];vector&lt;char&gt; v1, v2;inline bool ask(int r1, int c1, int r2, int c2)&#123; printf("? %d %d %d %d\n", r1, c1, r2, c2); fflush(stdout); scanf("%s", ans); return ans[0] == 'Y';&#125;inline bool can(int r1, int c1, int r2, int c2)&#123; return r1 &gt;= 1 &amp;&amp; r1 &lt;= n &amp;&amp; c1 &gt;= 1 &amp;&amp; c1 &lt;= n &amp;&amp; r2 &gt;= 1 &amp;&amp; r2 &lt;= n &amp;&amp; c2 &gt;= 1 &amp;&amp; c2 &lt;= n &amp;&amp; (r2 - r1) + (c2 - c1) &gt;= n - 1;&#125;int main()&#123; scanf("%d", &amp;n); int nowx = 1, nowy = 1; while(nowx + nowy &lt; n + 1)&#123; if(nowx &lt; n)&#123; if(ask(nowx + 1, nowy, n, n))&#123; nowx++; v1.push_back('D'); &#125; else&#123; nowy++; v1.push_back('R'); &#125; &#125; else&#123; nowy++; v1.push_back('R'); &#125; &#125; nowx = nowy = n; while(nowx + nowy &gt; n + 1)&#123; if(nowy &gt; 1)&#123; if(ask(1, 1, nowx, nowy - 1))&#123; nowy--; v2.push_back('R'); &#125; else&#123; nowx--; v2.push_back('D'); &#125; &#125; else&#123; nowx--; v2.push_back('D'); &#125; &#125; printf("! "); for(int i = 0; i &lt; v1.size(); i++) putchar(v1[i]); for(int i = v2.size() - 1; i &gt;= 0; i--) putchar(v2[i]); putchar(10); return 0;&#125;]]></content>
      <categories>
        <category>交互题</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大子矩形问题学习笔记]]></title>
    <url>%2F2018%2F08%2F16%2F%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E5%BD%A2%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[很经典的国家集训队论文：浅谈用极大化思想解决最大子矩形问题 最大子矩形问题：在一个给定的矩形网格中有一些障碍点，要找出网格内部不包含任何障碍点，且边界与坐标轴平行的最大子矩形。 悬线法 $O(nm)$个人理解：枚举在子矩形底边上的一个点，将它尽可能地向上扩展成一条高线，然后将这条高左右尽可能地平移得到一个矩形，用此矩形更新答案。枚举的复杂度已经达到了 $O(nm)$，所以我们需要预处理扩展和平移操作。 我们可以dp（或者叫递推也行）预处理：将每个点尽可能向上、向左、向右扩展到的位置存在数组 $u[][],l[][],r[][]$ 中（当然，存向上、向左、向右扩展的长度也行，但存位置对求答案来说更方便一点）123456For i = 1 to n For j = 1 to m u[i][j] = (能从(i-1,j)走到(i,j)) ? u[i-1][j] : i; l[i][j] = (能从(i,j-1)走到(i,j)) ? l[i][j-1] : j; For j = m to 1 r[i][j] = (能从(i,j+1)走到(i,j)) ? r[i][j+1] : j; 预处理后我们得到了点 $(i,j)$ 的高线。但是对于向左和向右，我们需要知道的不是每个点向左向右扩展的位置，而是每条高线向左向右扩展的位置，这个问题我们可以递推出来：12345For i = 2 to n For j = 1 to m if 能从(i-1,j)走到(i,j) l[i][j] = max(l[i][j], l[i-1][j] r[i][j] = min(r[i][j], r[i-1][j] 矩形面积就是 $(r[i][j] - l[i][j] + 1) * (i - u[i][j] + 1)$ 如此以来，我们就 $O(nm)$ 地解决了这个问题。 单调栈 $O(nm)$将每个点尽可能向上、向左、向右扩展到的长度存在数组 $u[][],l[][],r[][]$ 中。具体做法如下：For i = 1 to n 枚举矩形底边，对每一次枚举维护一个单增栈，存储的数据包括高度与宽度，For j = 1 to m，如果当前点高度大于栈顶元素高度，就直接入栈；否则，不断弹出栈顶元素，最后将所有弹出元素的宽度之和加上自身宽度作为新的宽度入栈。这样，我们就得到了一个点向左能扩展的最大长度（手动模拟一下就清楚了）。同理，For j = m to 1 就可以求出一个点向右扩展的最大长度。（当然，不用反过来for也能求出来，但是反过来for一遍挺方便的，何乐而不为？）单调栈做法的思想其实和悬线法本质上是一样的，只不过省去了递推那一步。 注意：有些题并不是两种方法都可以的 $O(S^2)$算法以奶牛浴场为经典的一类题，详见论文以及洛谷题解。 例题hdu1506 / poj2559底边已经定了，直接考察单调栈展开代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;stack&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)const int N = 100005;int n, h[N], len[N];LL ans;stack&lt;pii&gt; sta;int main()&#123; while(scanf("%d", &amp;n) &amp;&amp; n)&#123; ans = 0; while(!sta.empty()) sta.pop(); for(int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;h[i]); int sumL = 0; while(!sta.empty() &amp;&amp; h[i] &lt;= sta.top().first)&#123; sumL += sta.top().second; sta.pop(); &#125; len[i] = sumL; sta.push(mp(h[i], sumL + 1)); &#125; while(!sta.empty()) sta.pop(); for(int i = n; i &gt;= 1; i--)&#123; int sumL = 0; while(!sta.empty() &amp;&amp; h[i] &lt;= sta.top().first)&#123; sumL += sta.top().second; sta.pop(); &#125; len[i] += sumL; sta.push(mp(h[i], sumL + 1)); &#125; for(int i = 1; i &lt;= n; i++)&#123; len[i]++; ans = max(ans, 1ll * len[i] * h[i]); &#125; printf("%lld\n", ans); &#125; return 0;&#125; hdu2830枚举底边，按高度排个序，就变成了上一题。有趣的是，由于排了序，我们不用写单调栈，运用它的思想即可。展开代码 12345678910111213141516171819202122232425262728293031323334#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;stack&gt;using namespace std;const int N = 1005;int n, m, g[N][N], H[N][N], h[N], len[N], ans;char c[N][N];int main()&#123; while(scanf("%d%d", &amp;n, &amp;m) != EOF)&#123; ans = 0; for(int i = 1; i &lt;= n; i++)&#123; scanf("%s", c[i]+1); for(int j = 1; j &lt;= m; j++)&#123; if(c[i][j] == '0') H[i][j] = 0; else H[i][j] = H[i-1][j] + 1; &#125; &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++) h[j] = H[i][j]; sort(h+1, h+m+1); for(int j = 1; j &lt;= m; j++)&#123; if(h[j] == h[j-1]) continue; else ans = max(ans, h[j] * (m - j + 1)); &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125; hdu1505 / poj1964悬线法展开代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1005;int T, n, m, ans, g[N][N], l[N][N], u[N][N], r[N][N];char ch[10];int main()&#123; scanf("%d", &amp;T); while(T--)&#123; ans = 0; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; scanf("%s", ch); g[i][j] = ch[0] == 'F' ? 1 : 0; u[i][j] = l[i][j] = r[i][j] = 0; if(g[i][j] == 1) u[i][j] = i, l[i][j] = r[i][j] = j; &#125; &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(g[i][j] == 0) continue; if(i != 1) u[i][j] = g[i-1][j] == 1 ? u[i-1][j] : i; if(j != 1) l[i][j] = g[i][j-1] == 1 ? l[i][j-1] : j; &#125; for(int j = m; j &gt;= 1; j--)&#123; if(g[i][j] == 0) continue; if(j != m) r[i][j] = g[i][j+1] == 1 ? r[i][j+1] : j; &#125; &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(g[i][j] == 0) continue; if(g[i][j] == 1 &amp;&amp; g[i-1][j] == 1)&#123; l[i][j] = max(l[i][j], l[i-1][j]); r[i][j] = min(r[i][j], r[i-1][j]); &#125; ans = max(ans, (r[i][j] - l[i][j] + 1) * (i - u[i][j] + 1)); &#125; &#125; printf("%d\n", ans * 3); &#125; return 0;&#125; poj3494悬线法展开代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 2005;int n, m, l[N][N], r[N][N], u[N][N], g[N][N], ans;int main()&#123; while(scanf("%d%d", &amp;n, &amp;m) != EOF)&#123; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) scanf("%d", &amp;g[i][j]); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) u[i][j] = l[i][j] = r[i][j] = 0; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(g[i][j] == 0) continue; u[i][j] = g[i-1][j] == 1 ? u[i-1][j] : i; l[i][j] = g[i][j-1] == 1 ? l[i][j-1] : j; &#125; for(int j = m; j &gt;= 1; j--)&#123; if(g[i][j] == 0) continue; r[i][j] = g[i][j+1] == 1 ? r[i][j+1] : j; &#125; &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(g[i][j] == 0) continue; if(g[i-1][j] == 1)&#123; l[i][j] = max(l[i][j], l[i-1][j]); r[i][j] = min(r[i][j], r[i-1][j]); &#125; ans = max(ans, (r[i][j] - l[i][j] + 1) * (i - u[i][j] + 1)); &#125; &#125; printf("%d\n", ans); ans = 0; &#125; return 0;&#125; hdu2870最大子矩形一定要么全是 $a$，要么全是 $b$，要么全是 $c$。假设最大子矩形全是 $a$，那么把所有能变成 $a$ 的全变成 $a$ 一定比不变某些字母更好，以此求一次答案；同理，再全变成 $b$ 求一次答案，再全变成 $c$ 求一次答案。展开代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1005;int n, m, l[N][N], r[N][N], u[N][N], g[N][N], ans;char c[N][N];inline void work(char ch)&#123; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(ch == 'a' &amp;&amp; (c[i][j] == 'a' || c[i][j] == 'w' || c[i][j] == 'y' || c[i][j] == 'z')) g[i][j] = 1; else if(ch == 'b' &amp;&amp; (c[i][j] == 'b' || c[i][j] == 'w' || c[i][j] == 'x' || c[i][j] == 'z')) g[i][j] = 1; else if(ch == 'c' &amp;&amp; (c[i][j] == 'c' || c[i][j] == 'x' || c[i][j] == 'y' || c[i][j] == 'z')) g[i][j] = 1; else g[i][j] = 0; u[i][j] = i, l[i][j] = r[i][j] = j; &#125; &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(g[i][j] == 0) continue; if(i &gt; 1) u[i][j] = g[i-1][j] == 1 ? u[i-1][j] : i; if(j &gt; 1) l[i][j] = g[i][j-1] == 1 ? l[i][j-1] : j; &#125; for(int j = m; j &gt;= 1; j--)&#123; if(g[i][j] == 0) continue; if(j &lt; m) r[i][j] = g[i][j+1] == 1 ? r[i][j+1] : j; &#125; &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(g[i][j] == 0) continue; if(g[i-1][j] == 1)&#123; l[i][j] = max(l[i][j], l[i-1][j]); r[i][j] = min(r[i][j], r[i-1][j]); &#125; ans = max(ans, (r[i][j] - l[i][j] + 1) * (i - u[i][j] + 1)); &#125; &#125;&#125;int main()&#123; while(scanf("%d%d", &amp;n, &amp;m) != EOF)&#123; for(int i = 1; i &lt;= n; i++) scanf("%s", c[i] + 1); work('a'); work('b'); work('c'); printf("%d\n", ans); ans = 0; &#125; return 0;&#125; [ZJOI2007]棋盘制作悬线法展开代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 2005;int n, m, g[N][N], l[N][N], r[N][N], u[N][N], ans1, ans2;int main()&#123; memset(g, -1, sizeof g); scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; scanf("%d", &amp;g[i][j]); u[i][j] = i, l[i][j] = r[i][j] = j; &#125; &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(i != 1) u[i][j] = g[i][j] != g[i-1][j] ? u[i-1][j] : i; if(j != 1) l[i][j] = g[i][j] != g[i][j-1] ? l[i][j-1] : j; &#125; for(int j = m; j &gt;= 1; j--) if(j != m) r[i][j] = g[i][j] != g[i][j+1] ? r[i][j+1] : j; &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(i != 1 &amp;&amp; g[i][j] != g[i-1][j])&#123; l[i][j] = max(l[i][j], l[i-1][j]); r[i][j] = min(r[i][j], r[i-1][j]); &#125; int t1 = r[i][j] - l[i][j] + 1; int t2 = i - u[i][j] + 1; ans1 = max(ans1, min(t1, t2) * min(t1, t2)); ans2 = max(ans2, t1 * t2); &#125; &#125; printf("%d\n%d\n", ans1, ans2); return 0;&#125; 奶牛浴场洛谷上的题解 很详尽展开代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 5010;int L, W, n, x, y, ans;struct Point&#123; int x, y;&#125;p[N];bool cmp(Point a, Point b)&#123; if(a.y == b.y) return a.x &lt; b.x; return a.y &lt; b.y;&#125;bool cmp1(Point a, Point b)&#123; return a.x &lt; b.x;&#125;int main()&#123; scanf("%d%d%d", &amp;L, &amp;W, &amp;n); for(int i = 1; i &lt;= n; i++) scanf("%d%d", &amp;p[i].x, &amp;p[i].y); p[++n] = (Point)&#123;0, 0&#125;; p[++n] = (Point)&#123;0, W&#125;; p[++n] = (Point)&#123;L, 0&#125;; p[++n] = (Point)&#123;L, W&#125;; sort(p+1, p+n+1, cmp1); for(int i = 2; i &lt;= n; i++) ans = max(ans, (p[i].x - p[i-1].x) * W); sort(p+1, p+n+1, cmp); for(int i = 1; i &lt;= n; i++)&#123; int u = 0, d = L; for(int j = i + 1; j &lt;= n; j++)&#123; if(p[j].y == p[i].y) continue; ans = max(ans, (p[j].y - p[i].y) * (d - u)); if(p[j].x == p[i].x) u = d = p[j].x; else if(p[j].x &gt; p[i].x) d = min(d, p[j].x); else if(p[j].x &lt; p[i].x) u = max(u, p[j].x); &#125; ans = max(ans, (W - p[i].y) * (d - u)); &#125; for(int i = n; i &gt;= 1; i--)&#123; int u = 0, d = L; for(int j = i - 1; j &gt;= 1; j--)&#123; if(p[j].y == p[i].y) continue; ans = max(ans, (p[i].y - p[j].y) * (d - u)); if(p[j].x == p[i].x) u = d = p[j].x; else if(p[j].x &gt; p[i].x) d = min(d, p[j].x); else if(p[j].x &lt; p[i].x) u = max(u, p[j].x); &#125; ans = max(ans, p[i].y * (d - u)); &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>二维矩形相关</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[luogu P1417]烹调方案（贪心，排序，背包）]]></title>
    <url>%2F2018%2F08%2F12%2Fluogu-P1417-%E7%83%B9%E8%B0%83%E6%96%B9%E6%A1%88%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%8C%E6%8E%92%E5%BA%8F%EF%BC%8C%E8%83%8C%E5%8C%85%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目题目背景由于你的帮助，火星只遭受了最小的损失。但gw懒得重建家园了，就造了一艘飞船飞向遥远的earth星。不过飞船飞到一半，gw发现了一个很严重的问题：肚子饿了~ gw还是会做饭的，于是拿出了储藏的食物准备填饱肚子。gw希望能在T时间内做出最美味的食物，但是这些食物美味程度的计算方式比较奇葩，于是绝望的gw只好求助于你了。 题目描述一共有n件食材，每件食材有三个属性，ai，bi和ci，如果在t时刻完成第i样食材则得到ai-t*bi的美味指数，用第i件食材做饭要花去ci的时间。 众所周知，gw的厨艺不怎么样，所以他需要你设计烹调方案使得美味指数最大 输入输出格式输入格式：第一行是两个正整数T和n，表示到达地球所需时间和食材个数。 下面一行n个整数，ai 下面一行n个整数，bi 下面一行n个整数，ci 输出格式：输出最大美味指数 输入输出样例输入样例#1：123474 1502247 输出样例#1：1408 说明【数据范围】 对于40%的数据1&lt;=n&lt;=10 对于100%的数据1&lt;=n&lt;=50 所有数字均小于100,000 【题目来源】 tinylic改编 解题思路看起来很像一个0-1背包，但是……每个物品的价值在变。注意到价值的变化与物品的顺序有关，考虑两个相邻物品 $x$ 和 $y$，如果 $x$ 在前 $y$ 在后，那么他俩价值就是 a[x]-(p+c[x])*b[x]+a[y]-(p+c[x]+c[y])*b[y]同理，如果 $y$ 在前 $x$ 在后，那么价值是 a[y]-(p+c[y])*b[y]+a[x]-(p+c[x]+c[y])*b[x]二者比较大小，化简后得到 $x$ 在前 $y$ 在后更优的充要条件是 b[x]*c[y] > b[y]*c[x]所以我们就按它对物品先进行排序，接着挨个考虑是否使用某物品，也就是0-1背包了。 坑：注意开 long long Code1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;int T, n;LL dp[100005], ans;struct Food&#123; int a, b, c;&#125;f[55];bool cmp(Food x, Food y)&#123; return 1ll * x.b * y.c &gt; 1ll * y.b * x.c;&#125;int main()&#123; scanf("%d%d", &amp;T, &amp;n); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;f[i].a); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;f[i].b); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;f[i].c); sort(f+1, f+n+1, cmp); for(int i = 1; i &lt;= n; i++) for(int j = T; j &gt;= 0; j--) if(j &gt;= f[i].c) dp[j] = max(dp[j], dp[j-f[i].c]+1ll*(f[i].a-1ll*j*f[i].b)); for(int i = 1; i &lt;= T; i++) ans = max(ans, dp[i]); printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>贪心</category>
        <category>排序</category>
        <category>背包</category>
        <category>0-1背包</category>
      </categories>
      <tags>
        <tag>luogu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces 1019.A] Elections（枚举答案）]]></title>
    <url>%2F2018%2F08%2F12%2FCodeforces-1019-A-Elections%EF%BC%88%E6%9E%9A%E4%B8%BE%E7%AD%94%E6%A1%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[A. Electionstime limit: per test2 secondsmemory limit: per test256 megabytesinput:standard inputoutput:standard output As you know, majority of students and teachers of Summer Informatics School live in Berland for the most part of the year. Since corruption there is quite widespread, the following story is not uncommon. Elections are coming. You know the number of voters and the number of parties — $n$ and $m$ respectively. For each voter you know the party he is going to vote for. However, he can easily change his vote given a certain amount of money. In particular, if you give $i$-th voter $c_i$ bytecoins you can ask him to vote for any other party you choose. The United Party of Berland has decided to perform a statistical study — you need to calculate the minimum number of bytecoins the Party needs to spend to ensure its victory. In order for a party to win the elections, it needs to receive strictly more votes than any other party. InputThe first line of input contains two integers $n$ and $m$ $(1≤n,m≤3000)$ — the number of voters and the number of parties respectively. Each of the following $n$ lines contains two integers $p_i$ and $c_i$ $(1≤p_i≤m, 1≤c_i≤10^9)$ — the index of this voter’s preferred party and the number of bytecoins needed for him to reconsider his decision. The United Party of Berland has the index $1$. OutputPrint a single number — the minimum number of bytecoins needed for The United Party of Berland to win the elections. Examples input output 1 21 100 0 5 52 1003 2004 3005 4005 900 500 5 52 1003 2004 3005 8005 900 600 NoteIn the first sample, The United Party wins the elections even without buying extra votes. In the second sample, The United Party can buy the votes of the first and the fourth voter. This way The Party gets two votes, while parties $3$, $4$ and $5$ get one vote and party number $2$ gets no votes. In the third sample, The United Party can buy the votes of the first three voters and win, getting three votes against two votes of the fifth party. 解题思路这道题正着想不好想，那就不妨从答案出发！我们枚举一下 $1$ 号政党最终得票 $k$，那么其余政党得票必须小于 $k$，所以对于现在得票大于等于 $k$ 的政党，我们把他py交易到小于 $k$；如果这之后我们的得票还不足 $k$，就按价格从小到大py到 $k$。（具体看代码注释） 时间复杂度 $O(nm)$ 事实上，codeforces458C（链接）是此题加强版，暴力枚举 $k$ + 线段树可过。（口胡 qwq）不过据信，花的钱与 $k$ 的函数是单峰的？然而并不知道为什么。（欢迎留言讨论) Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int N = 3005;int n, m, p, c;LL ans = 1e18;vector&lt;int&gt; v[N], a;vector&lt;int&gt;::iterator it;LL cal(int x)&#123; //最终票数：x票 a.clear(); LL res = 0; int t = x - v[1].size(); //还需t票 for(int i = 2; i &lt;= m; i++)&#123; //先贿赂大于等于x票的政党使之小于x票 if(v[i].size() &lt; x)&#123; for(int j = 0; j &lt; v[i].size(); j++) a.push_back(v[i][j]); continue; &#125; for(int j = 0; j &lt; v[i].size(); j++)&#123; if(j &lt; v[i].size() - x + 1)&#123; t--; res += v[i][j]; &#125; else a.push_back(v[i][j]); &#125; &#125; if(t &lt; 0) return 1e18; //如果t&lt;0，说明要贿赂的人太多了，甚至多于最终票数x票了 if(t &gt; 0)&#123; //贿赂其他人凑齐x票 sort(a.begin(), a.end()); for(int i = 0; i &lt; a.size(); i++)&#123; res += 1ll * a[i]; t--; if(t == 0) break; &#125; &#125; return res;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++)&#123; scanf("%d%d", &amp;p, &amp;c); v[p].push_back(c); &#125; for(int i = 1; i &lt;= m; i++) sort(v[i].begin(), v[i].end()); for(int i = v[1].size();i &lt;= n; i++) //枚举最终票数 ans = min(ans, cal(i)); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>答案</category>
        <category>枚举答案</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces 1016.E] Rest In The Shades（二分，简单几何）]]></title>
    <url>%2F2018%2F08%2F06%2FCodeforces-1016-E-Rest-In-The-Shades%EF%BC%88%E4%BA%8C%E5%88%86%EF%BC%8C%E7%AE%80%E5%8D%95%E5%87%A0%E4%BD%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[E. Rest In The Shadestime limit: per test2 secondsmemory limit: per test256 megabytesinput:standard inputoutput:standard output There is a light source on the plane. This source is so small that it can be represented as point. The light source is moving from point $(a,s_y)$ to the $(b,s_y)$ $(s_y&lt;0)$ with speed equal to $1$ unit per second. The trajectory of this light source is a straight segment connecting these two points. There is also a fence on $OX$ axis represented as $n$ segments $(l_i,r_i)$ (so the actual coordinates of endpoints of each segment are $(l_i,0)$ and $(r_i,0)$. The point $(x,y)$ is in the shade if segment connecting $(x,y)$ and the current position of the light source intersects or touches with any segment of the fence. You are given $q$ points. For each point calculate total time of this point being in the shade, while the light source is moving from $(a,s_y)$ to the $(b,s_y)$. InputFirst line contains three space separated integers $s_y$, $a$ and $b$ $(-10^9≤s_y&lt;0$, $1≤a&lt;b≤10^9)$ — corresponding coordinates of the light source. Second line contains single integer $n$ $(1≤n≤2\cdot 10^5)$ — number of segments in the fence. Next $n$ lines contain two integers per line: $l_i$ and $r_i$ $(1≤l_i&lt;r_i≤10^9, r_{i-1}&lt;l_i)$ — segments in the fence in increasing order. Segments don’t intersect or touch each other. Next line contains single integer $q$ $(1≤q≤2\cdot 10^5)$ — number of points to check. Next $q$ lines contain two integers per line: $x_i$ and $y_i$ $(1≤x_i,y_i≤10^9)$ — points to process. OutputPrint $q$ lines. The $i$-th line should contain one real number — total time of the $i$-th point being in the shade, while the light source is moving from $(a,s_y)$ to the $(b,s_y)$. The answer is considered as correct if its absolute of relative error doesn’t exceed $10^{-6}$. Example input output -3 1 622 46 753 11 36 16 47 6 5.0000000000000003.0000000000000000.0000000000000001.5000000000000002.000000000000000 NoteThe 1-st point is always in the shade;the 2-nd point is in the shade while light source is moving from $(3,-3)$ to $(6,-3)$;the 3-rd point is in the shade while light source is at point $(6,-3)$.the 4-th point is in the shade while light source is moving from $(1,-3)$ to $(2.5,-3)$ and at point $(6,-3)$;the 5-th point is in the shade while light source is moving from $(1,-3)$ to $(2.5,-3)$ and from $(5.5,-3)$ to $(6,-3)$; 解题思路官方题解说的很清楚了： Let’s calculate the answer for a fixed point $P$. If you project with respect of $P$ each segment of the fence to the line containing light source you can see that the answer is the length of intersection of fence projection with segment $(A,B)$ of the trajectory light source.Key idea is the fact that the length of each fence segment is multiplied by the same coefficient $k=\frac{P_y+|s_y|}{P_y}$.On the other hand, fence segments whose projections lie inside $(A,B)$ form a subsegment in the array of segments, so its total length can be obtained with partial sums. And at most two fence segment are included in the answer partially, their positions can be calculated with lower_bound if you project points $A$ and $B$ on $OX$ axis.So now you can answer the query with $O(\log n)$ time (and quite small hidden constant) and resulting complexity is $O(n+q\log n)$ 具体来说：对于每个点 $P(P_x,P_y)$，连接 $PA$ 交 $x$ 轴于 $A’$，连接 $PB$ 交 $y$ 轴于 $B’$，则答案就是 $A’B’$ 内的篱笆长度乘以系数 $k=\frac{P_y+|s_y|}{P_y}$问题变成了如何快速求出 $A’B’$ 内的篱笆长度。首先可以二分找出 $A’B’$ 内的第一个完整篱笆和最后一个完整篱笆的编号（lower_bound 就可以搞定），然后利用前缀和 $O(1)$ 求出这两个篱笆之间的总长度，在加上一头一尾不完整的篱笆的长度即可。前缀和求出绿色部分长度，在单独处理蓝色部分长度。 坑：ans 变量要开 long double，而 long double 用 printf 输出的方式挺迷的（最后是用 %f 输出 (double)ans 才能在 codeforces 上正确输出） 复杂度 $O(n+q\log n)$ Code12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long double LD;const int N = 200005;int n, q;double sy, a, b, l[N], r[N], qx, qy, aa, bb, sum[N];LD ans;int main()&#123; scanf("%lf%lf%lf%d", &amp;sy, &amp;a, &amp;b, &amp;n); for(int i = 1; i &lt;= n; i++)&#123; scanf("%lf%lf", &amp;l[i], &amp;r[i]); sum[i] = r[i] - l[i] + sum[i-1]; &#125; scanf("%d", &amp;q); while(q--)&#123; scanf("%lf%lf", &amp;qx, &amp;qy); aa = (qy * a - qx * sy) / (qy - sy); bb = (qy * b - qx * sy) / (qy - sy); int L = lower_bound(l+1, l+n+1, aa) - l; int R = lower_bound(r+1, r+n+1, bb) - r; L--; if(L == R) ans = (LD)(bb - aa); else&#123; ans = (LD)(sum[R-1] - sum[L]); if(l[R] &lt;= bb &amp;&amp; bb &lt;= r[R]) ans += (LD)(bb - l[R]); if(l[L] &lt;= aa &amp;&amp; aa &lt;= r[L]) ans += (LD)(r[L] - aa); &#125; ans *= (LD)(qy -sy) / qy; printf("%.15f\n", (double)ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>简单几何</category>
        <category>分治</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转载]洛谷日报#18 简单食用的博弈论]]></title>
    <url>%2F2018%2F08%2F02%2F%E8%BD%AC%E8%BD%BD-%E6%B4%9B%E8%B0%B7%E6%97%A5%E6%8A%A5-18-%E7%AE%80%E5%8D%95%E9%A3%9F%E7%94%A8%E7%9A%84%E5%8D%9A%E5%BC%88%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[原文链接 博弈论又被称为对策论（Game Theory），既是现代数学的一个新分支，也是运筹学的一个重要学科。学习博弈论，可以指导我们这个充满竞争的世界中，我们要怎么做才能让自己（或者自己的集体）利益最大化。（《百度百科》） 特别鸣谢：@daifucong 感谢指出文章中的错误。博弈时往往有三种结果：负和博弈、零和博弈与正和博弈，用通俗的话解释就是两败俱伤、一方获利一方亏损和双赢。正和博弈当然是最好的结果，但是往往无法达成。 博弈论有很多的种类，我们介绍其中的几种。 一. 囚徒博弈论——为何走向穷途末路？有一个广为流传的故事：两个罪犯甲、乙入室盗窃并将屋子的主人杀害，被捕后分别审讯，他们都只承认盗窃罪，不承认故意杀人罪，这样他们都会被判处1年有期徒刑。这似乎对他们来说是最好的情况，但是后来他们却纷纷承认故意杀人罪，为什么呢？ 原因很简单：他们是分开审讯的。 假设盗窃罪判刑1年，故意杀人罪判刑8年，被别人揭穿会加刑1年，坦白减刑2年，那么就可以绘制一个简易的博弈论模型： 图真是太不美了(●—●) 明明可以少坐6年牢，为什么要招供呢？不妨从甲和乙的角度来考虑：由于不知道对方的消息，甲会认为，我不知道能不能相信乙，万一他先招供了，我就会坐10年的牢，为了不引起最坏的后果，还能够释放，我必须先招认！同样的，乙的想法和甲类似，再加上警察煽风点火，于是便纷纷招供，最后的结果是两人一起坐7年的牢。 这就呈现了所谓博弈论中的“纳什均衡”，简单来说是如果参加博弈的一方不改变策略，另一方就无法得到更好的结果，往往走向负和博弈，有兴趣的小伙伴可以点进去了解一下 $qwq$ 这就是最经典的囚徒博弈论。 二.枪手博弈论——弱者的生存法则故事是这样的：三个枪手（大佬，蒟蒻，我）积怨已久，决定进行一场决斗。当然，他们不是机器人，枪法有一定的差别（即使是大白也不会百发百中的），大佬是个神枪手，命中率是80%，蒟蒻差一些，命中率是60%，我最菜了。。。???????命中率只有40%（这是不是和我不常刷题有关(；д；)），如果在每人一枪只打出1颗子弹，且击中必杀，大家都保持绝对理性的前提下，出现了两个问题： 1.如果我们三个人同时开枪，谁活下来的概率会最大？ 2.如果我们轮流开枪，采用什么策略活下来的概率会大？ 首先讨论第1个问题，如果我们同时开枪，大佬一定是会把枪口对准蒟蒻的（他都是大佬了，不可能出现低级失误233），因为蒟蒻的命中率要比我高，他一定要先杀死对自己威胁大的那一个人。而蒟蒻会向大佬开枪，道理和大佬相同，我呢，自然把枪对准了大佬。这时来看一下3人的存活率，大佬是24%，蒟蒻是20%，至于我呢，因为没有人瞄准我，所以我的存活率是100%。这时，最菜的我反而成了存活率最高的人呢。( ? ?ω?? )? 好了，现在讨论第2个问题，如果我们轮流开枪呢？ 大佬先开枪依照“先杀死威胁大的目标的原则”，大佬自然要把枪口对准蒟蒻，如果杀死了……（此处省略血腥内容）如果没杀死呢，蒟蒻自然会向大佬开枪，全程我可以毫发无埙。这时，我再拿起枪，瞄准剩下的一个目标，（或者两个目标都活着的话就朝天）开一枪，娱乐一下，胜率我仍然是最大的。so easy！妈妈再也不用担心我打不准了 蒟蒻先开枪蒟蒻会把枪口对准对他更具有威胁的大佬，我不会有危险，如果它命中了，我就向蒟蒻开枪，没打中就朝大佬开枪，最后我的存活率仍然是最大的。( ′-ω ?)▄︻┻┳══━一 我先开枪这是一个很让我纠结的问题，我该先向谁开枪呢？打大佬？没打中还好，会转化成大佬先开枪的情况（也难保他不记仇呀），万一RP不足手抖打中了呢，那就只剩下我和蒟蒻两人了，他一定会朝我开枪了,那我可就很危险了呀！不行不行，我可不能这么草率。那么如果朝蒟蒻开枪呢？那也是一样的，打中了反而会使自己置于更加危险的境地，因为大佬的命中率更高。打谁都不是，那么该怎么办呢？结论是：朝天开枪。Σ(?д?lll)这确实很滑稽，但也是最有效的方法，能够让情况变为大佬先开枪。所以博弈时往往要出奇策才能够取胜。 不信的话大家可以试一下，三个砝码，一个骰子（虽然无法得到80%，60%和40%，但是可以先用一下），开枪时转动骰子，如果大佬转到1,2,3,4,5，那么他杀死了他的目标，蒟蒻转到1,2,3，那么他杀死了他的目标，如果我菜鸡转到1，那么我杀死了我的目标。 多试几次，看看谁的存活率大！ 好了，我们继续狗血剧情，我们突然握手言和了，决定改日再战……（剧本太狗血，我编不下去了。。。）啊，反正就是这次我们没有决斗，然后呢，大家都想在下一次的决斗中把对方打趴下，回家苦练枪法，大佬的命中率提升到了100%（蒟蒻知道了吓得瑟瑟发抖），蒟蒻不甘落后命中率提高到80%，我太懒了也太菜了，命中率毫无提升，还是40%（我是一个比蒟蒻还弱的人）＼( ′?∧?｀)／ ，于是，按照领错了的剧本，我们又相遇了，又要决斗，那么按照刚才的情况推理，大佬向蒟蒻开枪，蒟蒻向大佬开枪，我向大佬开枪，大佬的存活率是12%，蒟蒻的存活率是0%（快给他准备一份便当！），我的存活率是100%，依然是最高的ヽ(≧?≦)?，但是其余两人的存活率却发生了变化，这说明，只要任何数据发生变化，存活率都会发生巨大的变化。 本来故事要结束了，突然，导演（我怎么会告诉你那就是我？！）认为蒟蒻还应该有戏份，于是又让他们握手言和了（什么鬼？！）。这会大家（包括我啦）都意识到了枪法的重要性，开始苦砺枪法，命中率都提升到了100%，后来（你已经猜到了），我们又一次相遇了。这次每人只有一颗子弹，两个问题： 同时放枪，你会选择打人还是放空枪？ 由我先开始放枪，我该打人还是放空枪？ 先讨论1，结束后无非4种情况： (1) 自己活着，另外两个人去领盒饭了；(2) 自己活着，另外一个人也活着；(3) 自己和另一个人一起去领盒饭；(4) 自己独自去领盒饭。 因为别人指向谁开枪是无法预测的，所以每个人的存活率是相等的，这时如果放弃开枪，就会让另外两人的存活率提高，所以这时应该朝任何一个人开一枪，至少不减小对他人的威胁，因为大家命中率都是100%，所以这时打谁就显得不那么重要了，朝一个人放一枪，听天由命吧。 再来讨论2，那就会有很大的不同，分情况讨论一下： (1) 朝人开枪：必定杀死一人，然后场上变为两人，另外一人开枪，那么他必定会朝我开枪，然后就没有然后了。。。 不可取不可取，我还没演完呢，不能去领盒饭|。?ω?)っ (2) 于是乎应该考虑另一种方法：放空枪。 一旦我打出了仅有的一颗子弹后，我对于另外两人便变得没有威胁了，这样轮到下一个人开枪时，他一定会朝另外一个人开枪，因为如果第二个人不打死他而是选择放空枪，下一回合他就会有50%的概率被干掉，这是不可取的。 这样就变成了一个另外两方自相残杀的局面，从而最后两个人活下来。 但是如果他识破了我的计谋要朝我放枪呢？那样他就一定会被第三个人打挂，还不如放空枪的存活率，他一定会打死第三个人。 综上所述，放空枪是最有利的选择。 讲了这么多，大家心里应该有个疑问： 这讲的都是模型，有应用价值吗？ 其实大家耳熟能详的历史中就有呀(～￣▽￣)～ 三方对立，有强有弱，互相牵制，大家想到了什么？ 对，是三国！ 三国时期的赤壁之战，刘备最弱，孙权其次，曹操最强，曹操要和孙权干架，诸葛亮的想法是：二虎相争，必有一伤，如果曹操输了必定一蹶不振，孙权就会向刘备开刀，如果孙权被灭，曹操也必定会攻打刘备。这时刘备帮助较弱的孙权，将曹操打败，但是又“一不小心”让关羽把曹操在华容道放掉了，以达到制衡的目的。节省篇幅，这里战争细节就不扯了。这就是枪手博弈论的应用。 那么为啥不帮曹操呢？ 这是因为魏国实力更强，如果联曹攻吴，东吴很可能会被灭掉，蜀国为了避免不利情况出现，应该联吴抗曹，这样不足以将魏国消灭。 好了，导演要逃杀青了，下一集海盗分金见！ $qwq$ 这一集真的要剧终了 三.海盗分金博弈论——倒推取胜这一讲跟海盗打仗无关！！！故事是这样的： 5个海盗抢了100个金币（我说过跟打仗无关），准备分，但是他们分的方法非常奇特（为什么不平分？）他们准备了5个签，分别写上1,2,3,4,5，然后抽签，按抽签顺序（从小到大）轮流制定方案，从1号开始，他制定了分金方案后大家需要立即表决（该海盗也表决），如果有半数以上（含半数）的人支持，则方案通过，按此方案分金，否则（重口味的来了！）就会被扔到海里喂鲨鱼。 我们做如下假设： 每一个海盗都是绝对理性的，且思考周全，智商极高，不会做出错误判断。 不存在某些海盗私下结伙或有仇的情况。 海盗不会因为通过的提案对自己不利而大打出手。 所有海盗都不想去喂鲨鱼。 所有海盗都想获得更多的金币。 好了，现在如果你是1号海盗，你该如何使自己获得最大利益？ 表面上看1号海盗是最不利的，因为他最有可能去喂鲨鱼，因为参与分金的海盗越少，越能获得更多利益，即使自己分文不取将金币全分给另外四个海盗，他们也仍然有可能会把他扔给鲨鱼。 怎么办？怎么办？怎么办？现在好慌呀！我不想喂鲨鱼！ 别急，咱冷静一下，再看一遍规则，你会发现一个突破点： 如果有半数以上（含半数）的人支持，则方案通过欸，也就是说不需要获得所有人的支持呀？我只要笼络2个处于劣势的海盗就可以不喂鲨鱼了！不慌了！ 可是，应该笼络谁呢？又该如何笼络呢？ 这时往往会三等分，但是这对分到金币的另外两个海盗显然不是最佳方案，行不通呀。 这时大家可能会嫉妒5号，既安全又能分钱。 别急着嫉妒，请大家回去看一遍本小节的标题。 看完了吗？倒推取胜对不对？那我们就从简单的情况想起： 5号明显是最安全的，因为他没有喂鲨鱼的危险，但是他真的能分到钱吗？[?_??] 倒推举例证明： 假设只剩4号，5号两人，你、2号和3号都喂鲨鱼了（当然你不想这样），这时4号分金，他会怎么办呢，肯定会是100:0，表决时4号一定赞成，5号即使反对，支持人数也过了半数，表决结果是5号无法改变的，这样5号就会颗粒无收，这时他处于劣势，所以3号的提案里只要给他1枚金币，他就一定会赞成来避免自己的劣势情况，同样的，按照笼络劣势海盗原则，3号海盗指定的方案应该是99:0:1，放弃4号，笼络5号，这样3号，5号赞成，提议通过，5号获利1金币，不再处于劣势，处在劣势的变成了4号。 是不是有头绪了？我们再加上一个海盗，2号制定方案，应该笼络处于劣势的4号海盗，方案为：99:0:1:0（当然也可以笼络5号，方法不止一种），2号、4号海盗赞成，提议通过。劣势海盗为3号。 最后加上1号海盗，也就是我们，应该笼络谁呢，首先要笼络劣势的3号，放弃优势的2号，再在4号、5号之间任选一个，制定方案（一种例子，大家可以再想其他的）为：98:0:1:1:0，就可以通过。 没想到吧，看似最危险的1号可以化险为夷还能疯狂敛财，最安全的5号却可能颗粒无收，如果正思入手，很容易卡住，倒推却容易多了，大家要学会用。 当然，现实生活中大家或多或少都是非理性的，海盗往往宁可同归于尽也不会让1号拿走98枚金币的，所以这个模型仅供分析 博弈论的几个分支就讲到这里，希望对大家有所帮助！ 拜拜咯！]]></content>
      <categories>
        <category>博弈论</category>
      </categories>
      <tags>
        <tag>洛谷日报</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HNOI2004]宠物收养场（平衡树/set）]]></title>
    <url>%2F2018%2F07%2F25%2FHNOI2004-%E5%AE%A0%E7%89%A9%E6%94%B6%E5%85%BB%E5%9C%BA%EF%BC%88%E5%B9%B3%E8%A1%A1%E6%A0%91-set%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述凡凡开了一间宠物收养场。收养场提供两种服务：收养被主人遗弃的宠物和让新的主人领养这些宠物。每个领养者都希望领养到自己满意的宠物，凡凡根据领养者的要求通过他自己发明的一个特殊的公式，得出该领养者希望领养的宠物的特点值a（a是一个正整数，a&lt;2^31），而他也给每个处在收养场的宠物一个特点值。这样他就能够很方便的处理整个领养宠物的过程了，宠物收养场总是会有两种情况发生：被遗弃的宠物过多或者是想要收养宠物的人太多，而宠物太少。被遗弃的宠物过多时，假若到来一个领养者，这个领养者希望领养的宠物的特点值为a，那么它将会领养一只目前未被领养的宠物中特点值最接近a的一只宠物。（任何两只宠物的特点值都不可能是相同的，任何两个领养者的希望领养宠物的特点值也不可能是一样的）如果有两只满足要求的宠物，即存在两只宠物他们的特点值分别为a-b和a+b，那么领养者将会领养特点值为a-b的那只宠物。收养宠物的人过多，假若到来一只被收养的宠物，那么哪个领养者能够领养它呢？能够领养它的领养者，是那个希望被领养宠物的特点值最接近该宠物特点值的领养者，如果该宠物的特点值为a，存在两个领养者他们希望领养宠物的特点值分别为a-b和a+b，那么特点值为a-b的那个领养者将成功领养该宠物。一个领养者领养了一个特点值为a的宠物，而它本身希望领养的宠物的特点值为b，那么这个领养者的不满意程度为abs(a-b)。你得到了一年当中，领养者和被收养宠物到来收养所的情况，请你计算所有收养了宠物的领养者的不满意程度的总和。这一年初始时，收养所里面既没有宠物，也没有领养者。 输入第一行为一个正整数n，n&lt;=80000，表示一年当中来到收养场的宠物和领养者的总数。接下来的n行，按到来时间的先后顺序描述了一年当中来到收养场的宠物和领养者的情况。每行有两个正整数a, b，其中a=0表示宠物，a=1表示领养者，b表示宠物的特点值或是领养者希望领养宠物的特点值。（同一时间呆在收养所中的，要么全是宠物，要么全是领养者，这些宠物和领养者的个数不会超过10000个） 输出仅有一个正整数，表示一年当中所有收养了宠物的领养者的不满意程度的总和mod 1000000以后的结果。 输入样例1234565 0 2 0 4 1 31 21 5 输出样例13 样例解释abs(3-2) + abs(2-4)=3，最后一个领养者没有宠物可以领养。 解题思路题意很简单，就是让你实现每次在 $\log N$ 时间内对两个有序数列进行插入或二分查找——平衡树可以解决。不过，既然有 STL 这种东西，这道题用 set 水水就过了……（但是确实手写 splay 要快些） 一个小技巧：事先在平衡树（或set）中插入无限小 -INF 和无限大 INF，防止在查询前驱后继时出现 RE 等情况。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;set&gt;using namespace std;const int INF = 1e9;const int MOD = 1000000;int n, a, b, ans;set&lt;int&gt; pet;set&lt;int&gt; own;set&lt;int&gt;::iterator it;int main()&#123; scanf("%d", &amp;n); pet.insert(INF); pet.insert(-INF); own.insert(INF); own.insert(-INF); for(int i = 1; i &lt;= n; i++)&#123; scanf("%d%d", &amp;a, &amp;b); if(a == 0)&#123; if(own.size() &gt; 2)&#123; it = own.lower_bound(b); int t2 = *it, t1 = *(--it); if(abs(b - t1) &lt;= abs(t2 - b))&#123; (ans += abs(b - t1)) %= MOD; own.erase(t1); &#125; else&#123; (ans += abs(t2 - b)) %= MOD; own.erase(t2); &#125; &#125; else pet.insert(b); &#125; else&#123; if(pet.size() &gt; 2)&#123; it = pet.lower_bound(b); int t2 = *it, t1 = *(--it); if(abs(b - t1) &lt;= abs(t2 - b))&#123; (ans += abs(b - t1)) %= MOD; pet.erase(t1); &#125; else&#123; (ans += abs(t2 - b)) %= MOD; pet.erase(t2); &#125; &#125; else own.insert(b); &#125; &#125; printf("%d\n", ans % MOD); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>平衡树</category>
        <category>STL</category>
        <category>set</category>
      </categories>
      <tags>
        <tag>HNOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[网络流24题]太空飞行计划问题]]></title>
    <url>%2F2018%2F07%2F25%2F%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98-%E5%A4%AA%E7%A9%BA%E9%A3%9E%E8%A1%8C%E8%AE%A1%E5%88%92%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目描述W 教授正在为国家航天中心计划一系列的太空飞行。每次太空飞行可进行一系列商业性实验而获取利润。现已确定了一个可供选择的实验集合E={E1，E2，…，Em}，和进行这些实验需要使用的全部仪器的集合I={I1，I2，…In}。实验Ej需要用到的仪器是I的子集RjíI。配置仪器Ik的费用为ck美元。实验Ej的赞助商已同意为该实验结果支付pj美元。W教授的任务是找出一个有效算法，确定在一次太空飞行中要进行哪些实验并因此而配置哪些仪器才能使太空飞行的净收益最大。这里净收益是指进行实验所获得的全部收入与配置仪器的全部费用的差额。对于给定的实验和仪器配置情况，编程找出净收益最大的试验计划。 输入第1行有2 个正整数m和n。m是实验数，n是仪器数。接下来的m 行，每行是一个实验的有关数据。第一个数赞助商同意支付该实验的费用；接着是该实验需要用到的若干仪器的编号。最后一行的n个数是配置每个仪器的费用。 输出第1 行是实验编号；第2行是仪器编号；最后一行是净收益。 输入样例12342 310 1 225 2 35 6 7 输出样例1231 21 2 317 说明n,m&lt;=50 解题思路先假设我们接受了所有的实验，得到了 $\Sigma p_i$ 钱，然后要么减去某实验的收益，表示没有进行这个实验，要么减去某仪器的费用，表示使用了该仪器。实现方法是：将原点 $S$ 向实验连边，边权为该实验的收益（正数）；将仪器向汇点 $T$ 连边，边权是该仪器的费用（正数）；对应实验与仪器之间连边权为 INF 的边。如此，$\Sigma p_i - 最小割$ 即是答案。解释：由最小割的定义可知，被割的边一定是满流的，因此要么是 $S\rightarrow 实验$，要么是 $仪器\rightarrow T$ 的边，根据前面叙述，这两种情况分别代表了没有进行该实验和使用了该仪器。怎么输出方案呢？由以上分析可知，如果 $S$ 到某实验的边未满流，则做了该实验；某仪器到 $T$ 满流，则用了该仪器；所以，只要最后一次 dinic 时最后一次 bfs 后该点（实验/仪器）有层数，则使用了该点。 最后再吐槽一下 luogu 上的蜜汁输入…… Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;inline bool read(int&amp; x)&#123; x = 0; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123; if(ch == '\n') return false; ch = getchar(); &#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123; x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0'; ch = getchar(); &#125; if(ch == '\n') return false; return true;&#125;const int N = 155;const int INF = 1e9;int n, m, S, T, p, tot;struct Edge&#123; int nxt, from, to, cap;&#125;edge[N*N&lt;&lt;1];int head[N], edgeNum = 1;void addEdge(int from, int to, int cap)&#123; edge[++edgeNum] = (Edge)&#123;head[from], from, to, cap&#125;; head[from] = edgeNum;&#125;int lay[N];bool bfs()&#123; memset(lay, 0, sizeof lay); queue&lt;int&gt; q; q.push(S); lay[S] = 1; while(!q.empty())&#123; int cur = q.front(); q.pop(); for(int i = head[cur]; i; i = edge[i].nxt)&#123; if(edge[i].cap &lt;= 0) continue; if(!lay[edge[i].to])&#123; lay[edge[i].to] = lay[cur] + 1; q.push(edge[i].to); &#125; &#125; &#125; return lay[T];&#125;int dfs(int x, int minCap)&#123; if(x == T) return minCap; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(edge[i].cap &lt;= 0 || lay[edge[i].to] != lay[x] + 1) continue; int t = dfs(edge[i].to, min(minCap, edge[i].cap)); if(t)&#123; edge[i].cap -= t; edge[i^1].cap += t; return t; &#125; &#125; return 0;&#125;int dinic()&#123; int maxFlow = 0; while(bfs()) if(int flow = dfs(S, INF)) maxFlow += flow; return maxFlow;&#125;int main()&#123; read(m), read(n); S = 101, T = 102; for(int i = 1; i &lt;= m; i++)&#123; read(p); tot += p; addEdge(S, i, p); addEdge(i, S, 0); while(read(p))&#123; addEdge(i, p+50, INF); addEdge(p+50, i, 0); &#125; addEdge(i, p+50, INF); addEdge(p+50, i, 0); &#125; for(int i = 1; i &lt;= n; i++)&#123; read(p); addEdge(i+50, T, p); addEdge(T, i+50, 0); &#125; int ans = tot - dinic(); for(int i = 1; i &lt;= m; i++) if(lay[i]) printf("%d ", i); putchar(10); for(int i = 1; i &lt;= n; i++) if(lay[i+50]) printf("%d ", i); printf("\n%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>网络流</category>
        <category>最大流/最小割</category>
      </categories>
      <tags>
        <tag>网络流24题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ZJOI2007]矩阵游戏（二分图匹配）]]></title>
    <url>%2F2018%2F07%2F25%2FZJOI2007-%E7%9F%A9%E9%98%B5%E6%B8%B8%E6%88%8F%EF%BC%88%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目Description小Q是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏——矩阵游戏。矩阵游戏在一个N*N黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）列交换操作：选择矩阵的任意行列，交换这两列（即交换对应格子的颜色）游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色。对于某些关卡，小Q百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！！于是小Q决定写一个程序来判断这些关卡是否有解。 Input第一行包含一个整数T，表示数据的组数。接下来包含T组数据，每组数据第一行为一个整数N，表示方阵的大小；接下来N行为一个N*N的01矩阵（0表示白色，1表示黑色）。 Output输出文件应包含T行。对于每一组数据，如果该关卡有解，输出一行Yes；否则输出一行No。 Sample Input12345678220 00 130 0 10 1 01 0 0 Sample Output12NoYes Hint对于100%的数据，N ≤ 200 解题思路对每一个黑格子都在其横坐标与纵坐标之间连一条边，可得到一个二分图。而题目相当于要求交换后可以得到 $1\rightarrow 1,2\rightarrow 2,\cdots,n\rightarrow n$ 这样一种匹配方法。容易发现，只要这个二分图存在一种匹配方法使所有点都被匹配上，那么我们一定可以通过交换得到 $1\rightarrow 1,2\rightarrow 2,\cdots,n\rightarrow n$ 的匹配。所以我们只需要判断该二分图最大匹配是否为 $N$ 即可。用网络流实现，则当且仅当最大流等于 $N$ 时有解。 以下代码为 dinic 实现最大流。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int INF = 1e9;const int N = 405;int C, S, T, n, a;struct Edge&#123; int nxt, from, to, cap;&#125;edge[N*N*2];int head[N], edgeNum = 1;void addEdge(int from, int to, int cap)&#123; edge[++edgeNum] = (Edge)&#123;head[from], from, to, cap&#125;; head[from] = edgeNum;&#125;int lay[N];bool bfs()&#123; memset(lay, 0, sizeof lay); queue&lt;int&gt; q; q.push(S); lay[S] = 1; while(!q.empty())&#123; int cur = q.front(); q.pop(); for(int i = head[cur]; i; i = edge[i].nxt)&#123; if(edge[i].cap &lt;= 0) continue; if(!lay[edge[i].to])&#123; lay[edge[i].to] = lay[cur] + 1; q.push(edge[i].to); &#125; &#125; &#125; return lay[T];&#125;int dfs(int x, int minCap)&#123; if(x == T) return minCap; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(edge[i].cap &lt;= 0 || lay[edge[i].to] != lay[x] + 1) continue; int t = dfs(edge[i].to, min(minCap, edge[i].cap)); if(t)&#123; edge[i].cap -= t; edge[i^1].cap += t; return t; &#125; &#125; return 0;&#125;int dinic()&#123; int maxFlow = 0; while(bfs()) if(int flow = dfs(S, INF)) maxFlow += flow; return maxFlow;&#125;void init()&#123; memset(head, 0, sizeof head); edgeNum = 1;&#125;int main()&#123; scanf("%d", &amp;C); while(C--)&#123; init(); scanf("%d", &amp;n); S = n + n + 1, T = n + n + 2; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; scanf("%d", &amp;a); if(a)&#123; addEdge(i, j+n, 1); addEdge(j+n, i, 0); &#125; &#125; addEdge(S, i, 1); addEdge(i, S, 0); addEdge(i+n, T, 1); addEdge(T, i+n, 0); &#125; puts(dinic() == n ? "Yes" : "No"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>二分图</category>
        <category>二分图匹配</category>
        <category>网络流</category>
        <category>最大流/最小割</category>
      </categories>
      <tags>
        <tag>ZJOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[网络流24题]飞行员配对方案问题]]></title>
    <url>%2F2018%2F07%2F24%2F%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98-%E9%A3%9E%E8%A1%8C%E5%91%98%E9%85%8D%E5%AF%B9%E6%96%B9%E6%A1%88%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目背景第二次世界大战时期.. 描述英国皇家空军从沦陷国征募了大量外籍飞行员。由皇家空军派出的每一架飞机都需要配备在航行技能和语言上能互相配合的2 名飞行员，其中1 名是英国飞行员，另1名是外籍飞行员。在众多的飞行员中，每一名外籍飞行员都可以与其他若干名英国飞行员很好地配合。如何选择配对飞行的飞行员才能使一次派出最多的飞机。对于给定的外籍飞行员与英国飞行员的配合情况，试设计一个算法找出最佳飞行员配对方案，使皇家空军一次能派出最多的飞机。对于给定的外籍飞行员与英国飞行员的配合情况，编程找出一个最佳飞行员配对方案，使皇家空军一次能派出最多的飞机。 输入第 1 行有 2 个正整数 m 和 n。n 是皇家空军的飞行员总数(n&lt;100)；m 是外籍飞行员数(m&lt;=n)。外籍飞行员编号为 1~m；英国飞行员编号为 m+1~n。接下来每行有 2 个正整数 i 和 j，表示外籍飞行员 i 可以和英国飞行员 j 配合。最后以 2个-1 结束。 输出第 1 行是最佳飞行员配对方案一次能派出的最多的飞机数 M。接下来 M 行是最佳飞行员配对方案。每行有 2个正整数 i 和 j，表示在最佳飞行员配对方案中，飞行员 i 和飞行员 j 配对。如果所求的最佳飞行员配对方案不存在，则输出‘No Solution!’。 输入样例1234567891011125 101 71 82 62 92 103 73 84 74 85 10-1 -1 输出样例1234541 72 93 85 10 解题思路裸的二分图匹配问题用网络流做重在构图：源点 S 向 1~m 连容量为 1 的边，m+1~n 向汇点 T 连容量为 1 的边，能匹配的也连容量为 1 的边。这样，最大匹配即是最大流。 下面是 Dinic 算法跑最大流的代码。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int INF = 1e9;const int N = 205;int n, m, u, v, S, T;struct Edge&#123; int from, nxt, to, cap;&#125;edge[N*N*2];int head[N], edgeNum = 1;void addEdge(int from, int to, int cap)&#123; edge[++edgeNum].nxt = head[from]; edge[edgeNum].from = from; edge[edgeNum].to = to; edge[edgeNum].cap = cap; head[from] = edgeNum;&#125;int lay[N];bool bfs()&#123; memset(lay, 0, sizeof lay); queue&lt;int&gt; q; q.push(S); lay[S] = 1; while(!q.empty())&#123; int cur = q.front(); q.pop(); for(int i = head[cur]; i; i = edge[i].nxt)&#123; if(edge[i].cap &lt;= 0) continue; if(!lay[edge[i].to])&#123; lay[edge[i].to] = lay[cur] + 1; q.push(edge[i].to); &#125; &#125; &#125; return lay[T];&#125;int dfs(int x, int minn)&#123; if(x == T) return minn; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(edge[i].cap &lt;= 0 || lay[edge[i].to] != lay[x] + 1) continue; int t = dfs(edge[i].to, min(minn, edge[i].cap)); if(t)&#123; edge[i].cap -= t; edge[i^1].cap += t; return t; &#125; &#125; return 0;&#125;int dinic()&#123; int maxFlow = 0; while(bfs()) if(int flow = dfs(S, INF)) maxFlow += flow; return maxFlow;&#125;int main()&#123; scanf("%d%d", &amp;m, &amp;n); S = n + 1, T = n + 2; for(int i = 1; i &lt;= m; i++)&#123; addEdge(S, i, 1); addEdge(i, S, 0); &#125; for(int i = m + 1; i &lt;= n; i++)&#123; addEdge(i, T, 1); addEdge(T, i, 0); &#125; while(scanf("%d%d", &amp;u, &amp;v) &amp;&amp; (u != -1 &amp;&amp; v != -1))&#123; addEdge(u, v, 1); addEdge(v, u, 0); &#125; int ans = dinic(); if(ans == 0) return puts("No Solution!"), 0; printf("%d\n", ans); for(int i = 1; i &lt;= edgeNum; i += 2) if(edge[i].cap == 1 &amp;&amp; edge[i].from != S &amp;&amp; edge[i].from != T &amp;&amp; edge[i].to != S &amp;&amp; edge[i].to != T) printf("%d %d\n", edge[i].from, edge[i].to); return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>二分图</category>
        <category>二分图匹配</category>
        <category>网络流</category>
        <category>最大流/最小割</category>
      </categories>
      <tags>
        <tag>网络流24题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ZJOI2006]书架（平衡树）]]></title>
    <url>%2F2018%2F07%2F23%2FZJOI2006-%E4%B9%A6%E6%9E%B6%EF%BC%88%E5%B9%B3%E8%A1%A1%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述小T有一个很大的书柜。这个书柜的构造有些独特，即书柜里的书是从上至下堆放成一列。她用$1$到$n$的正整数给每本书都编了号。小T在看书的时候，每次取出一本书，看完后放回书柜然后再拿下一本。由于这些书太有吸引力了，所以她看完后常常会忘记原来是放在书柜的什么位置。不过小T的记忆力是非常好的，所以每次放书的时候至少能够将那本书放在拿出来时的位置附近，比如说她拿的时候这本书上面有$X$本书，那么放回去时这本书上面就只可能有$X-1$、$X$或$X+1$本书。当然也有特殊情况，比如在看书的时候突然电话响了或者有朋友来访。这时候粗心的小T会随手把书放在书柜里所有书的最上面或者最下面，然后转身离开。久而久之，小T的书柜里的书的顺序就会越来越乱，找到特定的编号的书就变得越来越困难。于是她想请你帮她编写一个图书管理程序，处理她看书时的一些操作，以及回答她的两个提问：(1)编号为$X$的书在书柜的什么位置；(2)从上到下第$i$本书的编号是多少。 输入第一行有两个数$n,m$，分别表示书的个数以及命令的条数；第二行为$n$个正整数：第$i$个数表示初始时从上至下第$i$个位置放置的书的编号；第三行到$m+2$行，每行一条命令。命令有5种形式：1．Top S——表示把编号为$S$的书放在最上面。2． Bottom S——表示把编号为$S$的书放在最下面。3． Insert S T——$T∈\{-1,0,1\}$，若编号为$S$的书上面有$X$本书，则这条命令表示把这本书放回去后它的上面有$X+T$本书；4． Ask S——询问编号为$S$的书的上面目前有多少本书。5． Query S——询问从上面数起的第$S$本书的编号。 输出对于每一条Ask或Query语句你应该输出一行，一个数，代表询问的答案。 输入样例12345678910111210 101 3 2 7 5 8 10 4 9 6Query 3Top 5Ask 6Bottom 3Ask 3Top 6Insert 4 -1Query 5Query 2Ask 2 输出样例123456299753 说明100%的数据，$n,m &lt;= 80000$ 解题思路用平衡树可以完成这些操作： Top S：将该元素旋转至根，然后将其左子树连到它的后继上 Bottom S：将该元素旋转至根，然后将其右子树连到它的前驱上 Insert S T：将该元素与其前驱或后继交换信息 Ask S：将该元素旋转至根，返回其左子树大小 Query S：在树上直接找即可 时间复杂度：$O(M\log_2N)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 80005;int n, m, q, qt, a[N], pos[N];char opt[10];struct BST&#123;#define lson tr[x].son[0]#define rson tr[x].son[1] struct Splay&#123; int fa, son[2]; int size, id; &#125;tr[N]; int root = 0, cnt = 0; inline int newNode()&#123; cnt++; tr[cnt].fa = tr[cnt].son[0] = tr[cnt].son[1] = 0; tr[cnt].size = 1, tr[cnt].id = 0; return cnt; &#125; inline void pushup(int x)&#123; tr[x].size = tr[lson].size + tr[rson].size + 1; &#125; inline int build(int l, int r, int f)&#123; if(l &gt; r) return 0; int mid = (l + r) &gt;&gt; 1; int x = newNode(); tr[x].id = a[mid]; pos[a[mid]] = x; tr[x].fa = f; tr[x].son[0] = build(l, mid-1, x); tr[x].son[1] = build(mid+1, r, x); pushup(x); return x; &#125; inline void rotate(int x, int kind)&#123; int y = tr[x].fa, z = tr[y].fa, B = tr[x].son[kind]; tr[x].son[kind] = y, tr[y].son[!kind] = B, tr[z].son[tr[z].son[1] == y] = x; tr[x].fa = z, tr[y].fa = x, tr[B].fa = y; pushup(y), pushup(x); &#125; inline void splay(int x, int goal)&#123; if(x == goal) return; while(tr[x].fa != goal)&#123; int y = tr[x].fa, z = tr[y].fa; int dir1 = !(tr[y].son[1] == x), dir2 = !(tr[z].son[1] == y); if(z == goal) rotate(x, dir1); else&#123; if(dir1 == dir2) rotate(y, dir2); else rotate(x, dir1); rotate(x, dir2); &#125; &#125; if(goal == 0) root = x; &#125; inline int find(int k)&#123; int now = root; while(k)&#123; if(k &lt;= tr[tr[now].son[0]].size) now = tr[now].son[0]; else if(k == tr[tr[now].son[0]].size + 1) return now; else&#123; k -= tr[tr[now].son[0]].size + 1; now = tr[now].son[1]; &#125; &#125; return now; &#125; inline void top(int x)&#123; x = pos[x]; splay(x, 0); if(!tr[x].son[0]) return; if(!tr[x].son[1]) tr[x].son[1] = tr[x].son[0], tr[x].son[0] = 0; else&#123; int p = find(tr[tr[x].son[0]].size + 2); tr[p].son[0] = tr[x].son[0], tr[tr[x].son[0]].fa = p; tr[x].son[0] = 0; splay(tr[p].son[0], 0); &#125; &#125; inline void bot(int x)&#123; x = pos[x]; splay(x, 0); if(!tr[x].son[1]) return; if(!tr[x].son[0]) tr[x].son[0] = tr[x].son[1], tr[x].son[1] = 0; else&#123; int p = find(tr[tr[x].son[0]].size); tr[p].son[1] = tr[x].son[1], tr[tr[x].son[1]].fa = p; tr[x].son[1] = 0; splay(tr[p].son[1], 0); &#125; &#125; inline void insert(int x, int t)&#123; if(!t) return; x = pos[x]; splay(x, 0); int p = find(t == -1 ? tr[tr[root].son[0]].size : tr[tr[root].son[0]].size + 2); swap(tr[root].id, tr[p].id); swap(pos[tr[root].id], pos[tr[p].id]); &#125; inline int ask(int x)&#123; x = pos[x]; splay(x, 0); return tr[tr[x].son[0]].size; &#125; inline int query(int k)&#123; return tr[find(k)].id; &#125; inline void print(int x)&#123; if(tr[x].son[0]) print(tr[x].son[0]); printf("%d ", tr[x].id); if(tr[x].son[1]) print(tr[x].son[1]); &#125;&#125;T;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); T.root = T.build(1, n, 0); while(m--)&#123; scanf("%s%d", opt, &amp;q); switch(opt[0])&#123; case 'T': T.top(q); break; case 'B': T.bot(q); break; case 'I': scanf("%d", &amp;qt); T.insert(q, qt); break; case 'A': printf("%d\n", T.ask(q)); break; case 'Q': printf("%d\n", T.query(q)); break; default: break; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>平衡树</category>
      </categories>
      <tags>
        <tag>ZJOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2009 T3]最优贸易（分层图spfa / 两次spfa / tarjan + topo）]]></title>
    <url>%2F2018%2F07%2F07%2FNOIP2009-T3-%E6%9C%80%E4%BC%98%E8%B4%B8%E6%98%93%EF%BC%88%E5%88%86%E5%B1%82%E5%9B%BEspfa-%E4%B8%A4%E6%AC%A1spfa-tarjan-topo%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述$C$ 国有 $n$ 个大城市和 $m$ 条道路，每条道路连接这 $n$ 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 $m$ 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 $1$ 条。$C$ 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。商人阿龙来到 $C$ 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 $C$ 国 n 个城市的标号从 $1 \sim n$ ，阿龙决定从 $1$ 号城市出发，并最终在 $n$ 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 $n$ 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品――水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 $C$ 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。现在给出 $n$ 个城市的水晶球价格， $m$ 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。 输入第一行包含 $2$ 个正整数 $n$ 和 $m$ ，中间用一个空格隔开，分别表示城市的数目和道路的数目。第二行 $n$ 个正整数，每两个整数之间用一个空格隔开，按标号顺序分别表示这 $n$ 个城市的商品价格。接下来 $m$ 行，每行有 $3$ 个正整数 $x,y,z$ ，每两个整数之间用一个空格隔开。如果 $z=1$ ，表示这条道路是城市 $x$ 到城市 $y$ 之间的单向道路；如果 $z=2$ ，表示这条道路为城市 $x$ 和城市 $y$ 之间的双向道路。 输出一 个整数，表示最多能赚取的旅费。如果没有进行贸易，则输出 $0$ 。 输入样例12345675 5 4 3 5 6 1 1 2 1 1 4 1 2 3 2 3 5 1 4 5 2 输出样例15 数据范围输入数据保证 $1$ 号城市可以到达 $n$ 号城市。对于 10%的数据， $1≤n≤6$ 。对于 30%的数据， $1≤n≤100$ 。对于 50%的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。对于 100%的数据，$1≤n≤100000$ ，$1≤m≤500000$ ， $1≤x$ ， $y≤n$ ， 1≤z≤21≤z≤2 ， $1≤$ 各城市水晶球价格 $≤100$ 。 解题思路（共3种方法）法1——分层图spfa分层图是一个神奇的东西，建的好可以大大简化题目。针对这道题，我们可以把图分三层： 第一层表示买之前，第二层表示买之后卖之前，第三层表示卖之后； 每一层内部边权设为 $0$； 对于一个点 $i$，设 $i$ 能到 $j$，则从 $i$ 连一条边权为 $-v[i]$ 的单向边到 $j+n$（即 $j$ 在第二层图中对应的点），表示在 $i$ 买入后走到 $j$； 同理，从 $i+n$ 连一条边权为 $v[i]$ 的单向边到 $j+n+n$（即 $j$ 在第三层图中对应的点），表示在 $i$ 卖出后走到 $j$； 最后将 $n$ 和 $n+n+n$ 都连向一个终点 $T$。 那么，从 $1$ 出发到 $T$，要么一直在第一层中移动，表示没有进行买卖；要么从第一层经过第二层到达第三层，表示经过了一次买卖操作。可以发现，这样我们就把所有买卖情况考虑到了，因此，最后做一个简单的spfa找最长路即可。 法2——两次spfa设 $minPrice[i]$ 表示从 $1$ 到 $i$ 的路线中经过的最小价格，$maxPrice[i]$ 表示从 $i$ 到 $n$ 的路线中经过的最大价格，那么 $ans = \max\limits_{i=1}^{n} (maxPrice[i]-minPrice[i])$可以先正向用 spfa 求出 $minPrice$，再反向用 spfa 求出 $maxPrice$ 法3——tarjan+topo从50%的数据范围中得到启发，如果原图是一个DAG，那么我们可以用拓扑序得到答案：用拓扑序遍历该图，同时记录下历史最小价格，每到一个点用它的价格减去历史最小价格来更新答案，最后就能得到最大利润了。但是原图可能存在环，怎么办？我们可以用 tarjan 缩点。因为在同一个强连通分量中可以随意走动，所以缩点后新点的最低价格就是强连通分量中的最低价格，新点的最高价格就是强连通分量中的最高价格，于是我们成功把图转成了一个DAG，就可以用上述方法解决问题了。 Code#1分层图spfa 展开代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int N = 100005;const int M = 500005;const int INF = 1e9;int n, m, v[N], x, y, z, T, S;struct Edge&#123; int nxt, to, dis;&#125;edge[M&lt;&lt;2];int head[N*3], edgeNum;void addEdge(int from, int to, int dis)&#123; edge[++edgeNum].nxt = head[from]; edge[edgeNum].to = to; edge[edgeNum].dis = dis; head[from] = edgeNum;&#125;int dis[N*3];bool inq[N*3];void spfa()&#123; for(int i = 1; i &lt;= n * 3; i++) dis[i] = -INF; queue&lt;int&gt; q; q.push(S); dis[S] = 0; inq[S] = 1; while(!q.empty())&#123; int cur = q.front(); q.pop(); inq[cur] = 0; for(int i = head[cur]; i; i = edge[i].nxt)&#123; if(dis[edge[i].to] &lt; dis[cur] + edge[i].dis)&#123; dis[edge[i].to] = dis[cur] + edge[i].dis; if(!inq[edge[i].to])&#123; q.push(edge[i].to); inq[edge[i].to] = 1; &#125; &#125; &#125; &#125;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;v[i]); for(int i = 1; i &lt;= m; i++)&#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); addEdge(x, y, 0); addEdge(x+n, y+n, 0); addEdge(x+n+n, y+n+n, 0); addEdge(x, y+n, -v[x]); addEdge(x+n, y+n+n, v[x]); if(z == 2)&#123; addEdge(y, x, 0); addEdge(y+n, x+n, 0); addEdge(y+n+n, x+n+n, 0); addEdge(y, x+n, -v[y]); addEdge(y+n, x+n+n, v[y]); &#125; &#125; S = 1, T = n+n+n+1; addEdge(n, T, 0); addEdge(n+n+n, T, 0); spfa(); printf("%d\n", dis[T]); return 0;&#125; Code#2两次spfa 展开代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int MAXN = 100005;const int MAXM = 500005;int n, m, p[MAXN], u, v, q, ans;struct Edge&#123; int nxt, to;&#125;edge[MAXM&lt;&lt;1], fedge[MAXM&lt;&lt;1];int head[MAXN], edge_num;int fhead[MAXN], fedge_num;void add_edge(int from, int to)&#123; edge[++edge_num].nxt = head[from]; edge[edge_num].to = to; head[from] = edge_num; fedge[++fedge_num].nxt = fhead[to]; fedge[fedge_num].to = from; fhead[to] = fedge_num;&#125;int max_price[MAXN], min_price[MAXN];bool inq[MAXN];void spfa1()&#123; memset(inq, 0, sizeof inq); memset(min_price, 0x7f, sizeof min_price); queue&lt;int&gt; q; q.push(1); inq[1] = 1; min_price[1] = p[1]; while(!q.empty())&#123; int cur = q.front(); q.pop(); inq[cur] = 0; for(int i = head[cur]; i; i = edge[i].nxt)&#123; if(min_price[edge[i].to] &gt; min(min_price[cur], p[edge[i].to]))&#123; min_price[edge[i].to] = min(min_price[cur], p[edge[i].to]); if(!inq[edge[i].to])&#123; q.push(edge[i].to); inq[edge[i].to] = 1; &#125; &#125; &#125; &#125;&#125;void spfa2()&#123; memset(inq, 0, sizeof inq); memset(max_price, 0, sizeof max_price); queue&lt;int&gt; q; q.push(n); inq[n] = 1; max_price[n] = p[n]; while(!q.empty())&#123; int cur = q.front(); q.pop(); inq[cur] = 0; for(int i = fhead[cur]; i; i = fedge[i].nxt)&#123; if(max_price[fedge[i].to] &lt; max(max_price[cur], p[fedge[i].to]))&#123; max_price[fedge[i].to] = max(max_price[cur], p[fedge[i].to]); if(!inq[fedge[i].to])&#123; q.push(fedge[i].to); inq[fedge[i].to] = 1; &#125; &#125; &#125; &#125;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;p[i]); for(int i = 1; i &lt;= m; i++)&#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;q); add_edge(u, v); if(q == 2) add_edge(v, u); &#125; spfa1(); spfa2(); for(int i = 1; i &lt;= n; i++) ans = max(ans, max_price[i] - min_price[i]); printf("%d", ans); return 0;&#125; Code#3tarjan+topo 展开代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;const int MAXM = 500005;const int MAXN = 100005;int n, m, x, y, z, p[MAXN], minprice = 0x7fffffff, maxp[MAXN], minp[MAXN];inline int max(int a, int b)&#123; return a &gt; b ? a : b;&#125;inline int min(int a, int b)&#123; return a &lt; b ? a : b;&#125;struct Edge&#123; int nxt, to;&#125;edge[MAXM&lt;&lt;1], e[MAXM&lt;&lt;1], fe[MAXM&lt;&lt;1];int head[MAXN], edge_num;int fh[MAXN], fe_n;void add_edge(int from, int to)&#123; edge[++edge_num].nxt = head[from]; edge[edge_num].to = to; head[from] = edge_num; fe[++fe_n].nxt = fh[to]; fe[fe_n].to = from; fh[to] = fe_n;&#125;bool vis[MAXN];void dfs(int x)&#123; vis[x] = 1; for(int i = fh[x]; i; i = fe[i].nxt)&#123; if(!vis[fe[i].to]) dfs(fe[i].to); &#125;&#125;int h[MAXN], e_n, ind[MAXN];void a_e(int from, int to)&#123; e[++e_n].nxt = h[from]; e[e_n].to = to; h[from] = e_n; ind[to]++;&#125;int low[MAXN], dfn[MAXN], belong[MAXN], scc, dex;bool ins[MAXN];stack&lt;int&gt; s;void tarjan(int x)&#123; s.push(x); ins[x] = 1; low[x] = dfn[x] = ++dex; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(!vis[edge[i].to]) continue; if(!dfn[edge[i].to])&#123; tarjan(edge[i].to); low[x] = min(low[x], low[edge[i].to]); &#125; else if(ins[edge[i].to]) low[x] = min(low[x], dfn[edge[i].to]); &#125; if(low[x] == dfn[x])&#123; scc++; while(1)&#123; int cur = s.top(); s.pop(); ins[cur] = 0; belong[cur] = scc; maxp[scc] = max(maxp[scc], p[cur]); minp[scc] = min(minp[scc], p[cur]); if(cur == x) break; &#125; &#125;&#125;int f[MAXN], ans;void topo()&#123; queue&lt;int&gt; q; for(int s = 1; s &lt;= scc; s++) if(!ind[s]) q.push(s); while(!q.empty())&#123; int cur = q.front(); q.pop(); for(int i = h[cur]; i; i = e[i].nxt)&#123; ind[e[i].to]--; if(!ind[e[i].to])&#123; q.push(e[i].to); minprice = min(minprice, minp[e[i].to]); ans = max(ans, maxp[e[i].to] - minprice); &#125; &#125; &#125;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;p[i]); for(int i = 1; i &lt;= m; i++)&#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); add_edge(x, y); if(z == 2) add_edge(y, x); &#125; dfs(n); memset(maxp, 0, sizeof maxp); memset(minp, 0x7f, sizeof minp); for(int i = 1; i &lt;= n; i++) if(!dfn[i] &amp;&amp; vis[i]) tarjan(i); for(int i = 1; i &lt;= n; i++) for(int j = head[i]; j; j = edge[j].nxt) if(vis[edge[j].to] &amp;&amp; belong[edge[j].to] != belong[i]) a_e(belong[i], belong[edge[j].to]); topo(); printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>最短路</category>
        <category>强连通分量</category>
        <category>拓扑序</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder ARC099]E - Independence（图论，二分图染色）]]></title>
    <url>%2F2018%2F07%2F06%2FAtCoder-ARC099-E-Independence%EF%BC%88%E5%9B%BE%E8%AE%BA%EF%BC%8C%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9F%93%E8%89%B2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[E - IndependenceTime limit : 2sec / Memory limit : 1024MBScore : 700 points Problem StatementIn the State of Takahashi in AtCoderian Federation, there are $N$ cities, numbered $1,2,…,N$. $M$ bidirectional roads connect these cities. The $i$-th road connects City $A_i$ and City $B_i$. Every road connects two distinct cities. Also, for any two cities, there is at most one road that directly connects them. One day, it was decided that the State of Takahashi would be divided into two states, Taka and Hashi. After the division, each city in Takahashi would belong to either Taka or Hashi. It is acceptable for all the cities to belong Taka, or for all the cities to belong Hashi. Here, the following condition should be satisfied: Any two cities in the same state, Taka or Hashi, are directly connected by a road. Find the minimum possible number of roads whose endpoint cities belong to the same state. If it is impossible to divide the cities into Taka and Hashi so that the condition is satisfied, print -1. Constraints$2≤N≤700$$0≤M≤N(N?1)/2$$1≤A_i≤N$$1≤B_i≤N$$A_i≠B_i$If $i≠j$, at least one of the following holds: $A_i≠A_j$ and $B_i≠B_j$.If $i≠j$, at least one of the following holds: $A_i≠B_j$ and $B_i≠A_j$. InputInput is given from Standard Input in the following format: $N$ $M$$A_1 B_1$$A_2 B_2$:$A_M$ $B_M$ OutputPrint the answer. Samples Input Output 5 51 21 33 43 54 5 4 5 11 2 -1 4 31 21 32 3 3 10 397 27 15 65 89 102 88 73 1010 18 102 37 43 94 103 46 16 79 59 76 99 44 67 58 32 59 210 78 68 97 35 34 56 32 105 104 26 28 410 6 21 Sample#1:For example, if the cities 1,2 belong to Taka and the cities 3,4,5 belong to Hashi, the condition is satisfied. Here, the number of roads whose endpoint cities belong to the same state, is 4. Sample#2:In this sample, the condition cannot be satisfied regardless of which cities belong to each state. 解题思路题目大意：将一个图分成两个子图，使得每一个子图都是完全图。所有不相连的点不能在一个子图里，那么我们就对这些不相连点进行建边，然后二分图染色（即建立了一个原图的补图）在新图中，同一个连通块中且是相同颜色的点一定在同一个子图里，而不同连通块中不同颜色的点可以放在一起那么，用一个布尔数组 $s$ 做一个统计，$s[i]$ 表示是否存在大小为 $i$ 的子图，答案取最小情况即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 705;const int M = 490005;int n, m, u, v, ans = 0x7fffffff;bool g[N][N], s[N], t[N];int col[N], cnt[2];void dfs(int x, int c)&#123; col[x] = c; cnt[c == 1]++; for(int i = 1; i &lt;= n; i++)&#123; if(i == x || g[x][i]) continue; if(!col[i]) dfs(i, -c); else if(col[i] == c)&#123; puts("-1"); exit(0); &#125; &#125;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= m; i++)&#123; scanf("%d%d", &amp;u, &amp;v); g[u][v] = g[v][u] = 1; &#125; s[0] = 1; for(int i = 1; i &lt;= n; i++)&#123; if(col[i]) continue; cnt[0] = cnt[1] = 0; dfs(i, 1); memset(t, 0, sizeof t); for(int j = 0; j &lt;= n; j++)&#123; t[j+cnt[0]] |= s[j]; t[j+cnt[1]] |= s[j]; &#125; for(int j = 0; j &lt;= n; j++) s[j] = t[j]; &#125; for(int i = 0; i &lt;= n; i++) if(s[i]) ans = min(ans, i*(i-1)/2 + (n-i)*(n-i-1)/2); printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>二分图</category>
        <category>二分图染色</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[轮到我们了]]></title>
    <url>%2F2018%2F06%2F08%2F%E8%BD%AE%E5%88%B0%E6%88%91%E4%BB%AC%E4%BA%86%2F</url>
    <content type="text"><![CDATA[下午，高考结束的铃声终究是响了。此时此刻，高三的学长学姐们正式告别了十年寒窗的生涯——也意味着高三的接力棒，传到了我们手中。终于，轮到我们了。 我曾听说过高三的紧张与压力，也听说过高三的奋斗与无悔，只是，从来没有这么靠近过这一时刻。现在的我，不免有些紧张，也有些期待。有人做了这样一个比喻：如果说人生是一个椭圆轨道，梦想是椭圆的焦点，那么，高三就是距离焦点最近的地方——这是你最靠近你的梦想的时刻，也是你速度最快、最容易错过梦想的时刻。可以见得，高三是何等的关键。 从小学一年级开始，我们就开始了12km伏案苦读的长跑，现在，终于到了最后1km。这一路来，多少路边迷人的风景都没扰乱我们前行的意志，多少牵绊都没影响我们坚定的步伐。我们已经很优秀了，只是这最后一千米，我们还需要咬咬牙，再努力一些，坚持下去。因为，努力过，便无怨无悔。 是的，轮到我们了。愿我们不忘初心，砥砺前行。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces 988.F] Rain and Umbrellas（序列dp）]]></title>
    <url>%2F2018%2F06%2F03%2FCodeforces-988-F-Rain-and-Umbrellas%EF%BC%88%E5%BA%8F%E5%88%97dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[F. Rain and Umbrellastime limit per test:2 secondsmemory limit per test:256 megabytesinput:standard inputoutput:standard output Polycarp lives on a coordinate line at the point $x=0$. He goes to his friend that lives at the point $x=a$. Polycarp can move only from left to right, he can pass one unit of length each second. Now it’s raining, so some segments of his way are in the rain. Formally, it’s raining on $n$ non-intersecting segments, the $i$-th segment which is in the rain is represented as $[l_i,r_i]$ ($0≤l_i&lt;r_i≤a$). There are $m$ umbrellas lying on the line, the $i$-th umbrella is located at point $x_i$ ($0≤x_i≤a$) and has weight $p_i$. When Polycarp begins his journey, he doesn’t have any umbrellas. During his journey from $x=0$ to $x=a$ Polycarp can pick up and throw away umbrellas. Polycarp picks up and throws down any umbrella instantly. He can carry any number of umbrellas at any moment of time. Because Polycarp doesn’t want to get wet, he must carry at least one umbrella while he moves from $x$ to $x+1$ if a segment $[x,x+1]$ is in the rain (i.e. if there exists some $i$ such that $l_i≤x$ and $x+1≤r_i$). The condition above is the only requirement. For example, it is possible to go without any umbrellas to a point where some rain segment starts, pick up an umbrella at this point and move along with an umbrella. Polycarp can swap umbrellas while he is in the rain. Each unit of length passed increases Polycarp’s fatigue by the sum of the weights of umbrellas he carries while moving. Can Polycarp make his way from point $x=0$ to point $x=a$? If yes, find the minimum total fatigue after reaching $x=a$, if Polycarp picks up and throws away umbrellas optimally. InputThe first line contains three integers $a$, $n$ and $m$ ($1≤a,m≤2000,1≤n≤⌈\frac{a}{2}⌉$) — the point at which Polycarp’s friend lives, the number of the segments in the rain and the number of umbrellas. Each of the next $n$ lines contains two integers $l_i$ and $r_i$ ($0≤l_i&lt;r_i≤a$) — the borders of the $i$-th segment under rain. It is guaranteed that there is no pair of intersecting segments. In other words, for each pair of segments $i$ and $j$ either $r_i&lt;l_j$ or $r_j&lt;l_i$. Each of the next $m$ lines contains two integers $x_i$ and $p_i$ ($0≤x_i≤a$, $1≤p_i≤10^5$) — the location and the weight of the $i$-th umbrella. OutputPrint “-1“ (without quotes) if Polycarp can’t make his way from point $x=0$ to point $x=a$. Otherwise print one integer — the minimum total fatigue after reaching $x=a$, if Polycarp picks up and throws away umbrellas optimally. Examples input output 10 2 43 78 100 103 48 11 2 14 10 1 10 90 5 45 10 1 10 91 5 -1 NoteIn the first example the only possible strategy is to take the fourth umbrella at the point $x=1$, keep it till the point $x=7$ (the total fatigue at $x=7$ will be equal to $12$), throw it away, move on from $x=7$ to $x=8$ without an umbrella, take the third umbrella at x=8 and keep it till the end (the total fatigue at $x=10$ will be equal to $14$). In the second example the only possible strategy is to take the first umbrella, move with it till the point $x=9$, throw it away and proceed without an umbrella till the end. 解题思路这肯定是一道 dp 题。注意题目是从 $0$ 位置开始的，下列解法均先把所有位置右移了1格 首先有一个很显然的贪心：不可能同时拿着多把伞。然后预处理一下哪些地方下雨，哪些地方有伞，每把伞在什么位置 $O(n\cdot a+m)$ 下面是 dp：考虑到不同的状态取决于当前所在位置和当前拿着的伞，令 $dp[i][j]$ 表示走到 $i$ 时拿着第 $j$ 把伞（$j=0$ 表示没拿伞），分情况转移（已知 $dp[i][j]$，刷表法）： 拿着第 $j$ 把伞走到 $i+1$：$dp[i+1][j] = min(dp[i+1][j],dp[i][j] + weight[j])$前提： $j \neq 0$ 放下第 $j$ 把伞走到 $i+1$：$dp[i+1][0] = min(dp[i+1][0], dp[i][j])$前提：$i$ 处不下雨 拿起 $i$ 处的最轻的伞（假设是第 $k$ 把伞）走到 $i+1$：$dp[i+1][k] = min(dp[i+1][k], dp[i][j] + w[k]$前提：$i$ 处有伞 边界条件为 $dp[0][0] = 0$答案就是 $\min\limits_{i=0}^m dp[a][i]$ 坑点：同一个位置可以有多把伞！ 时间复杂度 $O(n\cdot a)$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 2005;bool rain[N];struct Umbrella&#123; int pos, w;&#125;umb[N];int a, n, m, x, y, umbre[N];int dp[N][N], ans = 1e9;int main()&#123; scanf("%d%d%d", &amp;a, &amp;n, &amp;m); a++; for(int i = 1; i &lt;= n; i++)&#123; scanf("%d%d", &amp;x, &amp;y); x++, y++; for(int j = x; j &lt; y; j++) rain[j] = 1; &#125; for(int i = 1; i &lt;= m; i++)&#123; scanf("%d%d", &amp;x, &amp;y); x++; umb[i].pos = x; umb[i].w = y; if(!umbre[x] || (umbre[x] &amp;&amp; y &lt; umb[umbre[x]].w)) umbre[x] = i; &#125; memset(dp, 0x3f, sizeof dp); dp[0][0] = 0; for(int i = 0; i &lt; a; i++)&#123; for(int j = 0; j &lt;= m; j++)&#123; if(umb[j].pos &gt; i) continue; if(j) dp[i+1][j] = min(dp[i+1][j], dp[i][j] + umb[j].w); if(!rain[i]) dp[i+1][0] = min(dp[i+1][0], dp[i][j]); if(umbre[i]) dp[i+1][umbre[i]] = min(dp[i+1][umbre[i]], dp[i][j] + umb[umbre[i]].w); &#125; &#125; for(int i = 0; i &lt;= m; i++) ans = min(ans, dp[a][i]); if(ans == 1e9) puts("-1"); else printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>序列dp</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces 985.E] Pencils and Boxes（dp，前缀和优化）]]></title>
    <url>%2F2018%2F05%2F27%2FCodeforces-985-E-Pencils-and-Boxes%EF%BC%88dp%EF%BC%8C%E5%89%8D%E7%BC%80%E5%92%8C%E4%BC%98%E5%8C%96%EF%BC%89%2F</url>
    <content type="text"><![CDATA[E. Pencils and Boxestime limit per test: 2 secondsmemory limit per test: 256 megabytesinput: standard inputoutput: standard output Mishka received a gift of multicolored pencils for his birthday! Unfortunately he lives in a monochrome world, where everything is of the same color and only saturation differs. This pack can be represented as a sequence $a_1, a_2, …, a_n$ of n integer numbers — saturation of the color of each pencil. Now Mishka wants to put all the mess in the pack in order. He has an infinite number of empty boxes to do this. He would like to fill some boxes in such a way that: Each pencil belongs to exactly one box; Each non-empty box has at least $k$ pencils in it; If pencils $i$ and $j$ belong to the same box, then $|a_i - a_j| ≤ d$, where $|x|$ means absolute value of $x$. Note that the opposite is optional, there can be pencils $i$ and $j$ such that $|a_i - a_j| ≤ d$ and they belong to different boxes. Help Mishka to determine if it’s possible to distribute all the pencils into boxes. Print &quot;YES&quot; if there exists such a distribution. Otherwise print &quot;NO&quot;. InputThe first line contains three integer numbers $n$, $k$ and $d$ ($1 ≤ k ≤ n ≤ 5·10^5$, $0 ≤ d ≤ 10^9$) — the number of pencils, minimal size of any non-empty box and maximal difference in saturation between any pair of pencils in the same box, respectively. The second line contains n integer numbers $a_1, a_2, …, a_n$ ($1 ≤ a_i ≤ 10^9$) — saturation of color of each pencil. OutputPrint &quot;YES&quot; if it’s possible to distribute all the pencils into boxes and satisfy all the conditions. Otherwise print &quot;NO&quot;. Examples Input Output 6 3 107 2 7 7 4 2 YES 6 2 34 5 3 13 4 10 YES 3 2 510 16 22 NO NoteIn the first example it is possible to distribute pencils into $2$ boxes with $3$ pencils in each with any distribution. And you also can put all the pencils into the same box, difference of any pair in it won’t exceed $10$. In the second example you can split pencils of saturations $[4, 5, 3, 4]$ into $2$ boxes of size $2$ and put the remaining ones into another box. 解题思路将数列排序，若有解，则一定存在一种数列划分的方式（即把连续一段铅笔放进一个盒子中）满足条件。设 $dp[i]$ 表示前 $i$ 个铅笔能否放进盒子中（$1$能，$0$不能），那么转移非常简单：只要存在一个 $dp[j]=1$，那么 $dp[i]=1$，其中 $j$ 满足 $1 \leqslant j \leqslant i - k$ 且 $a_i - a_{j+1} \leqslant d$（仔细想想为什么是 $a_{j+1}$）可是如果遍历 $j​$ 的话复杂度是 $O(N^2)​$ 的，显然需要优化——其实我们只需要知道 $j​$ 所在的那个区间内是否有 $1​$ 即可，或者说，和大于 $0​$ 即可。所以我们可以用前缀和轻松做到 $O(1)​$ 查询。 综上： dp状态：$dp[i]$ 表示前 $i$ 个铅笔能否放进盒子中（$1$能，$0$不能） dp方程：$dp[i] = (sum(pos-1, i - k) &gt; 0)$，其中 $pos$ 是最小的满足 $a[i] - a[pos] \leqslant d$ 的点 dp顺序：由dp方程可得：从小到大枚举 $i$ 即可 边界条件：这道题的边界条件有点迷……在实践过程中你会发现那些从 $1$ 开始的符合题意的区间会被判 $0$，所以边界条件可以是把它们置为 $1$。其他合法区间都可以从它们转移过去。 时间复杂度 $O(N)$ Code123456789101112131415161718192021222324252627282930#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 500005;int n, k, d, a[N], ptl, ptr, cnt, dpSum[N];bool dp[N]; // dp[i] represents whether we can put 1st~ith pencils into boxesinline int sum(int l, int r)&#123; if(l &gt; r) return 0; return dpSum[r] - dpSum[l-1];&#125;int main()&#123; scanf("%d%d%d", &amp;n, &amp;k, &amp;d); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); sort(a+1, a+n+1); for(int i = k; i &lt;= n; i++) if(a[i] - a[1] &lt;= d) dp[i] = 1; int pos = 1; for(int i = 1; i &lt;= n; i++)&#123; while(a[i] - a[pos] &gt; d) pos++; dp[i] |= sum(pos-1, i - k); dpSum[i] = dpSum[i-1] + dp[i]; &#125; return puts(dp[n] ? "YES" : "NO"), 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder ARC098]E - Range Minimum Queries]]></title>
    <url>%2F2018%2F05%2F27%2FAtCoder-ARC098-E-Range-Minimum-Queries%2F</url>
    <content type="text"><![CDATA[E - Range Minimum QueriesTime limit : 2sec / Memory limit : 1024MBScore : 600 points Problem StatementYou are given an integer sequence $A$ of length $N$ and an integer $K$. You will perform the following operation on this sequence $Q$ times: Choose a contiguous subsequence of length $K$, then remove the smallest element among the $K$ elements contained in the chosen subsequence (if there are multiple such elements, choose one of them as you like). Let $X$ and $Y$ be the values of the largest and smallest element removed in the $Q$ operations. You would like $X−Y$ to be as small as possible. Find the smallest possible value of $X−Y$ when the $Q$ operations are performed optimally. Constraints$1≤N≤2000$$1≤K≤N$$1≤Q≤N−K+1$$1≤A_i≤10^9$All values in input are integers. InputInput is given from Standard Input in the following format: $N$ $K$ $Q$$A_1$ $A_2$ … $A_N$ OutputPrint the smallest possible value of $X−Y$. Samples Input Output 5 3 24 3 1 5 2 1 10 1 61 1 2 3 5 8 13 21 34 55 7 11 7 524979445 861648772 623690081 433933447 476190629 262703497 211047202 971407775 628894325 731963982 822804784 451211184 In the first operation, whichever contiguous subsequence of length 3 we choose, the minimum element in it is $1$. Thus, the first operation removes $A_3=1$ and now we have $A=(4,3,5,2)$. In the second operation, it is optimal to choose $(A_2,A_3,A_4)=(3,5,2)$ as the contiguous subsequence of length $3$ and remove $A_4=2$. In this case, the largest element removed is $2$, and the smallest is $1$, so their difference is $2−1=1$. 解题思路如果从正面来想，最大值 $X$ 和最小值 $Y$ 都在变，所以不好解决。于是我们可以固定最小值 $Y$，每次找符合要求的最小的 $X$ 就行了。具体来说，从小到大枚举最小值 $Y$，对于每次枚举的 $Y$：我们可以找到一些区间，满足区间长度 $len$ 大于等于 $K$ 并且区间内的所有数都大于等于 $Y$，于是这个区间内的前 $len - K + 1$ 小都有可能被选进答案，记录下这些可能值后，排序就可以找到对于当前的 $Y$ 最小的 $X$ 是多少，用 $X-Y$ 更新 $ans$ 即可。 时间复杂度：枚举是 $O(N)$ 的，每次枚举中查找可能值+排序是 $O(N＋N\log N)$的，所以总复杂度是 $O(N^2\log N)$ Code1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 2005;int n, k, q, a[N], ans = 1e9+5, t[N], b[N], c[N];void cal(int mn)&#123; int l = 1, r = 1; b[0] = 0; while(l &lt;= n)&#123; c[0] = 0; while(a[l] &lt; mn &amp;&amp; l &lt;= n) l++; r = l; while(a[r] &gt;= mn &amp;&amp; r &lt;= n) r++; for(int i = l; i &lt; r &amp;&amp; i &lt;= n; i++) c[++c[0]] = a[i]; if(c[0] &gt;= k)&#123; sort(c+1, c+c[0]+1); for(int i = 1; i &lt;= c[0] - k + 1; i++) b[++b[0]] = c[i]; &#125; l = r; &#125; sort(b+1, b+b[0]+1); if(b[0] &gt;= q) ans = min(ans, b[q] - b[1]);&#125;int main()&#123; scanf("%d%d%d", &amp;n, &amp;k, &amp;q); for(int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;a[i]); t[i] = a[i]; &#125; sort(t+1, t+n+1); for(int i = 1; i &lt;= n; i++) cal(t[i]); printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder ARC097]E - Sorted and Sorted（dp，逆序对，前缀和优化）]]></title>
    <url>%2F2018%2F05%2F20%2FAtCoder-ARC097-E-Sorted-and-Sorted%EF%BC%88dp%EF%BC%8C%E9%80%86%E5%BA%8F%E5%AF%B9%EF%BC%8C%E5%89%8D%E7%BC%80%E5%92%8C%E4%BC%98%E5%8C%96%EF%BC%89%2F</url>
    <content type="text"><![CDATA[E - Sorted and SortedTime limit : 2sec / Memory limit : 1024MBScore : 600 points Problem StatementThere are $2N$ balls, $N$ white and $N$ black, arranged in a row. The integers from $1$ through $N$ are written on the white balls, one on each ball, and they are also written on the black balls, one on each ball. The integer written on the $i$-th ball from the left ($1 ≤ i ≤ 2N$) is $a_i$, and the color of this ball is represented by a letter $c_i$. $c_i = $ W represents the ball is white; $c_i = $B represents the ball is black.Takahashi the human wants to achieve the following objective: For every pair of integers $(i,j)$ such that $1 ≤ i &lt; j ≤ N$, the white ball with $i$ written on it is to the left of the white ball with $j$ written on it. For every pair of integers $(i,j)$ such that $1 ≤ i &lt; j ≤ N$, the black ball with $i$ written on it is to the left of the black ball with $j$ written on it. In order to achieve this, he can perform the following operation: Swap two adjacent balls. Find the minimum number of operations required to achieve the objective. Constraints$1 ≤ N ≤ 2000$$1 ≤ a_i ≤ N$$c_i = $ W or $c_i =$ B.If $i ≠ j$, $(a_i,c_i) ≠ (a_j,c_j)$. InputInput is given from Standard Input in the following format: $N$$c_1$ $a_1$$c_2$ $a_2$$:$$c_{2N}$ $a_{2N}$ OutputPrint the minimum number of operations required to achieve the objective. Samples Input Output 3B 1W 2B 3W 1W 3B 2 4 4B 4W 4B 3W 3B 2W 2B 1W 1 18 9W 3B 1B 4W 1B 5W 9W 2B 6W 5B 3W 8B 9W 7B 2B 8W 4W 6B 7 41 Sample 1:The objective can be achieved in four operations, for example, as follows:Swap the black 3 and white 1.Swap the white 1 and white 2.Swap the black 3 and white 3.Swap the black 3 and black 2. 解题思路先看一个最基本的问题： 已知 $1$ 到 $N$ 的一个排列，每次操作可以交换相邻两数，求至少多少次操作才能将这个数列变为 $1,2,3,\cdots,N$ 答案就是原数列的逆序对对数。证明如下：目标数列显然满足这样一个性质：对于 $\forall i \in [1,N)$，都有 $a_i &lt; a_{i+1}$。因此如果当前数列不是目标数列，一定 $\exists\ i \in [1,n)$ 使得 $a_i &gt; a_{i+1}$，那么 $a_i$ 和 $a_{i+1}$ 就构成了一对逆序对，我们需要一次操作交换这两个数。这样周而复始地进行交换操作，最终操作数量就是逆序对对数。 这个基本问题就可以衍生出许多问题，比如说 NOIP2013花匠 [题解]，又比如这道题。 这道题把一个 $1$ 到 $N$ 的排列变成了两个 $1$ 到 $N$ 的排列相混合，于是出现了一个问题：我们甚至都不知道最终数列的状态是怎样的。假设现在我们知道最终数列的状态，那么只需要像 NOIP2013花匠 一样扩展一下“逆序对” $(a_i,a_j)$ 的定义为：初始时 $a_i$ 在 $a_j$ 之后，目标状态下 $a_i$ 在 $a_j$ 之前的一对 $(a_i,a_j)$。这样，答案仍旧是逆序对对数。ok，现在我们只需要找到最优的目标状态了： dp状态：定义 $dp[i][j]$ 表示目标状态中，前 $i+j$ 个数由 $1$~$i$ 的黑球和 $1$~$j$ 的白球混合排列而成（对于任意一种颜色的球，排列是升序的）时，最少的逆序对对数 dp方程：$dp[i][j] = min(dp[i-1][j] + b_{i,j},dp[i][j-1] + w_{i, j})$，其中 $b_{i,j}$ 表示 $1$~$i$ 的白球和 $1$~$j$ 的黑球中，初始时在黑球 $i$ 之后的球的数量；$w_{i,j}$ 同理具体计算 $b_{i,j}$ 和 $w_{i,j}$ 可以在 dp 之前先 $O(N^2)$ 预处理出所有位置关系，再通过二维前缀和优化使得能够在 dp 时 $O(1)$ 得值 dp顺序：由dp方程易知：顺序 for i 再 for j 即可 边界条件：由dp定义和dp顺序可知：dp[0][0] = 0 答案即是 $dp[N][N]$ 时间复杂度：$O(N^2)$ Code12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int INF = 0x7fffffff;const int N = 2005;int n, a[N&lt;&lt;1], t, dp[N][N], g[N&lt;&lt;1][N&lt;&lt;1];char c;int cal(int x, int b, int w)&#123; return g[x][b] - g[x-1][b] + g[x][w] - g[x][n] - g[x-1][w] + g[x-1][n];&#125;int main()&#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n &lt;&lt; 1; i++)&#123; scanf("%s%d", &amp;c, &amp;a[i]); if(c == 'W') a[i] += n; for(int j = 1; j &lt; i; j++) g[a[j]][a[i]] = 1; &#125; for(int i = 1; i &lt;= n &lt;&lt; 1; i++) for(int j = 1; j &lt;= n &lt;&lt; 1; j++) g[i][j] += g[i-1][j] + g[i][j-1] - g[i-1][j-1]; memset(dp, 0x7f, sizeof dp); dp[0][0] = 0; for(int i = 0; i &lt;= n; i++)&#123; for(int j = 0; j &lt;= n; j++)&#123; if(!i &amp;&amp; !j) continue; dp[i][j] = min(i ? dp[i-1][j] + cal(i, i, j+n) : INF, j ? dp[i][j-1] + cal(j+n, i, j+n) : INF); &#125; &#125; printf("%d\n", dp[n][n]); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2013 D2 T2]花匠（贪心）]]></title>
    <url>%2F2018%2F05%2F07%2FNOIP2013-D2-T2-%E8%8A%B1%E5%8C%A0%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述花匠栋栋种了一排花，每株花都有自己的高度。花儿越长越大，也越来越挤。栋栋决定把这排中的一部分花移走，将剩下的留在原地，使得剩下的花能有空间长大，同时，栋栋希望剩下的花排列得比较别致。具体而言，栋栋的花的高度可以看成一列整数h1,h2..hn。设当一部分花被移走后，剩下的花的高度依次为g1,g2..gm，则栋栋希望下面两个条件中至少有一个满足：条件 A：对于所有g(2i)&gt;g(2i-1),g(2i)&gt;g(2i+1)条件 B：对于所有g(2i)]]></content>
      <categories>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder ABC096]D - Five, Five Everywhere（构造）]]></title>
    <url>%2F2018%2F05%2F05%2FAtCoder-ABC096-D-Five-Five-Everywhere%EF%BC%88%E6%9E%84%E9%80%A0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[D - Five, Five EverywhereTime limit : 2sec / Memory limit : 256MBScore: 400 points Problem StatementPrint a sequence $a_1,a_2,…,a_N$ whose length is $N$ that satisfies the following conditions: $a_i$ ($1≤i≤N$) is a prime number at most $55 555$. The values of $a_1,a_2,…,a_N$ are all different. In every choice of five different integers from $a_1,a_2,…,a_N$, the sum of those integers is a composite number.If there are multiple such sequences, printing any of them is accepted. NotesAn integer $N$ not less than $2$ is called a prime number if it cannot be divided evenly by any integers except $1$ and $N$, and called a composite number otherwise. Constraints $N$ is an integer between $5$ and $55$ (inclusive). InputInput is given from Standard Input in the following format: N OutputPrint $N$ numbers $a_1,a_2,a_3,…,a_N$ in a line, with spaces in between. Sample Input 115 Sample Output 113 5 7 11 31 Let us see if this output actually satisfies the conditions.First, 3, 5, 7, 11 and 31 are all different, and all of them are prime numbers.The only way to choose five among them is to choose all of them, whose sum is $a_1+a_2+a_3+a_4+a_5=57$, which is a composite number.There are also other possible outputs, such as 2 3 5 7 13, 11 13 17 19 31 and 7 11 5 31 3. Sample Input 216 Sample Output 212 3 5 7 11 13 $2, 3, 5, 7, 11, 13$ are all different prime numbers.$2+3+5+7+11=28$ is a composite number.$2+3+5+7+13=30$ is a composite number.$2+3+5+11+13=34$ is a composite number.$2+3+7+11+13=36$ is a composite number.$2+5+7+11+13=38$ is a composite number.$3+5+7+11+13=39$ is a composite number.Thus, the sequence 2 3 5 7 11 13 satisfies the conditions. Sample Input 318 Sample Output 312 5 7 13 19 37 67 79 解题思路比赛时居然没想出来，被可恶的样例解释带偏了…要求给出一个全是质数的数列，使得任取五个数的和都是合数既然这样，我们不妨让所有数的个位都是1，很容易证明在 $[5,55555]$ 中可以找出至少 $55$ 个这样的个位是1的质数那么，任意5个数的和的个位就一定是5了——那就一定是合数了oops… Code1234567891011121314151617181920212223#include&lt;cstdio&gt;using namespace std;int n;bool isPrime(int x)&#123; for(int i = 2; i * i &lt;= x; i++) if(x % i == 0) return false; return true;&#125;int main()&#123; scanf("%d", &amp;n); for(int i = 11; n; i += 10)&#123; if(isPrime(i))&#123; printf("%d ", i); n--; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces 940.E]Cashback（动态规划，单调队列，贪心）]]></title>
    <url>%2F2018%2F04%2F30%2FCodeforces-940-E-Cashback%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E8%B4%AA%E5%BF%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目E. Cashbacktime limit per test: 2 secondsmemory limit per test: 256 megabytesinput: standard inputoutput: standard output Since you are the best Wraith King, Nizhniy Magazin at the centre of Vinnytsia is offering you a discount.You are given an array $a$ of length $n$ and an integer $c$.The value of some array $b$ of length $k$ is the sum of its elements except for the $\lfloor \frac{k}{c} \rfloor$ smallest. For example, the value of the array $[3,1,6,5,2]$ with $c=2$ is $3+6+5=14$.Among all possible partitions of a into contiguous subarrays output the smallest possible sum of the values of these subarrays. InputThe first line contains integers n and c ($1≤n,c≤100000$).The second line contains n integers ai ($1≤a_i≤10^9$) — elements of a. OutputOutput a single integer — the smallest possible sum of values of these subarrays of some partition of $a$. Examples input output 3 51 2 3 6 12 101 1 10 10 10 10 10 10 9 10 10 10 92 7 22 3 6 4 5 7 1 17 8 41 3 4 5 5 3 4 1 23 NoteIn the first example any partition yields 6 as the sum.In the second example one of the optimal partitions is $[1,1],[10,10,10,10,10,10,9,10,10,10]$ with the values 2 and 90 respectively.In the third example one of the optimal partitions is $[2,3],[6,4,5,7],[1]$ with the values 3, 13 and 1 respectively.In the fourth example one of the optimal partitions is $[1],[3,4,5,5,3,4],[1]$ with the values 1, 21 and 1 respectively. 解题思路这当然是一道dp题。我们先设$dp[i]$表示前$i$个数字划分后的最小代价，那么转移就是$dp[i]=min\{dp[k]+cal(k+1, i)\ |\ 1 \leqslant k &lt; i\}$，其中$cal(l, r)$是计算$l$到$r$作为整体时的代价。复杂度？$cal(l,r)$可以用multiset之类的做到$O(\log n)$完成，但是dp方程里面有两层循环，所以复杂度高达$O(n^2\log n)$，差远了。 怎么优化呢？这里我们可以发现一个贪心：划分的每一块长度要么是1，要么是c。证明：如果块的长度小于c，那么代价是所有值的和，与把这些值划分成一份一份的等价；如果块的长度大于c，我们把它们划分成几个长为c或1的块，答案一定不会更差（去除数量相同，但区间更小，更有机会去除掉大一点的数，手动模拟一下就知道了）。综上所述，我们的dp长这样： dp状态：$dp[i]$表示前$i$个数字划分后的最小代价 dp方程：$dp[i] = min\big(dp[i-1] + a[i], dp[i-c] + sum(i-c+1, i) - min(i-c+1, i)\big)$由于长为c的段只会去除最小的值，所以上文中的$cal()$变成了此处的$min()$sum(l,r)表示$l$到$r$的和，可以前缀和优化到$O(1)$min(l,r)表示$l$到$r$的最小值，由于$l$~$r$长度固定为c，所以可以单调队列$O(n)$的预处理出来 dp顺序：由dp方程可知，$i$从小到大for即可 边界条件：$dp[0] = 0$ 时间复杂度 $O(n)$ Code12345678910111213141516171819202122232425262728293031#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;typedef long long LL;const int N = 100005;int n, c, hd, tl;LL a[N], sum[N], mnC[N], dp[N];pair&lt;LL, int&gt; q[N];int main()&#123; scanf("%d%d", &amp;n, &amp;c); for(int i = 1; i &lt;= n; i++)&#123; scanf("%lld", &amp;a[i]); sum[i] = sum[i-1] + a[i]; while(hd &lt; tl &amp;&amp; q[tl-1].first &gt; a[i]) tl--; q[tl++] = make_pair(a[i], i); while(hd &lt; tl &amp;&amp; q[hd].second &lt;= max(i - c, 0)) hd++; mnC[i] = q[hd].first; &#125; memset(dp, 0x7f, sizeof dp); dp[0] = 0; for(int i = 1; i &lt;= n; i++)&#123; dp[i] = dp[i-1] + a[i]; if(i - c &gt;= 0) dp[i] = min(dp[i], dp[i-c] + sum[i] - sum[i-c] - mnC[i]); &#125; printf("%lld", dp[n]); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>数据结构</category>
        <category>贪心</category>
        <category>队列</category>
        <category>单调队列</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2017 D2 T3]列队（线段树/平衡树）]]></title>
    <url>%2F2018%2F04%2F30%2FNOIP2017-D2-T3-%E5%88%97%E9%98%9F%EF%BC%88%E7%BA%BF%E6%AE%B5%E6%A0%91-%E5%B9%B3%E8%A1%A1%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述Sylvia 是一个热爱学习的女♂孩子。前段时间，Sylvia 参加了学校的军训。众所周知，军训的时候需要站方阵。Sylvia 所在的方阵中有$n \times m$名学生，方阵的行数为 $n$，列数为 $m$。为了便于管理，教官在训练开始时，按照从前到后，从左到右的顺序给方阵中 的学生从 1 到 $n \times m$ 编上了号码（参见后面的样例）。即：初始时，第 $i$ 行第 $j$ 列 的学生的编号是$(i-1)\times m + j$。然而在练习方阵的时候，经常会有学生因为各种各样的事情需要离队。在一天 中，一共发生了 $q$件这样的离队事件。每一次离队事件可以用数对$(x,y) (1 \le x \le n, 1 \le y \le m)$描述，表示第 $x$ 行第 $y$ 列的学生离队。在有学生离队后，队伍中出现了一个空位。为了队伍的整齐，教官会依次下达 这样的两条指令： 向左看齐。这时第一列保持不动，所有学生向左填补空缺。不难发现在这条 指令之后，空位在第 $x$ 行第 $m$ 列。 向前看齐。这时第一行保持不动，所有学生向前填补空缺。不难发现在这条 指令之后，空位在第 $n$ 行第 $m$ 列。 教官规定不能有两个或更多学生同时离队。即在前一个离队的学生归队之后， 下一个学生才能离队。因此在每一个离队的学生要归队时，队伍中有且仅有第 $n$ 行 第 $m$ 列一个空位，这时这个学生会自然地填补到这个位置。因为站方阵真的很无聊，所以 Sylvia 想要计算每一次离队事件中，离队的同学 的编号是多少。注意：每一个同学的编号不会随着离队事件的发生而改变，在发生离队事件后 方阵中同学的编号可能是乱序的。 输入输入共 $q+1$行。第 1 行包含 3 个用空格分隔的正整数 $n, m, q$，表示方阵大小是 $n$ 行 $m$ 列，一共发 生了 $q$ 次事件。接下来 $q$ 行按照事件发生顺序描述了 $q$ 件事件。每一行是两个整数 $x, y$，用一个空 格分隔，表示这个离队事件中离队的学生当时排在第 $x$ 行第 $y$ 列。 输出按照事件输入的顺序，每一个事件输出一行一个整数，表示这个离队事件中离队学 生的编号。 输入样例12342 2 31 12 21 2 输出样例123114 数据规模与约定$n,m,q \leq 3 \times 10^5$数据保证每一个事件满足 $1 \le x \le n,1 \le y \le m$ 解题思路一道数据结构的好题。首先我们发现，每次操作只会更改某一行和最后一列的状态，那么我们可以单独把最后一列拿出来用一个数据结构维护，再用$n$个数据结构维护每一行的前$m-1$个元素。那用什么数据结构好呢？ 一、线段树线段树是最容易想到的，共开$n+1$颗线段树，前$n$颗维护每行前$m-1$个元素，第$n+1$颗维护最后一列的元素。每次对$(x,y)$操作都可以转化为一个基本操作：从一颗线段树里面拿出一个元素加到一颗线段树的末尾，具体来说： 如果$y = m$，只需要从“列线段树”里拿出第$x$个元素加到它本身末尾 否则，从第$x$颗“行线段树”里拿出第$y$个元素加到“列线段树”末尾，再从“列线段树”里拿出第$x$个元素加到“行线段树”末尾 所谓的“拿出”操作就是一个在线段树上二分查找的过程，为此我们要在线段树每个节点上记录一个size，表示当前节点表示的区间里面还剩多少个元素。另外，每颗线段树要多开$q$的区间长度（想想操作过程就明白了）。 但是，以上并不是这道题的难点，这道题的特殊之处在于你无法直接开满$n+1$颗线段树！怎么办呢，我们可以动态开点来解决，也就是说当你要用某个点时再开它（想想主席树）。这样我们只需要$NlogN$的空间就够了。 时间复杂度 $O(q\log (n+q))$ 二、平衡树既然线段树可以，平衡树当然也可以了！同样的思路：每次操作都可以转化为从一颗平衡树上二分查找第k大的值，把它加到一颗平衡树的末尾。 怎么解决空间问题？由于有一些人至始至终都站在一起，我们可以在平衡树上只用一个节点表示这个区间$[l,r]$（编号从$l$到$r$的人），当我们发现这个区间中的某个人（如编号为$k$的人）要离队时，再把它split成两个小区间（$[l,k-1],[k+1,r]$），输出$k$，这样就能保证空间复杂度为 $NlogN$。 时间复杂度$O(q\log n)$ 三、树状数组有待学习… Code#1（线段树）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 300005;int n, m, q, qx, qy, p[N], root[N];LL t;struct segTree&#123; int son[2]; LL val, size;&#125;tr[N*30];struct OPT_segTree&#123; int cnt; inline int newNode(int l, int r, int kind)&#123; cnt++; int temp = (kind == 0 ? m - 1 : n); if(l &lt;= temp &amp;&amp; r &lt;= temp) tr[cnt].size = r - l + 1; else if(l &lt;= temp &amp;&amp; r &gt; temp) tr[cnt].size = temp - l + 1; else if(l &gt; temp &amp;&amp; r &gt; temp) tr[cnt].size = 0; return cnt; &#125; inline void pushup(int id)&#123; tr[id].size = tr[tr[id].son[0]].size + tr[tr[id].son[1]].size; &#125; LL getKth(int id, int l, int r, LL k, int kind)&#123; if(l == r)&#123; if(!tr[id].val)&#123; if(kind == 0) tr[id].val = 1ll * (qx - 1) * m + l; else tr[id].val = 1ll * l * m; &#125; tr[id].size = 0; return tr[id].val; &#125; int mid = (l + r) &gt;&gt; 1; if(!tr[id].son[0]) tr[id].son[0] = newNode(l, mid, kind); if(!tr[id].son[1]) tr[id].son[1] = newNode(mid+1, r, kind); LL res = 0; if(tr[tr[id].son[0]].size &gt;= k) res = getKth(tr[id].son[0], l, mid, k, kind); else res = getKth(tr[id].son[1], mid+1, r, k - tr[tr[id].son[0]].size, kind); pushup(id); return res; &#125; void insert(int id, int l, int r, int pos, LL val, int kind)&#123; if(l == r)&#123; tr[id].val = val; tr[id].size = 1; return; &#125; int mid = (l + r) &gt;&gt; 1; if(!tr[id].son[0]) tr[id].son[0] = newNode(l, mid, kind); if(!tr[id].son[1]) tr[id].son[1] = newNode(mid+1, r, kind); if(pos &lt;= mid) insert(tr[id].son[0], l, mid, pos, val, kind); else insert(tr[id].son[1], mid+1, r, pos, val, kind); pushup(id); &#125;&#125;Seg;int main()&#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;q); for(int i = 1; i &lt;= n; i++) p[i] = m - 1; p[n+1] = n; for(int i = 1; i &lt;= n; i++) root[i] = Seg.newNode(1, m - 1 + q, 0); root[n+1] = Seg.newNode(1, n + q, 1); for(int i = 1; i &lt;= q; i++)&#123; scanf("%d%d", &amp;qx, &amp;qy); if(qy == m)&#123; printf("%lld\n", t = Seg.getKth(root[n+1], 1, n + q, qx, 1)); Seg.insert(root[n+1], 1, n + q, ++p[n+1], t, 1); &#125; else&#123; printf("%lld\n", t = Seg.getKth(root[qx], 1, m - 1 + q, qy, 0)); Seg.insert(root[n+1], 1, n + q, ++p[n+1], t, 1); t = Seg.getKth(root[n+1], 1, n + q, qx, 1); Seg.insert(root[qx], 1, m - 1 + q, ++p[qx], t, 0); &#125; &#125; return 0;&#125; Code#2（Splay）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;cstdio&gt;using namespace std;typedef long long LL;const int N = 300005;int qx, qy, rt[N];LL t, n, m, q;struct Splay&#123; int son[2], fa; LL val, l, r, size;&#125;tr[N*30];struct OPT_Splay&#123; int cnt; inline void pushup(int id)&#123; tr[id].size = tr[id].r - tr[id].l + 1; if(tr[id].son[0]) tr[id].size += tr[tr[id].son[0]].size; if(tr[id].son[1]) tr[id].size += tr[tr[id].son[1]].size; &#125; inline int newNode(LL l, LL r)&#123; cnt++; tr[cnt].fa = tr[cnt].son[0] = tr[cnt].son[1] = 0; tr[cnt].size = (tr[cnt].r = r) - (tr[cnt].l = l) + 1; return cnt; &#125; inline void rotate(int x, int kind)&#123; int y = tr[x].fa, z = tr[y].fa, A = tr[y].son[kind], B = tr[x].son[kind], C = tr[x].son[!kind]; tr[x].son[kind] = y, tr[x].fa = z; tr[y].fa = x, tr[y].son[!kind] = B; tr[z].son[tr[z].son[1] == y] = x, tr[B].fa = y; pushup(y), pushup(x); &#125; inline void splay(int &amp;root, int x, int goal)&#123; if(x == goal) return; while(tr[x].fa != goal)&#123; int y = tr[x].fa, z = tr[y].fa; int isrson1 = tr[y].son[1] == x, isrson2 = tr[z].son[1] == y; if(z == goal) rotate(x, !isrson1); else&#123; if(isrson1 == isrson2) rotate(y, !isrson2); else rotate(x, !isrson1); rotate(x, !isrson2); &#125; &#125; if(goal == 0) root = x; &#125; inline int selectLast(int &amp;root)&#123; int now = root; while(tr[now].son[1]) now = tr[now].son[1]; return now; &#125; inline void insert(int &amp;root, LL val)&#123; int temp = newNode(val, val); int pos = selectLast(root); tr[pos].son[1] = temp; tr[temp].fa = pos; splay(root, temp, 0); &#125; LL split(int &amp;root, int now, LL k)&#123; splay(root, now, 0); k += tr[now].l - 1; int temp = newNode(k+1, tr[now].r); tr[now].r = k - 1; if(!tr[now].son[1])&#123; tr[now].son[1] = temp; tr[temp].fa = now; &#125; else&#123; tr[temp].son[1] = tr[now].son[1]; tr[tr[temp].son[1]].fa = temp; tr[now].son[1] = temp; tr[temp].fa = now; &#125; pushup(temp), pushup(now); return k; &#125; inline LL getKth(int &amp;root, LL k)&#123; int now = root; while(1)&#123; if(k &lt;= tr[tr[now].son[0]].size) now = tr[now].son[0]; else&#123; k -= tr[tr[now].son[0]].size; if(k &lt;= tr[now].r - tr[now].l + 1) return split(root, now, k); else&#123; k -= (tr[now].r - tr[now].l + 1); now = tr[now].son[1]; &#125; &#125; &#125; &#125;&#125;BST;int main()&#123; scanf("%lld%lld%lld", &amp;n, &amp;m, &amp;q); for(int i = 1; i &lt;= n; i++) rt[i] = BST.newNode((i - 1) * m + 1, i * m - 1); rt[n+1] = BST.newNode(m, m); for(int i = 2; i &lt;= n; i++) BST.insert(rt[n+1], i * m); while(q--)&#123; scanf("%d%d", &amp;qx, &amp;qy); if(qy == m)&#123; printf("%lld\n", t = BST.getKth(rt[n+1], qx)); BST.insert(rt[n+1], t); &#125; else&#123; printf("%lld\n", t = BST.getKth(rt[qx], qy)); BST.insert(rt[n+1], t); BST.insert(rt[qx], BST.getKth(rt[n+1], qx)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
        <category>平衡树</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2017 D2 T2]宝藏（状压dp）]]></title>
    <url>%2F2018%2F04%2F30%2FNOIP2017-D2-T2-%E5%AE%9D%E8%97%8F%EF%BC%88%E7%8A%B6%E5%8E%8Bdp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述参与考古挖掘的小明得到了一份藏宝图，藏宝图上标出了 $n$ 个深埋在地下的宝藏屋， 也给出了这 $n$ 个宝藏屋之间可供开发的 $m$ 条道路和它们的长度。 小明决心亲自前往挖掘所有宝藏屋中的宝藏。但是，每个宝藏屋距离地面都很远， 也就是说，从地面打通一条到某个宝藏屋的道路是很困难的，而开发宝藏屋之间的道路 则相对容易很多。 小明的决心感动了考古挖掘的赞助商，赞助商决定免费赞助他打通一条从地面到某 个宝藏屋的通道，通往哪个宝藏屋则由小明来决定。 在此基础上，小明还需要考虑如何开凿宝藏屋之间的道路。已经开凿出的道路可以 任意通行不消耗代价。每开凿出一条新道路，小明就会与考古队一起挖掘出由该条道路 所能到达的宝藏屋的宝藏。另外，小明不想开发无用道路，即两个已经被挖掘过的宝藏 屋之间的道路无需再开发。新开发一条道路的代价是： L \times K$L$代表这条道路的长度，$K$代表从赞助商帮你打通的宝藏屋到这条道路起点的宝藏屋所经过的 宝藏屋的数量（包括赞助商帮你打通的宝藏屋和这条道路起点的宝藏屋） 。 请你编写程序为小明选定由赞助商打通的宝藏屋和之后开凿的道路，使得工程总代价最小，并输出这个最小值。 输入第一行两个用空格分离的正整数 $n$ 和 $m$，代表宝藏屋的个数和道路数。 接下来 $m$ 行，每行三个用空格分离的正整数，分别是由一条道路连接的两个宝藏 屋的编号（编号为 $1$~$n$），和这条道路的长度 $v$。 输出输出共一行，一个正整数，表示最小的总代价。 样例输入样例输入11234564 5 1 2 1 1 3 3 1 4 1 2 3 4 3 4 1 样例输入21234564 5 1 2 1 1 3 3 1 4 1 2 3 4 3 4 2 样例输出样例输出114 样例输出215 数据规模与约定对于 20% 的数据： 保证输入是一棵树，$1 \le n \le 8$ , $v \le 5000$ 且所有的 v 都相等。对于 40% 的数据： $1 \le n \le 8$，$0 \le m \le 1000$ , $v \le 5000$ 且所有的 v 都相等。对于 70% 的数据： $1 \le n \le 8$，$0 \le m \le 1000$，$v \le 5000$对于 100% 的数据： $1 \le n \le 12$，$0 \le m \le 1000$ , $v \le 500000$ 解题思路首先，很容易发现打通后的道路一定是一棵树，并且，若以起点为根并令其深度为$0$，则题目中的 $K$ 即为这条路所连向的点的深度。 观察数据范围，$n \le 12$，显然是状压dp： dp状态：$dp[i][S]$ 表示考虑到树的第$i$层，前$i$层已选的点的集合为$S$（二进制状压）的最小代价。 dp方程（刷表法）： 已知$dp[i][S]$时，可枚举所有由不在$S$中的点构成的集合作为第$i+1$层，则状态转移为dp[i][S] \to dp[i+1][S|S'] + (i+1) \times \Sigma \ min\{G[a][b]|a \in S , b \in S',S \cap S' = \emptyset \} 简单一点，就是dp[i][S] \to dp[i+1][S|S'] + (i+1) \times sval[S'][S] \} 其中$sval[A][B]$表示集合A到集合B的最短距离，即集合A中所有点到集合B的最短距离之和。可以先预处理出每个点到每个集合的最短距离$pval[i][S]$（也就是点$i$到集合$S$中所有点的距离的最小值），然后用$pval[i][B]$更新$sval[A][B]$。 dp顺序：由dp方程可得：从小到大枚举层数，再枚举集合即可 边界条件：枚举根节点，设为$root$，则$dp[0][1&lt;&lt;(root-1)] = 0$ 状压相关技巧 若$S$是$U$的子集，则$S$关于$U$的补集：$S ^\wedge U$ 判断点$k$是否在集合$S$中（即$S$的第$k-1$位是否为$1$）：S &amp; (1 &lt;&lt; (k-1)) ！= 0 ? &quot;Yes&quot; : &quot;No&quot;; 枚举$S$的子集：for(int i = S; i; i = (i - 1) &amp; S){...} Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int INF = 1e7;const int N = 13;int n, m, g[N][N], u, v, p, U;LL dp[N][1&lt;&lt;N], ans = 1e14, sval[1&lt;&lt;N][1&lt;&lt;N], pval[N][1&lt;&lt;N];void init(int root)&#123; for(int i = 0; i &lt;= n; i++) for(int j = 0; j &lt;= U; j++) dp[i][j] = INF; dp[0][1&lt;&lt;(root-1)] = 0;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); U = (1 &lt;&lt; n) - 1; for(int i = 1; i &lt;= n; i++) //initialize g[i][j] for(int j = 1; j &lt;= n; j++) if(i ^ j) g[i][j] = INF; for(int i = 1; i &lt;= n; i++) for(int j = 0; j &lt;= U; j++) pval[i][j] = INF; for(int i = 0; i &lt;= U; i++) for(int j = 0; j &lt;= U; j++) sval[i][j] = INF; while(m--)&#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;p); g[u][v] = min(g[u][v], p); g[v][u] = min(g[v][u], p); &#125; for(int i = 1; i &lt;= n; i++) //initialize pval[i][S] for(int j = 0; j &lt;= U; j++) for(int k = 1; k &lt;= n; k++) if(j &amp; (1 &lt;&lt; (k - 1))) pval[i][j] = min(pval[i][j], 1ll*g[i][k]); for(int i = 0; i &lt;= U; i++)&#123; //initialize sval[A][B] int C = i ^ U; for(int s = C; s; s = (s - 1) &amp; C)&#123; LL temp = 0; for(int j = 1; j &lt;= n; j++) if(s &amp; (1 &lt;&lt; (j - 1))) temp += pval[j][i]; sval[s][i] = temp &gt;= INF ? INF : temp; &#125; &#125; for(int root = 1; root &lt;= n; root++)&#123; //dp init(root); for(int i = 0; i &lt; n; i++) for(int S = 0; S &lt;= U; S++) if(dp[i][S] != INF)&#123; int C = S ^ U; for(int s = C; s; s = (s - 1) &amp; C) dp[i+1][S|s] = min(dp[i+1][S|s], dp[i][S] + (i + 1) * sval[s][S]); &#125; for(int i = 0; i &lt; n; i++) ans = min(ans, dp[i][U]); &#125; printf("%lld", ans); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>状压dp</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2017 D2 T1]奶酪（并查集）]]></title>
    <url>%2F2018%2F04%2F30%2FNOIP2017-D2-T1-%E5%A5%B6%E9%85%AA%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述现有一块大奶酪，它的高度为 $h$，它的长度和宽度我们可以认为是无限大的，奶酪中间有许多半径相同的球形空洞。我们可以在这块奶酪中建立空间坐标系，在坐标系中，奶酪的下表面为$z=0$，奶酪的上表面为$z = h$。现在，奶酪的下表面有一只小老鼠 Jerry，它知道奶酪中所有空洞的球心所在的坐 标。如果两个空洞相切或是相交，则 Jerry 可以从其中一个空洞跑到另一个空洞，特别地，如果一个空洞与下表面相切或是相交，Jerry 则可以从奶酪下表面跑进空洞；如果一个空洞与上表面相切或是相交，Jerry 则可以从空洞跑到奶酪上表面。位于奶酪下表面的 Jerry 想知道，在不破坏奶酪的情况下，能否利用已有的空洞跑到奶酪的上表面去?空间内两点$P_1(x_1,y_1,z_1)$、$P2(x_2,y_2,z_2)$的距离公式如下： \mathrm{dist}(P_1,P_2)=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}输入每个输入文件包含多组数据。输入文件的第一行，包含一个正整数 $T$，代表该输入文件中所含的数据组数。接下来是 $T$ 组数据，每组数据的格式如下： 第一行包含三个正整数 $n,h$ 和 $r$，两个数之间以一个空格分开，分别代表奶酪中空洞的数量，奶酪的高度和空洞的半径。接下来的 $n$ 行，每行包含三个整数 $x,y,z$，两个数之间以一个空格分开，表示空洞球心坐标为$(x,y,z)$。 输出输出文件包含 $T$ 行，分别对应 $T$ 组数据的答案，如果在第 $i$ 组数据中，Jerry 能从下表面跑到上表面，则输出 “Yes”，如果不能，则输出 “No” （均不包含引号）。 样例输入123456789103 2 4 1 0 0 1 0 0 3 2 5 1 0 0 1 0 0 4 2 5 2 0 0 2 2 0 4 样例输出123YesNoYes 数据规模与约定对于 20%的数据，$n = 1$，$1 \le h,r \le 10,000$，坐标的绝对值不超过 10,000。 对于 40%的数据，$1 \le n \le 8$， $1 \le h,r \le 10,000$，坐标的绝对值不超过 10,000。 对于80%的数据， $1 \le n \le 1,000$， $1 \le h , r \le 10,000$，坐标的绝对值不超过10,000。 对于 100%的数据，$1 \le n \le 1,000$，$1 \le h , r \le 1,000,000,000$，$T \le 20$，坐标的绝对值不超过 1,000,000,000。 解题思路设下底面为点$S=n+1$，上底面为点$T=n+2$，枚举两个点看它们是否连通，连通即将它们用并查集并起来，最后看$S$与$T$是否连通即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;typedef long long LL;typedef long double LB;const int N = 1005;int CASES, n, h, S, T;LL r;struct Node&#123; int x, y, z;&#125;node[N];inline LB dist(int a, int b)&#123; return sqrt((LB)(node[a].x-node[b].x)*(node[a].x-node[b].x)+(LB)(node[a].y-node[b].y)*(node[a].y-node[b].y)+(LB)(node[a].z-node[b].z)*(node[a].z-node[b].z));&#125;int fa[N];void init()&#123; for(int i = 1; i &lt;= n+2; i++) fa[i] = i;&#125;int findfa(int x)&#123; if(fa[x] != x) fa[x] = findfa(fa[x]); return fa[x];&#125;void unionn(int x, int y)&#123; fa[findfa(y)] = findfa(x);&#125;int main()&#123; scanf("%d", &amp;CASES); while(CASES--)&#123; scanf("%d%d%lld", &amp;n, &amp;h, &amp;r); init(); S = n + 1, T = n + 2; for(int i = 1; i &lt;= n; i++)&#123; scanf("%d%d%d", &amp;node[i].x, &amp;node[i].y, &amp;node[i].z); for(int j = 1; j &lt; i; j++)&#123; if(dist(i, j) &lt;= 2 * r &amp;&amp; findfa(i) != findfa(j)) unionn(i, j); &#125; if(node[i].z + r &gt;= h) unionn(i, T); if(node[i].z - r &lt;= 0) unionn(i, S); &#125; if(findfa(T) == findfa(S)) puts("Yes"); else puts("No"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普通平衡树/文艺平衡树/二逼平衡树]]></title>
    <url>%2F2018%2F04%2F30%2F%E6%99%AE%E9%80%9A%E5%B9%B3%E8%A1%A1%E6%A0%91-%E6%96%87%E8%89%BA%E5%B9%B3%E8%A1%A1%E6%A0%91-%E4%BA%8C%E9%80%BC%E5%B9%B3%E8%A1%A1%E6%A0%91%2F</url>
    <content type="text"><![CDATA[普通平衡树题目链接：luogu3369bzoj3224 解题思路平衡树模板题，我分别用了 [非旋Treap] 和 [Splay] AC了本题。 一、Splay每个节点表示一个值，同时记录该点及其子树大小、该点表示的值的出现次数、左右儿子、父节点。 插入：将x前驱旋至根，x后继旋至根的右儿子，那么根的左儿子的右儿子即为要插入的位置，如果此位置上无数，则新建一个节点；否则该位置的出现次数和大小加1。 注意：为了避免找不到x前驱和后继，应事先插入一个值为-INF和值为INF的节点。 删除：将x前驱旋至根，x后继旋至根的右儿子，那么根的左儿子的右儿子即为要删除的节点，如果此节点大小为1，直接删除；否则该位置的出现次数和大小减1。 查x排名：将x旋至根，则x排名为根的左儿子大小+1 查排名为x的数：从根向下查找，如果当前节点的左儿子大小+1=x，则返回当前节点的值；否则，如果当前节点的左儿子大小$\geq$x，则向其右儿子查找；否则，向其左儿子查找。 求x前驱：从根向下查找，如果当前节点的值小于等于x，更新ans并向其右儿子查找；否则，向其左儿子查找。更新时，不断取max即可。 求x后继：从根向下查找，如果当前节点的值大于等于x，更新ans并向其左儿子查找；否则，向其右儿子查找。更新时，不断取min即可。 时间复杂度：每次操作 $O(log_2n)$ Code#1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int INF = 0x7fffffff;const int N = 100005;int n, opt, q;int cnt = 0, root = 0;struct Splay_tree&#123; int fa, son[2], size, val, times;&#125;tr[N];inline void pushup(int x)&#123; if(x)&#123; tr[x].size = tr[x].times; if(tr[x].son[0]) tr[x].size += tr[tr[x].son[0]].size; if(tr[x].son[1]) tr[x].size += tr[tr[x].son[1]].size; &#125;&#125;inline void rotate(int x, int kind)&#123; int y = tr[x].fa, z = tr[y].fa, A = tr[y].son[kind], B = tr[x].son[kind], C = tr[x].son[!kind]; tr[x].son[kind] = y, tr[x].fa = z; tr[y].son[!kind] = B, tr[y].fa = x, tr[B].fa = y; tr[z].son[tr[z].son[1] == y] = x; pushup(y), pushup(x);&#125;inline void splay(int x, int goal)&#123; if(x == goal) return; while(tr[x].fa != goal)&#123; int y = tr[x].fa, z = tr[y].fa; int isrson1 = tr[y].son[1] == x, isrson2 = tr[z].son[1] == y; if(z == goal) rotate(x, !isrson1); else&#123; if(isrson1 == isrson2) rotate(y, !isrson2); else rotate(x, !isrson1); rotate(x, !isrson2); &#125; &#125; if(goal == 0) root = x;&#125;inline int select(int x)&#123; int now = root; while(now)&#123; if(tr[now].val == x) break; else if(tr[now].val &lt; x) now = tr[now].son[1]; else if(tr[now].val &gt; x) now = tr[now].son[0]; &#125; if(!now) return -1; return now;&#125;inline int getPre(int x)&#123; int now = root, ans = -INF; while(now)&#123; if(tr[now].val &lt; x)&#123; ans = max(ans, tr[now].val); now = tr[now].son[1]; &#125; else now = tr[now].son[0]; &#125; return ans;&#125;inline int getSub(int x)&#123; int now = root, ans = INF; while(now)&#123; if(tr[now].val &gt; x)&#123; ans = min(ans, tr[now].val); now = tr[now].son[0]; &#125; else now = tr[now].son[1]; &#125; return ans;&#125;inline int getRank(int x)&#123; int now = root, ans = 0; while(now)&#123; if(tr[now].val == x)&#123; ans += tr[tr[now].son[0]].size + 1; break; &#125; else if(tr[now].val &lt; x)&#123; ans += tr[tr[now].son[0]].size + tr[now].times; now = tr[now].son[1]; &#125; else now = tr[now].son[0]; &#125; return ans - 1;&#125;inline int newNode(int val, int f)&#123; ++cnt; tr[cnt].val = val; tr[cnt].fa = f; tr[cnt].son[0] = tr[cnt].son[1] = 0; tr[cnt].size = tr[cnt].times = 1; return cnt;&#125;inline void insert(int x)&#123; splay(select(getPre(x)), 0); splay(select(getSub(x)), root); int t = tr[tr[root].son[1]].son[0]; if(!t) tr[tr[root].son[1]].son[0] = newNode(x, tr[root].son[1]); else tr[t].times++, tr[t].size++; pushup(tr[root].son[1]); pushup(root);&#125;inline void del(int x)&#123; splay(select(getPre(x)), 0); splay(select(getSub(x)), root); int t = tr[tr[root].son[1]].son[0]; if(!t || tr[t].times == 0) return; tr[t].times--, tr[t].size--; if(tr[t].times == 0) tr[tr[root].son[1]].son[0] = 0; pushup(tr[root].son[1]); pushup(root);&#125;inline int findRank(int x)&#123; int now = root; while(now)&#123; if(tr[tr[now].son[0]].size + 1 &lt;= x &amp;&amp; x &lt;= tr[tr[now].son[0]].size + tr[now].times) break; else if(tr[tr[now].son[0]].size + 1 &gt; x) now = tr[now].son[0]; else if(tr[tr[now].son[0]].size + tr[now].times &lt; x)&#123; x -= tr[tr[now].son[0]].size + tr[now].times; now = tr[now].son[1]; &#125; &#125; return tr[now].val;&#125;int main()&#123; scanf("%d", &amp;n); root = newNode(-INF, 0); tr[root].son[1] = newNode(INF, root), pushup(root); while(n--)&#123; scanf("%d%d", &amp;opt, &amp;q); if(opt == 1) insert(q); else if(opt == 2) del(q); else if(opt == 3) printf("%d\n", getRank(q)); else if(opt == 4) printf("%d\n", findRank(q+1)); else if(opt == 5) printf("%d\n", getPre(q)); else if(opt == 6) printf("%d\n", getSub(q)); &#125; return 0;&#125; 二、非旋Treap每个节点表示一个值，同时记录该点及其子树大小、左右儿子。 插入：从x处split，新建一个值为x的节点，再将三部分merge起来。（注：从x处分开：x在前一部分，下同） 删除：从x、x+1处split成三部分（记为l、t、r），将t的左右儿子merge起来，这样就删除了一个节点，再将三部分merge起来。 查x排名：从x-1处split，则x排名为前一部分的大小+1 查排名为x的数：同Splay 求x前驱：同Splay 求x后继：同Splay 时间复杂度：每次操作 $O(log_2n)$ Code#2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int INF = 1e9;const int N = 100005;int n, opt, q;struct Treap&#123; int val, son[2], size, hp;&#125;tr[N];struct OPT_Treap&#123; int cnt, root; inline int newNode(int val)&#123; cnt++; tr[cnt].val = val; tr[cnt].hp = rand(); tr[cnt].son[0] = tr[cnt].son[1] = 0; tr[cnt].size = 1; return cnt; &#125; inline void pushup(int id)&#123; tr[id].size = 1; if(tr[id].son[0]) tr[id].size += tr[tr[id].son[0]].size; if(tr[id].son[1]) tr[id].size += tr[tr[id].son[1]].size; &#125; inline void pushdown(int id)&#123; return; &#125; int merge(int a, int b)&#123; if(a == 0) return b; if(b == 0) return a; if(tr[a].hp &lt;= tr[b].hp)&#123; pushdown(a); tr[a].son[1] = merge(tr[a].son[1], b); pushup(a); return a; &#125; else&#123; pushdown(b); tr[b].son[0] = merge(a, tr[b].son[0]); pushup(b); return b; &#125; &#125; void split(int id, int k, int &amp;x, int &amp;y)&#123; if(!id)&#123; x = 0, y = 0; return; &#125; pushdown(id); if(tr[id].val &gt; k) y = id, split(tr[id].son[0], k, x, tr[id].son[0]); else x = id, split(tr[id].son[1], k, tr[id].son[1], y); pushup(id); &#125; inline void insert(int val)&#123; int l = 0, r = 0; split(root, val, l, r); int t = newNode(val); root = merge(merge(l, t), r); &#125; inline void del(int val)&#123; int l = 0, r = 0, t = 0; split(root, val - 1, l, t); split(t, val, t, r); t = merge(tr[t].son[0], tr[t].son[1]); root = merge(merge(l, t), r); &#125; inline int getRank(int x)&#123; int ans = 0, l = 0, r = 0; split(root, x-1, l, r); ans = tr[l].size + 1; root = merge(l, r); return ans; &#125; inline int getKth(int k)&#123; int now = root; while(now)&#123; if(tr[tr[now].son[0]].size + 1 == k) return tr[now].val; else if(tr[tr[now].son[0]].size &gt;= k) now = tr[now].son[0]; else k -= (tr[tr[now].son[0]].size + 1), now = tr[now].son[1]; &#125; return -INF; &#125; inline int getPre(int x)&#123; int ans = -INF, now = root; while(now)&#123; if(tr[now].val &gt;= x) now = tr[now].son[0]; else&#123; ans = max(ans, tr[now].val); now = tr[now].son[1]; &#125; &#125; return ans; &#125; inline int getSub(int x)&#123; int ans = INF, now = root; while(now)&#123; if(tr[now].val &lt;= x) now = tr[now].son[1]; else&#123; ans = min(ans, tr[now].val); now = tr[now].son[0]; &#125; &#125; return ans; &#125;&#125;BST;int main()&#123; srand(200127); scanf("%d", &amp;n); BST.root = BST.newNode(INF); while(n--)&#123; scanf("%d%d", &amp;opt, &amp;q); if(opt == 1) BST.insert(q); else if(opt == 2) BST.del(q); else if(opt == 3) printf("%d\n", BST.getRank(q)); else if(opt == 4) printf("%d\n", BST.getKth(q)); else if(opt == 5) printf("%d\n", BST.getPre(q)); else if(opt == 6) printf("%d\n", BST.getSub(q)); &#125; return 0;&#125; 文艺平衡树题目链接：luogu3391bzoj3223 解题思路一、Splay这道题只有区间翻转操作，线段树不好维护，只有用平衡树了。对于一次$[l,r]$的区间翻转，把$l-1$旋至根，$r+1$旋至根的右儿子，那么$[l,r]$就在根的右儿子的左儿子处了。和线段树一样，我们可以将它的左右儿子互换后打上一个翻转标记(rev ^= 1)，之后再pushdown。 Code#3123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int INF = 0x7fffffff;const int N = 100005;int n, m, ql, qr;int cnt, root;struct Splay_tree&#123; int fa, son[2], size, val; bool rev;&#125;tr[N];inline void pushup(int x)&#123; if(x)&#123; tr[x].size = 1; if(tr[x].son[0]) tr[x].size += tr[tr[x].son[0]].size; if(tr[x].son[1]) tr[x].size += tr[tr[x].son[1]].size; &#125;&#125;inline void pushdown(int x)&#123; if(tr[x].rev)&#123; if(tr[x].son[0])&#123; tr[tr[x].son[0]].rev ^= 1; swap(tr[tr[x].son[0]].son[0], tr[tr[x].son[0]].son[1]); &#125; if(tr[x].son[1])&#123; tr[tr[x].son[1]].rev ^= 1; swap(tr[tr[x].son[1]].son[0], tr[tr[x].son[1]].son[1]); &#125; tr[x].rev = 0; &#125;&#125;inline void rotate(int x, int kind)&#123; int y = tr[x].fa, z = tr[y].fa, A = tr[y].son[kind], B = tr[x].son[kind], C = tr[x].son[!kind]; tr[x].son[kind] = y, tr[x].fa = z; tr[y].son[!kind] = B, tr[y].fa = x; tr[z].son[tr[z].son[1] == y] = x; tr[B].fa = y; pushup(y), pushup(x);&#125;inline void splay(int x, int goal)&#123; if(x == goal) return; while(tr[x].fa != goal)&#123; int y = tr[x].fa, z = tr[y].fa; pushdown(z), pushdown(y), pushdown(x); int isrson1 = tr[y].son[1] == x, isrson2 = tr[z].son[1] == y; if(z == goal) rotate(x, !isrson1); else&#123; if(isrson1 == isrson2) rotate(y, !isrson2); else rotate(x, !isrson1); rotate(x, !isrson2); &#125; &#125; if(goal == 0) root = x;&#125;inline int newNode(int val, int f)&#123; cnt++; tr[cnt].val = val; tr[cnt].fa = f; tr[cnt].son[0] = tr[cnt].son[1] = 0; tr[cnt].size = 1; return cnt;&#125;int select(int x)&#123; int now = root; pushdown(now); while(tr[tr[now].son[0]].size + 1 != x)&#123; if(tr[tr[now].son[0]].size + 1 &gt; x) now = tr[now].son[0]; else&#123; x -= tr[tr[now].son[0]].size + 1; now = tr[now].son[1]; &#125; pushdown(now); &#125; return now;&#125;inline void reverse(int l, int r)&#123; splay(select(l-1), 0); splay(select(r+1), root); int t = tr[tr[root].son[1]].son[0]; tr[t].rev ^= 1; swap(tr[t].son[0], tr[t].son[1]);&#125;int build(int l, int r, int f)&#123; if(l &gt; r) return 0; int mid = (l + r) &gt;&gt; 1, x = ++cnt; tr[x].val = mid - 1; tr[x].size = 1; tr[x].fa = f; tr[x].rev = 0; tr[x].son[0] = build(l, mid-1, x); tr[x].son[1] = build(mid+1, r, x); pushup(x); return x;&#125;void print(int x)&#123; pushdown(x); if(tr[x].son[0]) print(tr[x].son[0]); if(tr[x].val &gt;= 1 &amp;&amp; tr[x].val &lt;= n) printf("%d ", tr[x].val); if(tr[x].son[1]) print(tr[x].son[1]);&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); root = build(1, n+2, 0); while(m--)&#123; scanf("%d%d", &amp;ql, &amp;qr); reverse(ql+1, qr+1); &#125; print(root); return 0;&#125; 二、非旋Treap同上。 Code#4123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int INF = 1e9;const int N = 100005;int n, m, ql, qr;struct Treap&#123; int val, size, son[2], hp; bool rev;&#125;tr[N];struct OPT_Treap&#123; int cnt, root; inline int newNode(int val)&#123; cnt++; tr[cnt].val = val; tr[cnt].hp = rand(); tr[cnt].size = 1; tr[cnt].son[0] = tr[cnt].son[1] = 0; tr[cnt].rev = 0; return cnt; &#125; inline void pushup(int id)&#123; if(!id) return; tr[id].size = 1; if(tr[id].son[0]) tr[id].size += tr[tr[id].son[0]].size; if(tr[id].son[1]) tr[id].size += tr[tr[id].son[1]].size; &#125; inline void pushdown(int id)&#123; if(!tr[id].rev) return; if(tr[id].son[0])&#123; int t = tr[id].son[0]; tr[t].rev ^= 1; swap(tr[t].son[0], tr[t].son[1]); &#125; if(tr[id].son[1])&#123; int t = tr[id].son[1]; tr[t].rev ^= 1; swap(tr[t].son[0], tr[t].son[1]); &#125; tr[id].rev ^= 1; &#125; int merge(int a, int b)&#123; if(a == 0) return b; if(b == 0) return a; if(tr[a].hp &lt;= tr[b].hp)&#123; pushdown(a); tr[a].son[1] = merge(tr[a].son[1], b); pushup(a); return a; &#125; else&#123; pushdown(b); tr[b].son[0] = merge(a, tr[b].son[0]); pushup(b); return b; &#125; &#125; void split(int id, int k, int &amp;x, int &amp;y)&#123; if(!id)&#123; x = 0, y = 0; return; &#125; pushdown(id); if(tr[tr[id].son[0]].size &gt;= k) y = id, split(tr[id].son[0], k, x, tr[id].son[0]); else x = id, split(tr[id].son[1], k - tr[tr[id].son[0]].size - 1, tr[id].son[1], y); pushup(id); &#125; inline void reverse(int l, int r)&#123; int L, t, R; split(root, l - 1, L, t); split(t, r - l + 1, t, R); tr[t].rev ^= 1; swap(tr[t].son[0], tr[t].son[1]); root = merge(merge(L, t), R); &#125; inline int build(int l, int r)&#123; if(l &gt; r) return 0; int mid = (l + r) &gt;&gt; 1; int t = newNode(mid); tr[t].son[0] = build(l, mid - 1); tr[t].son[1] = build(mid + 1, r); pushup(t); return t; &#125;&#125;BST;void print(int x)&#123; BST.pushdown(x); if(tr[x].son[0]) print(tr[x].son[0]); printf("%d ", tr[x].val); if(tr[x].son[1]) print(tr[x].son[1]);&#125;int main()&#123; srand(200127); scanf("%d%d", &amp;n, &amp;m); BST.root = BST.build(1, n); while(m--)&#123; scanf("%d%d", &amp;ql, &amp;qr); BST.reverse(ql, qr); &#125; print(BST.root); return 0;&#125; 二逼平衡树题目链接：luogu3380bzoj3196 解题思路一、线段树套Splay这道题与普通平衡树唯一的不同就在于所有查询都是区间查询，那么我们需要在平衡树外面套一层线段树以供区间查询，即线段树套平衡树。当然，并非真的要在每个线段树节点内建一颗平衡树，存一下在这个节点的平衡树的根的编号就行了。 查询区间内k的排名：在线段树上递归找查询的区间，在相应节点上的平衡树上查询比k小的数的个数，回溯时将所有答案相加得到了区间内比k小的数的个数，最后+1就是排名； 查询区间内排名为k的值：这个要麻烦一点，由于不同线段树节点上的答案不能进行合并，只能考虑二分答案，问题转化为二分出的答案在区间内的排名问题，即第一问； 修改某位置的值：修改即先删除原值，再插入新值；在线段树上找到该节点，对所经路线上所有线段树里的平衡树进行删除插入操作； 查询k在区间内的前驱：同第一问，只不过在更新答案时不是相加，而是取max； 查询k在区间内的后继：同第一问，只不过在更新答案时不是相加，而是取min。 Code#5123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((A[id].l+A[id].r)&gt;&gt;1)using namespace std;const int INF = 0x7fffffff;const int N = 50005;int n, m, a[N], opt, ql, qr, qk, qpos, tmp;struct splay&#123; int size, times, val, son[2], fa;&#125;B[(int)4e6];struct segTree&#123; int l, r, root;&#125;A[N&lt;&lt;2];struct OPT_splay&#123; int cnt; inline void pushup(int x)&#123; if(x)&#123; B[x].size = B[x].times; if(B[x].son[0]) B[x].size += B[B[x].son[0]].size; if(B[x].son[1]) B[x].size += B[B[x].son[1]].size; &#125; &#125; inline void rotate(int x, int kind)&#123; int y = B[x].fa, z = B[y].fa, a = B[y].son[kind], b = B[x].son[kind], c = B[x].son[!kind]; B[x].fa = z, B[x].son[kind] = y; B[y].fa = x, B[y].son[!kind] = b; B[z].son[B[z].son[1] == y] = x; B[b].fa = y; pushup(y), pushup(x); &#125; inline void splay(int x, int goal, int id)&#123; if(x == goal) return; while(B[x].fa != goal)&#123; int y = B[x].fa, z = B[y].fa; int isrson1 = B[y].son[1] == x, isrson2 = B[z].son[1] == y; if(z == goal) rotate(x, !isrson1); else&#123; if(isrson1 == isrson2) rotate(y, !isrson2); else rotate(x, !isrson1); rotate(x, !isrson2); &#125; &#125; if(goal == 0) A[id].root = x; &#125; inline int newNode(int val, int fa)&#123; cnt++; B[cnt].fa = fa; B[cnt].val = val; B[cnt].size = B[cnt].times = 1; B[cnt].son[0] = B[cnt].son[1] = 0; return cnt; &#125; inline int getPre(int x, int id)&#123; int now = A[id].root, res = -INF; while(now)&#123; if(B[now].val &lt; x)&#123; res = max(res, B[now].val); now = B[now].son[1]; &#125; else now = B[now].son[0]; &#125; return res; &#125; inline int getSub(int x, int id)&#123; int now = A[id].root, res = INF; while(now)&#123; if(B[now].val &gt; x)&#123; res = min(res, B[now].val); now = B[now].son[0]; &#125; else now = B[now].son[1]; &#125; return res; &#125; inline int select(int x, int id)&#123; int now = A[id].root; while(now)&#123; if(B[now].val == x) break; else if(B[now].val &gt; x) now = B[now].son[0]; else if(B[now].val &lt; x) now = B[now].son[1]; &#125; if(!now) return -1; return now; &#125; inline int getRank(int x, int id)&#123; if(select(x, id) != -1) splay(select(x, id), 0, id); else splay(select(getSub(x, id), id), 0, id); return B[B[A[id].root].son[0]].size; &#125; inline void insert(int val, int id)&#123; splay(select(getPre(val, id), id), 0, id); splay(select(getSub(val, id), id), A[id].root, id); int t = B[B[A[id].root].son[1]].son[0]; if(!t) B[B[A[id].root].son[1]].son[0] = newNode(val, B[A[id].root].son[1]); else B[t].times++, B[t].size++; pushup(B[A[id].root].son[1]); pushup(A[id].root); &#125; inline void del(int val, int id)&#123; splay(select(getPre(val, id), id), 0, id); splay(select(getSub(val, id), id), A[id].root, id); int t = B[B[A[id].root].son[1]].son[0]; if(!t || B[t].times == 0) return; B[t].times--, B[t].size--; if(B[t].times == 0) B[B[A[id].root].son[1]].son[0] = 0; pushup(B[A[id].root].son[1]); pushup(A[id].root); &#125;&#125;Splay;struct OPT_segTree&#123; void build(int id, int l, int r)&#123; A[id].root = Splay.newNode(-INF, 0); B[A[id].root].son[1] = Splay.newNode(INF, A[id].root); A[id].l = l, A[id].r = r; if(A[id].l == A[id].r) return; build(lid, l, mid); build(rid, mid+1, r); &#125; void insert(int id, int pos, int val)&#123; Splay.insert(val, id); if(A[id].l == A[id].r) return; if(pos &lt;= mid) insert(lid, pos, val); else insert(rid, pos, val); &#125; int getRank(int id, int l, int r, int x)&#123; if(A[id].l == l &amp;&amp; A[id].r == r) return Splay.getRank(x, id) - 1; if(r &lt;= mid) return getRank(lid, l, r, x); else if(l &gt; mid) return getRank(rid, l, r, x); else return getRank(lid, l, mid, x) + getRank(rid, mid+1, r, x); &#125; int getKth(int l, int r, int k)&#123; int ans = -1, L = 0, R = 1e8; while(L &lt;= R)&#123; int Mid = (L + R) &gt;&gt; 1; int t1 = getRank(1, l, r, Mid) + 1; int t2 = getRank(1, l, r, Mid+1); if(t1 &lt;= k &amp;&amp; k &lt;= t2)&#123; ans = Mid; break; &#125; if(t2 &lt; k) L = Mid+1; else if(t1 &gt; k) R = Mid-1; &#125; return ans; &#125; void modify(int id, int pos, int val)&#123; Splay.del(a[pos], id); Splay.insert(val, id); if(A[id].l == A[id].r) return; if(pos &lt;= mid) modify(lid, pos, val); else modify(rid, pos, val); &#125; int getPre(int id, int l, int r, int x)&#123; if(A[id].l == l &amp;&amp; A[id].r == r) return Splay.getPre(x, id); if(r &lt;= mid) return getPre(lid, l, r, x); else if(l &gt; mid) return getPre(rid, l, r, x); else return max(getPre(lid, l, mid, x), getPre(rid, mid+1, r, x)); &#125; int getSub(int id, int l, int r, int x)&#123; if(A[id].l == l &amp;&amp; A[id].r == r) return Splay.getSub(x, id); if(r &lt;= mid) return getSub(lid, l, r, x); else if(l &gt; mid) return getSub(rid, l, r, x); else return min(getSub(lid, l, mid, x), getSub(rid, mid+1, r, x)); &#125;&#125;Seg;int main()&#123; scanf("%d%d", &amp;n, &amp;m); Seg.build(1, 1, n); for(int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;a[i]); Seg.insert(1, i, a[i]); &#125; while(m--)&#123; scanf("%d", &amp;opt); if(opt == 3) scanf("%d%d", &amp;qpos, &amp;qk); else scanf("%d%d%d", &amp;ql, &amp;qr, &amp;qk); if(opt == 1) printf("%d\n", Seg.getRank(1, ql, qr, qk) + 1); else if(opt == 2) printf("%d\n", Seg.getKth(ql, qr, qk)); else if(opt == 3) Seg.modify(1, qpos, qk), a[qpos] = qk; else if(opt == 4) printf("%d\n", Seg.getPre(1, ql, qr, qk)); else if(opt == 5) printf("%d\n", Seg.getSub(1, ql, qr, qk)); &#125; return 0;&#125; 二、线段树套非旋Treap同上。 Code#6123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((A[id].l + A[id].r) &gt;&gt; 1)using namespace std;const int INF = 0x7fffffff;const int N = 50005;int n, m, opt, ql, qr, qk, qpos, a[N];struct Treap&#123; int val, son[2], size, hp;&#125;B[(int)4e6];struct segTree&#123; int l, r, root;&#125;A[N&lt;&lt;2];struct OPT_Treap&#123; int cnt; inline int newNode(int val)&#123; cnt++; B[cnt].val = val; B[cnt].son[0] = B[cnt].son[1] = 0; B[cnt].size = 1; B[cnt].hp = rand(); return cnt; &#125; inline void pushup(int id)&#123; if(!id) return; B[id].size = 1; if(B[id].son[0]) B[id].size += B[B[id].son[0]].size; if(B[id].son[1]) B[id].size += B[B[id].son[1]].size; &#125; int merge(int a, int b)&#123; if(a == 0) return b; if(b == 0) return a; if(B[a].hp &lt;= B[b].hp)&#123; B[a].son[1] = merge(B[a].son[1], b); pushup(a); return a; &#125; else&#123; B[b].son[0] = merge(a, B[b].son[0]); pushup(b); return b; &#125; &#125; void split(int id, int k, int &amp;x, int &amp;y)&#123; if(!id)&#123; x = 0, y = 0; return; &#125; if(B[id].val &gt; k) y = id, split(B[id].son[0], k, x, B[id].son[0]); else x = id, split(B[id].son[1], k, B[id].son[1], y); pushup(id); &#125; inline void insert(int &amp;rt, int val)&#123; int l = 0, r = 0; split(rt, val, l, r); int t = newNode(val); rt = merge(merge(l, t), r); &#125; inline void del(int &amp;rt, int val)&#123; int l = 0, r = 0, t = 0; split(rt, val - 1, l, t); split(t, val, t, r); t = merge(B[t].son[0], B[t].son[1]); rt = merge(merge(l, t), r); &#125; inline int getRank(int &amp;rt, int x)&#123; int l = 0, r = 0; split(rt, x - 1, l, r); int ans = B[l].size + 1; rt = merge(l, r); return ans; &#125; inline int getPre(int &amp;rt, int x)&#123; int now = rt, ans = -INF; while(now)&#123; if(B[now].val &lt; x)&#123; ans = max(ans, B[now].val); now = B[now].son[1]; &#125; else now = B[now].son[0]; &#125; return ans; &#125; inline int getSub(int &amp;rt, int x)&#123; int now = rt, ans = INF; while(now)&#123; if(B[now].val &gt; x)&#123; ans = min(ans, B[now].val); now = B[now].son[0]; &#125; else now = B[now].son[1]; &#125; return ans; &#125;&#125;BST;struct OPT_segTree&#123; void build(int id, int l, int r)&#123; A[id].l = l, A[id].r = r; A[id].root = BST.newNode(INF); if(A[id].l == A[id].r) return; build(lid, l, mid); build(rid, mid+1, r); &#125; void insert(int id, int pos, int val)&#123; BST.insert(A[id].root, val); if(A[id].l == A[id].r) return; if(pos &lt;= mid) insert(lid, pos, val); else insert(rid, pos, val); &#125; void modify(int id, int pos, int val)&#123; BST.del(A[id].root, a[pos]); BST.insert(A[id].root, val); if(A[id].l == A[id].r) return; if(pos &lt;= mid) modify(lid, pos, val); else modify(rid, pos, val); &#125; int query(int id, int l, int r, int x, int kind)&#123; if(A[id].l == l &amp;&amp; A[id].r == r)&#123; if(kind == 0) return BST.getRank(A[id].root, x); if(kind == 1) return BST.getPre(A[id].root, x); if(kind == 2) return BST.getSub(A[id].root, x); &#125; if(r &lt;= mid) return query(lid, l, r, x, kind); else if(l &gt; mid) return query(rid, l, r, x, kind); else&#123; if(kind == 0) return query(lid, l, mid, x, kind) + query(rid, mid+1, r, x, kind) - 1; if(kind == 1) return max(query(lid, l, mid, x, kind), query(rid, mid+1, r, x, kind)); if(kind == 2) return min(query(lid, l, mid, x, kind), query(rid, mid+1, r, x, kind)); &#125; &#125; int getKth(int l, int r, int k)&#123; int L = 0, R = 1e8, ans = 0; while(L &lt;= R)&#123; int Mid = (L + R) &gt;&gt; 1; int t1 = query(1, l, r, Mid, 0); int t2 = query(1, l, r, Mid+1, 0) - 1; if(t1 &lt;= k &amp;&amp; k &lt;= t2)&#123; ans = Mid; break; &#125; else if(t2 &lt; k) L = Mid + 1; else if(t1 &gt; k) R = Mid - 1; &#125; return ans; &#125;&#125;Seg;int main()&#123; srand(200127); scanf("%d%d", &amp;n, &amp;m); BST.cnt = 0; Seg.build(1, 1, n); for(int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;a[i]); Seg.insert(1, i, a[i]); &#125; while(m--)&#123; scanf("%d", &amp;opt); if(opt == 3) scanf("%d%d", &amp;qpos, &amp;qk); else scanf("%d%d%d", &amp;ql, &amp;qr, &amp;qk); if(opt == 1) printf("%d\n", Seg.query(1, ql, qr, qk, 0)); else if(opt == 2) printf("%d\n", Seg.getKth(ql, qr, qk)); else if(opt == 3) Seg.modify(1, qpos, qk), a[qpos] = qk; else if(opt == 4) printf("%d\n", Seg.query(1, ql, qr, qk, 1)); else if(opt == 5) printf("%d\n", Seg.query(1, ql, qr, qk, 2)); &#125; return 0;&#125; 三、树状数组套值域线段树（带修改主席树）hmm…这道题其实可以不用平衡树做，因为要求第k大，自然而然想到主席树可以做到，但这道题有修改操作，普通的维护前缀和的主席树修改一次就要把后面所有树都改了，所以修改一次的时间复杂度就是$O(NlogN)$的，显然不行。于是，带修改主席树应运而生：我们不再让值域线段树们维护前缀和了，而是让它们维护树状数组上对应的约$logN$个点，这样一次修改的时间复杂度就降到了$O(log_2^2N)$。 查询区间内k的排名：相当于找比k小的数有多少个（答案是个数+1）。在值域线段树上二分查找k时，如果往右儿子走，就把左儿子大小加进答案里去就行了； 查询区间内排名为k的值：找到树状数组里面相关的值域线段树（存进一个数组，见代码中的A[]和B[]），算出当前点左儿子大小，再决定是向左还是向右二分下去； 修改某位置的值：修改即先删除原值，再插入新值；找到树状数组里面相关的值域线段树，对每棵树都进行删除和插入操作； 查询k在区间内的前驱：查询区间内比k小的数有多少个，如果没有，输出-INF；否则输出区间内相应排名的值； 查询k在区间内的后继：查询区间内比k大的数有多少个，如果没有，输出INF；否则输出区间内相应排名的值。 涉及到值域线段树一般都要离散化，以保证空间；同时，这道题还必须动态开点才能保证空间。 Code#7纪念我的第一份超过200行的代码…123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int INF = 0x7fffffff;const int N = 50005;int n, m, a[N], t[N&lt;&lt;1], f[N&lt;&lt;1], MX, A[20], B[20];//因为有询问操作，t[]和f[]空间一定要开够!int root[N], cnt;struct Query&#123; int opt, l, r, k, pos;&#125;q[N];struct segTree&#123; int size, son[2];&#125;tr[N*15*15];inline void readin()&#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]), t[++t[0]] = a[i]; for(int i = 1; i &lt;= m; i++)&#123; scanf("%d", &amp;q[i].opt); if(q[i].opt != 3)&#123; scanf("%d%d%d", &amp;q[i].l, &amp;q[i].r, &amp;q[i].k); if(q[i].opt != 2) t[++t[0]] = q[i].k; &#125; else&#123; scanf("%d%d", &amp;q[i].pos, &amp;q[i].k); t[++t[0]] = q[i].k; &#125; &#125;&#125;inline void disc()&#123; sort(t+1, t+t[0]+1); int len = unique(t+1, t+t[0]+1) - (t+1); for(int i = 1; i &lt;= n; i++)&#123; int temp = lower_bound(t+1, t+len+1, a[i]) - t; f[temp] = a[i], a[i] = temp; MX = max(MX, temp); &#125; for(int i = 1; i &lt;= m; i++)&#123; if(q[i].opt == 2) continue; int temp = lower_bound(t+1, t+len+1, q[i].k) - t; f[temp] = q[i].k, q[i].k = temp; MX = max(MX, temp); &#125; f[MX+1] = -INF; f[MX+2] = INF;&#125;inline int lowbit(int x)&#123; return x &amp; -x; &#125;inline void init1(int x, int X[])&#123; X[0] = 0; for(int i = x; i; i -= lowbit(i))&#123; if(!root[i]) root[i] = ++cnt; X[++X[0]] = root[i]; &#125;&#125;inline void init2(int x, int X[])&#123; X[0] = 0; for(int i = x; i &lt;= n; i += lowbit(i))&#123; if(!root[i]) root[i] = ++cnt; X[++X[0]] = root[i]; &#125;&#125;inline void pushup(int id)&#123; tr[id].size = tr[tr[id].son[0]].size + tr[tr[id].son[1]].size;&#125;void insert(int &amp;id, int l, int r, int val)&#123; if(!id) id = ++cnt; if(l == r)&#123; tr[id].size++; return; &#125; int mid = (l + r) &gt;&gt; 1; if(val &lt;= mid) insert(tr[id].son[0], l, mid, val); else insert(tr[id].son[1], mid+1, r, val); pushup(id);&#125;void del(int &amp;id, int l, int r, int val)&#123; if(!id) id = ++cnt; if(l == r)&#123; if(tr[id].size &gt; 0) tr[id].size--; return; &#125; int mid = (l + r) &gt;&gt; 1; if(val &lt;= mid) del(tr[id].son[0], l, mid, val); else del(tr[id].son[1], mid+1, r, val); pushup(id);&#125;int getSmaller(int l, int r, int k)&#123; if(l == r) return 0; int mid = (l + r) &gt;&gt; 1; if(k &lt;= mid)&#123; for(int i = 1; i &lt;= A[0]; i++)&#123; if(!tr[A[i]].son[0]) tr[A[i]].son[0] = ++cnt; A[i] = tr[A[i]].son[0]; &#125; for(int i = 1; i &lt;= B[0]; i++)&#123; if(!tr[B[i]].son[0]) tr[B[i]].son[0] = ++cnt; B[i] = tr[B[i]].son[0]; &#125; return getSmaller(l, mid, k); &#125; else&#123; int res = 0; for(int i = 1; i &lt;= A[0]; i++)&#123; if(!tr[A[i]].son[1]) tr[A[i]].son[1] = ++cnt; res -= tr[tr[A[i]].son[0]].size; A[i] = tr[A[i]].son[1]; &#125; for(int i = 1; i &lt;= B[0]; i++)&#123; if(!tr[B[i]].son[1]) tr[B[i]].son[1] = ++cnt; res += tr[tr[B[i]].son[0]].size; B[i] = tr[B[i]].son[1]; &#125; return res + getSmaller(mid+1, r, k); &#125;&#125;int getBigger(int l, int r, int k)&#123; if(l == r) return 0; int mid = (l + r) &gt;&gt; 1; if(k &lt;= mid)&#123; int res = 0; for(int i = 1; i &lt;= A[0]; i++)&#123; if(!tr[A[i]].son[0]) tr[A[i]].son[0] = ++cnt; res -= tr[tr[A[i]].son[1]].size; A[i] = tr[A[i]].son[0]; &#125; for(int i = 1; i &lt;= B[0]; i++)&#123; if(!tr[B[i]].son[0]) tr[B[i]].son[0] = ++cnt; res += tr[tr[B[i]].son[1]].size; B[i] = tr[B[i]].son[0]; &#125; return res + getBigger(l, mid, k); &#125; else&#123; for(int i = 1; i &lt;= A[0]; i++)&#123; if(!tr[A[i]].son[1]) tr[A[i]].son[1] = ++cnt; A[i] = tr[A[i]].son[1]; &#125; for(int i = 1; i &lt;= B[0]; i++)&#123; if(!tr[B[i]].son[1]) tr[B[i]].son[1] = ++cnt; B[i] = tr[B[i]].son[1]; &#125; return getBigger(mid+1, r, k); &#125;&#125;int getKth(int l, int r, int k)&#123; if(l == r) return l; int lsize = 0; for(int i = 1; i &lt;= A[0]; i++) lsize -= tr[tr[A[i]].son[0]].size; for(int i = 1; i &lt;= B[0]; i++) lsize += tr[tr[B[i]].son[0]].size; int mid = (l + r) &gt;&gt; 1; if(lsize &gt;= k)&#123; for(int i = 1; i &lt;= A[0]; i++)&#123; if(!tr[A[i]].son[0]) tr[A[i]].son[0] = ++cnt; A[i] = tr[A[i]].son[0]; &#125; for(int i = 1; i &lt;= B[0]; i++)&#123; if(!tr[B[i]].son[0]) tr[B[i]].son[0] = ++cnt; B[i] = tr[B[i]].son[0]; &#125; return getKth(l, mid, k); &#125; else&#123; for(int i = 1; i &lt;= A[0]; i++)&#123; if(!tr[A[i]].son[1]) tr[A[i]].son[1] = ++cnt; A[i] = tr[A[i]].son[1]; &#125; for(int i = 1; i &lt;= B[0]; i++)&#123; if(!tr[B[i]].son[1]) tr[B[i]].son[1] = ++cnt; B[i] = tr[B[i]].son[1]; &#125; return getKth(mid+1, r, k - lsize); &#125;&#125;inline int getPre(int ql, int qr, int k)&#123; init1(ql-1, A), init1(qr, B); int rank = getSmaller(1, MX, k) + 1; init1(ql-1, A), init1(qr, B); if(rank == 1) return MX+1; else return getKth(1, MX, rank-1);&#125;inline int getSub(int ql, int qr, int k)&#123; init1(ql-1, A), init1(qr, B); int rank = getBigger(1, MX, k) + 1; init1(ql-1, A), init1(qr, B); if(rank == 1) return MX+2; else return getKth(1, MX, qr - ql + 3 - rank);&#125;int main()&#123; readin(); disc(); for(int i = 1; i &lt;= n; i++)&#123; init2(i, A); for(int j = 1; j &lt;= A[0]; j++) insert(A[j], 1, MX, a[i]); &#125; for(int i = 1; i &lt;= m; i++)&#123; switch(q[i].opt)&#123; case 1: init1(q[i].l-1, A); init1(q[i].r, B); printf("%d\n", getSmaller(1, MX, q[i].k) + 1); break; case 2: init1(q[i].l-1, A); init1(q[i].r, B); printf("%d\n", f[getKth(1, MX, q[i].k)]); break; case 3:&#123; init2(q[i].pos, A); for(int j = 1; j &lt;= A[0]; j++)&#123; del(A[j], 1, MX, a[q[i].pos]); insert(A[j], 1, MX, q[i].k); &#125; a[q[i].pos] = q[i].k; break; &#125; case 4: printf("%d\n", f[getPre(q[i].l, q[i].r, q[i].k)]); break; case 5: printf("%d\n", f[getSub(q[i].l, q[i].r, q[i].k)]); break; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>平衡树</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ZJOI2008]树的统计（树链剖分，线段树）]]></title>
    <url>%2F2018%2F04%2F29%2FZJOI2008-%E6%A0%91%E7%9A%84%E7%BB%9F%E8%AE%A1%EF%BC%88%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%EF%BC%8C%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述一棵树上有n个节点，编号分别为1到n，每个节点都有一个权值w。我们将以下面的形式来要求你对这棵树完成一些操作：I. CHANGE u t : 把结点u的权值改为tII. QMAX u v: 询问从点u到点v的路径上的节点的最大权值III. QSUM u v: 询问从点u到点v的路径上的节点的权值和注意：从点u到点v的路径上的节点包括u和v本身 输入格式输入文件的第一行为一个整数n，表示节点的个数。接下来n – 1行，每行2个整数a和b，表示节点a和节点b之间有一条边相连。接下来一行n个整数，第i个整数wi表示节点i的权值。接下来1行，为一个整数q，表示操作的总数。接下来q行，每行一个操作，以“CHANGE u t”或者“QMAX u v”或者“QSUM u v”的形式给出。 输出格式对于每个“QMAX”或者“QSUM”的操作，每行输出一个整数表示要求输出的结果。 输入样例12345678910111213141516171841 22 34 14 2 1 312QMAX 3 4QMAX 3 3QMAX 3 2QMAX 2 3QSUM 3 4QSUM 2 1CHANGE 1 5QMAX 3 4CHANGE 3 6QMAX 3 4QMAX 2 4QSUM 3 4 输出样例12345678910412210656516 说明对于100％的数据，保证$1 \leq n \leq 30000，0 \leq q \leq 200000$；中途操作中保证每个节点的权值w在$-30000$到$30000$之间。 解题思路这是一道树链剖分的模板题了。注意权值有可能为负数，所以求最大值时要初始化为-INF 复杂度$O(n \log ^2n)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const LL INF = 1e16;const int N = 30005;int n, u, v, q;char opt[10];LL a[N];struct Edge&#123; int nxt, to;&#125;edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to)&#123; edge[++edgeNum].nxt = head[from]; edge[edgeNum].to = to; head[from] = edgeNum;&#125;int size[N], fa[N], dep[N], son[N];void dfs1(int x, int f, int depth)&#123; size[x] = 1, fa[x] = f, dep[x] = depth, son[x] = 0; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(edge[i].to == f) continue; dfs1(edge[i].to, x, depth+1); size[x] += size[edge[i].to]; if(size[edge[i].to] &gt; size[son[x]]) son[x] = edge[i].to; &#125;&#125;int st[N], ed[N], belong[N], dfsClock, fun[N];void dfs2(int x, int top)&#123; st[x] = ++dfsClock, fun[dfsClock] = x; belong[x] = top; if(son[x]) dfs2(son[x], top); for(int i = head[x]; i; i = edge[i].nxt)&#123; if(edge[i].to == fa[x] || edge[i].to == son[x]) continue; dfs2(edge[i].to, edge[i].to); &#125; ed[x] = dfsClock;&#125;#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((tr[id].l+tr[id].r)&gt;&gt;1)struct segTree&#123; int l, r; LL mx, sum; segTree()&#123; l = r = 0; sum = 0ll; mx = -INF; &#125;&#125;tr[N&lt;&lt;2];struct &#123; inline void pushup(int id)&#123; tr[id].mx = max(tr[lid].mx, tr[rid].mx); tr[id].sum = tr[lid].sum + tr[rid].sum; &#125; void build(int id, int l, int r)&#123; tr[id].l = l, tr[id].r = r; if(tr[id].l == tr[id].r)&#123; tr[id].mx = tr[id].sum = a[fun[l]]; return; &#125; build(lid, l, mid); build(rid, mid+1, r); pushup(id); &#125; LL query(int id, int l, int r, int k)&#123; if(tr[id].l == l &amp;&amp; tr[id].r == r) return k == 0 ? tr[id].mx : tr[id].sum; if(r &lt;= mid) return query(lid, l, r, k); else if(l &gt; mid) return query(rid, l, r, k); else return k == 0 ? max(query(lid, l, mid, k), query(rid, mid+1, r, k)) : query(lid, l, mid, k) + query(rid, mid+1, r, k); &#125; void modify(int id, int pos, LL v)&#123; if(tr[id].l == tr[id].r)&#123; tr[id].sum = tr[id].mx = v; return; &#125; if(pos &lt;= mid) modify(lid, pos, v); else modify(rid, pos, v); pushup(id); &#125;&#125;seg;LL query(int u, int v, int k)&#123; LL res = k == 0 ? -INF : 0; while(belong[u] != belong[v])&#123; if(dep[belong[u]] &lt; dep[belong[v]]) swap(u, v); res = k == 0 ? max(res, seg.query(1, st[belong[u]], st[u], 0)) : res + seg.query(1, st[belong[u]], st[u], 1); u = fa[belong[u]]; &#125; if(dep[u] &gt; dep[v]) swap(u, v); res = k == 0 ? max(res, seg.query(1, st[u], st[v], 0)) : res + seg.query(1, st[u], st[v], 1); return res;&#125;int main()&#123; scanf("%d", &amp;n); for(int i = 1; i &lt; n; i++)&#123; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v); addEdge(v, u); &#125; for(int i = 1; i &lt;= n; i++) scanf("%lld", &amp;a[i]); dfs1(1, 1, 1); dfs2(1, 1); seg.build(1, 1, n); scanf("%d", &amp;q); while(q--)&#123; scanf("%s%d%d", opt, &amp;u, &amp;v); if(opt[0] == 'C') seg.modify(1, st[u], 1ll*v); else if(opt[1] == 'M') printf("%lld\n", query(u, v, 0)); else if(opt[1] == 'S') printf("%lld\n", query(u, v, 1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>数据结构</category>
        <category>线段树</category>
        <category>树</category>
        <category>树链剖分</category>
      </categories>
      <tags>
        <tag>ZJOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDOI2011]染色（树链剖分，线段树）]]></title>
    <url>%2F2018%2F04%2F28%2FSDOI2011-%E6%9F%93%E8%89%B2%EF%BC%88%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%EF%BC%8C%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目Description给定一棵有n个节点的无根树和m个操作，操作有2类：1、将节点a到节点b路径上所有点都染成颜色c；2、询问节点a到节点b路径上的颜色段数量（连续相同颜色被认为是同一段），如“112221”由3段组成：“11”、“222”和“1”。请你写一个程序依次完成这m个操作。 Input第一行包含2个整数n和m，分别表示节点数和操作数；第二行包含n个正整数表示n个节点的初始颜色下面 n-1 行每行包含两个整数x和y，表示x和y之间有一条无向边。下面 m 行每行描述一个操作：“C a b c”表示这是一个染色操作，把节点a到节点b路径上所有点（包括a和b）都染成颜色c；“Q a b”表示这是一个询问操作，询问节点a到节点b（包括a和b）路径上的颜色段数量。 Output对于每个询问操作，输出一行答案。 Sample Input1234567891011126 52 2 1 2 1 11 21 32 42 52 6Q 3 5C 2 1 1Q 3 5C 5 1 2Q 3 5 Sample Output123312 HINT$N \leq 10^5, M \leq 10^5$，所有的颜色C为整数且在$[0, 10^9]$之间。 解题思路这道题思路应该是很好想到的——树链剖分+线段树显然，合并两个颜色段时，如果合并点两侧颜色相同，那么颜色段数量为左右两段数量之和再减一，否则就是它们的和。根据这个基本性质——线段树维护3个值：颜色段数量(cnt)、左端颜色(lcol)、右端颜色(rcol)，于是tr[id].cnt = tr[lid].cnt + tr[rid].cnt - (tr[lid].rcol == tr[rid].lcol);树链剖分询问时（即往上“跳”时），记录一下上一次询问的端点颜色，如果本次询问的相应端点颜色在合并点处与上次询问端点颜色相等，就要减一。至此本题解决。 复杂度$O(n\log ^2n)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 100005;int n, m, a[N], u, v, qa, qb, qc;char opt[2];struct Edge&#123; int nxt, to;&#125;edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to)&#123; edge[++edgeNum].nxt = head[from]; edge[edgeNum].to = to; head[from] = edgeNum;&#125;int fa[N], dep[N], size[N], son[N];void dfs1(int x, int f, int depth)&#123; fa[x] = f, dep[x] = depth, size[x] = 1, son[x] = 0; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(edge[i].to == f) continue; dfs1(edge[i].to, x, depth+1); size[x] += size[edge[i].to]; if(size[edge[i].to] &gt; size[son[x]]) son[x] = edge[i].to; &#125;&#125;int belong[N], st[N], ed[N], dfsClock, fun[N];void dfs2(int x, int top)&#123; st[x] = ++dfsClock, fun[dfsClock] = x; belong[x] = top; if(son[x]) dfs2(son[x], top); for(int i = head[x]; i; i = edge[i].nxt)&#123; if(edge[i].to == fa[x] || edge[i].to == son[x]) continue; dfs2(edge[i].to, edge[i].to); &#125; ed[x] = dfsClock;&#125;#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((tr[id].l+tr[id].r)&gt;&gt;1)struct segTree&#123; int l, r, lcol, rcol, cnt, cov; segTree()&#123; l = r = lcol = rcol = cnt = cov = 0; &#125;&#125;tr[N&lt;&lt;2];struct &#123; inline void pushup(int id)&#123; tr[id].cnt = tr[lid].cnt + tr[rid].cnt - (tr[lid].rcol == tr[rid].lcol); tr[id].lcol = tr[lid].lcol; tr[id].rcol = tr[rid].rcol; &#125; inline void pushdown(int id)&#123; if(tr[id].l == tr[id].r) return; if(tr[id].cov)&#123; int t = tr[id].cov; tr[lid].cov = tr[rid].cov = t; tr[lid].lcol = tr[lid].rcol = t; tr[rid].lcol = tr[rid].rcol = t; tr[lid].cnt = tr[rid].cnt = 1; tr[id].cov = 0; &#125; &#125; void build(int id, int l, int r)&#123; tr[id].l = l, tr[id].r = r; if(tr[id].l == tr[id].r)&#123; tr[id].cnt = 1; tr[id].lcol = tr[id].rcol = a[fun[l]]; return; &#125; build(lid, l, mid); build(rid, mid+1, r); pushup(id); &#125; void cover(int id, int l, int r, int c)&#123; pushdown(id); if(tr[id].l == l &amp;&amp; tr[id].r == r)&#123; tr[id].cov = c; tr[id].cnt = 1; tr[id].lcol = tr[id].rcol = c; return; &#125; if(r &lt;= mid) cover(lid, l, r, c); else if(l &gt; mid) cover(rid, l, r, c); else cover(lid, l, mid, c), cover(rid, mid+1, r, c); pushup(id); &#125; segTree query(int id, int l, int r)&#123; pushdown(id); if(tr[id].l == l &amp;&amp; tr[id].r == r) return tr[id]; if(r &lt;= mid) return query(lid, l, r); else if(l &gt; mid) return query(rid, l, r); else&#123; segTree t1 = query(lid, l, mid), t2 = query(rid, mid+1, r), t; t.cnt = t1.cnt + t2.cnt - (t1.rcol == t2.lcol); t.lcol = t1.lcol, t.rcol = t2.rcol; return t; &#125; &#125;&#125;seg;void cover(int u, int v, int c)&#123; while(belong[u] != belong[v])&#123; if(dep[belong[u]] &lt; dep[belong[v]]) swap(u, v); seg.cover(1, st[belong[u]], st[u], c); u = fa[belong[u]]; &#125; if(dep[u] &gt; dep[v]) swap(u, v); seg.cover(1, st[u], st[v], c);&#125;int query(int u, int v)&#123; int ans = 0, lastu = 0, lastv = 0; while(belong[u] != belong[v])&#123; if(dep[belong[u]] &lt; dep[belong[v]]) swap(u, v), swap(lastu, lastv); segTree t = seg.query(1, st[belong[u]], st[u]); ans += t.cnt - (t.rcol == lastu); lastu = t.lcol; u = fa[belong[u]]; &#125; if(dep[u] &gt; dep[v]) swap(u, v), swap(lastu, lastv); segTree t = seg.query(1, st[u], st[v]); ans += t.cnt - (t.lcol == lastu) - (t.rcol == lastv); return ans;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]), a[i]++; for(int i = 1; i &lt; n; i++)&#123; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v); addEdge(v, u); &#125; dfs1(1, 1, 1); dfs2(1, 1); seg.build(1, 1, n); while(m--)&#123; scanf("%s", opt); if(opt[0] == 'C')&#123; scanf("%d%d%d", &amp;qa, &amp;qb, &amp;qc); qc++; cover(qa, qb, qc); &#125; else if(opt[0] == 'Q')&#123; scanf("%d%d", &amp;qa, &amp;qb); printf("%d\n", query(qa, qb)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>数据结构</category>
        <category>线段树</category>
        <category>树</category>
        <category>树链剖分</category>
      </categories>
      <tags>
        <tag>SDOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点分治学习笔记]]></title>
    <url>%2F2018%2F04%2F22%2F%E7%82%B9%E5%88%86%E6%B2%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[简介点分治主要解决树上路径问题，其主要思想是把一颗有根树以根为分治点分为一个森林（其实就是各个子树），解决经过当前根的路径后在子树里继续分治，从而将问题“分而治之”。 这里面，根的选择非常重要。为了保证复杂度，我们的分治点应该尽可能的“居中”，所以分治点一般选择正在处理的树的重心。 套路 找到当前树的重心作为根 解决通过这个根的路径的答案（一般有两种方法，一种是通过与子树容斥，一种是直接计算子树贡献） 递归解决子树 实现求重心12345678910111213//root = 0, mxson[0] = INF, sum = n;//root = 0, mxson[0] = INF, sum = size[edge[i].to];void findRoot(int x, int f)&#123; size[x] = 1, mxson[x] = 0; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to] || edge[i].to == f) continue; findRoot(edge[i].to, x); size[x] += size[edge[i].to]; mxson[x] = max(mxson[x], size[edge[i].to]); &#125; mxson[x] = max(mxson[x], sum - size[x]); if(mxson[x] &lt; mxson[root]) root = x;&#125; size[]是子树大小，mxson[]是最大子树大小，root是重心，sum是当前整颗树的大小注意每次 findRoot() 前要初始化 root 和 sum 分治计算1234567891011void solve(int x)&#123; cal(x);//如果此处计算时将子树中一些不合法的路径的贡献也算进去了，那么需要容斥，即在下方*处减掉子树贡献；如果不容斥，就直接利用每颗子树的信息计算答案 vis[x] = 1; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to]) continue; cal(edge[i].to);//* root = 0, sum = size[edge[i].to], mxson[0] = INF; findRoot(edge[i].to, 0); solve(root); &#125;&#125; vis[]标记此点是否计算过，cal()计算以x为根、经过根的路径的答案 注意事项不要再分治时用memset O(n) 地进行初始化，否则点分治好不容易保证的复杂度就被毁了。 练习poj1741 tree题意给一棵树，边有边权，问两点之间的距离小于等于K的点对有多少个。题解点分治时用容斥做：计算以x为根的子树时直接将求得的dis排序后O(n)求答案，然后再减去每个子树中被统计了的不合法答案Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int INF = 1e9;const int N = 10005;int n, k, u, v, p;struct Edge&#123; int nxt, to, dis;&#125;edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to, int dis)&#123; edge[++edgeNum].nxt = head[from]; edge[edgeNum].to = to; edge[edgeNum].dis = dis; head[from] = edgeNum;&#125;bool vis[N];int root, sum, size[N], mxson[N];void findRoot(int x, int f)&#123; size[x] = 1, mxson[x] = 0; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(edge[i].to == f || vis[edge[i].to]) continue; findRoot(edge[i].to, x); size[x] += size[edge[i].to]; mxson[x] = max(mxson[x], size[edge[i].to]); &#125; mxson[x] = max(mxson[x], sum - size[x]); if(mxson[x] &lt; mxson[root]) root = x;&#125;int dis[N], ans;void getDis(int x, int f, int d)&#123; dis[++dis[0]] = d; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(edge[i].to == f || vis[edge[i].to]) continue; getDis(edge[i].to, x, d + edge[i].dis); &#125;&#125;int cal(int x, int d)&#123; int res = 0; for(int i = 1; i &lt;= dis[0]; i++) dis[i] = 0; dis[0] = 0; getDis(x, 0, d); sort(dis+1, dis+dis[0]+1); int l = 1, r = dis[0]; while(l &lt; r)&#123; if(dis[l] + dis[r] &lt;= k) res += r - l, l++; else r--; &#125; return res;&#125;void solve(int x)&#123; ans += cal(x, 0); vis[x] = 1; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to]) continue; ans -= cal(edge[i].to, edge[i].dis); root = 0, mxson[0] = INF, sum = size[edge[i].to]; findRoot(edge[i].to, 0); solve(root); &#125;&#125;void init()&#123; memset(edge, 0, sizeof edge); memset(head, 0, sizeof head); edgeNum = 0; root = sum = ans = 0; memset(size, 0, sizeof size); memset(mxson, 0, sizeof mxson); memset(vis, 0, sizeof vis);&#125;int main()&#123; while(1)&#123; scanf("%d%d", &amp;n, &amp;k); if(n == 0 &amp;&amp; k == 0) break; init(); for(int i = 1; i &lt; n; i++)&#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;p); addEdge(u, v, p); addEdge(v, u, p); &#125; sum = n, root = 0, mxson[0] = INF; findRoot(1, 0); solve(root); printf("%d\n", ans); &#125; return 0;&#125; luogu3806 【模板】点分治1题意给定一棵有n个点的树，多次询问树上距离为k的点对是否存在。题解和上一题差不多，也是容斥，只不过我们把所有k的答案一次性求出来，每次询问O(1)回答。Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;map&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int INF = 1e9;const int N = 10005;int n, m, k[105], u, v, p;struct Edge&#123; int nxt, to, dis;&#125;edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to, int dis)&#123; edge[++edgeNum].nxt = head[from]; edge[edgeNum].to = to; edge[edgeNum].dis = dis; head[from] = edgeNum;&#125;int size[N], mxson[N], dis[N], root, sum;bool vis[N];map&lt;int, int&gt; cnt;void findRoot(int x, int f)&#123; size[x] = 1, mxson[x] = 0; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to] || edge[i].to == f) continue; findRoot(edge[i].to, x); size[x] += size[edge[i].to]; mxson[x] = max(mxson[x], size[edge[i].to]); &#125; mxson[x] = max(mxson[x], sum - size[x]); if(mxson[x] &lt; mxson[root]) root = x;&#125;void getDis(int x, int f, int d)&#123; dis[++dis[0]] = d; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(edge[i].to == f || vis[edge[i].to]) continue; getDis(edge[i].to, x, d + edge[i].dis); &#125;&#125;void cal(int x, int d, int fl)&#123; for(int i = 1; i &lt;= dis[0]; i++) dis[i] = 0; dis[0] = 0; getDis(x, 0, d); sort(dis+1, dis+dis[0]+1); for(int i = 1; i &lt;= dis[0]; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(dis[i] + dis[i] &gt; k[j]) continue; int l = lower_bound(dis+i, dis+dis[0]+1, k[j]-dis[i]) - dis; if(dis[l] + dis[i] != k[j]) continue; int r = upper_bound(dis+i, dis+dis[0]+1, k[j]-dis[i]) - dis; cnt[k[j]] += (r - l) * fl; &#125; &#125;&#125;void solve(int x)&#123; cal(x, 0, 1); vis[x] = 1; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to]) continue; cal(edge[i].to, edge[i].dis, -1); root = 0, sum = size[edge[i].to], mxson[0] = INF; findRoot(edge[i].to, 0); solve(root); &#125;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt; n; i++)&#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;p); addEdge(u, v, p); addEdge(v, u, p); &#125; for(int i = 1; i &lt;= m; i++) scanf("%d", &amp;k[i]); root = 0, sum = n, mxson[0] = INF; findRoot(1, 0); solve(root); for(int i = 1; i &lt;= m; i++) puts(cnt[k[i]] &gt; 0 ? "AYE" : "NAY"); return 0;&#125; [国家集训队] 聪聪可可题意求边权和是3的倍数的点对个数题解思路和上面两道题大同小异，而且更简单了：不用对dis排序，只需记录下距当前根dis为0,1,2的点的个数(cnt)，则答案就是$cnt[0] * cnt[0] + cnt[1] * cnt[2] * 2$当然这样做也要容斥Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 20005;const int INF = 1e9;int n, u, v, p;struct Edge&#123; int nxt, to, dis;&#125;edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to, int dis)&#123; edge[++edgeNum].nxt = head[from]; edge[edgeNum].to = to; edge[edgeNum].dis = dis; head[from] = edgeNum;&#125;int root, mxson[N], sum, size[N];bool vis[N];void findRoot(int x, int f)&#123; size[x] = 1, mxson[x] = 0; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to] || edge[i].to == f) continue; findRoot(edge[i].to, x); size[x] += size[edge[i].to]; mxson[x] = max(mxson[x], size[edge[i].to]); &#125; mxson[x] = max(mxson[x], sum - size[x]); if(mxson[x] &lt; mxson[root]) root = x;&#125;int cnt[3];void getDis(int x, int f, int d)&#123; cnt[d%3]++; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to] || edge[i].to == f) continue; getDis(edge[i].to, x, (d + edge[i].dis) % 3); &#125;&#125;int cal(int x, int d)&#123; cnt[0] = cnt[1] = cnt[2] = 0; getDis(x, 0, d); return cnt[0] * cnt[0] + cnt[1] * cnt[2] * 2;&#125;int ans;void solve(int x)&#123; ans += cal(x, 0); vis[x] = 1; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to]) continue; ans -= cal(edge[i].to, edge[i].dis % 3); root = 0, sum = size[edge[i].to], mxson[0] = INF; findRoot(edge[i].to, 0); solve(root); &#125;&#125;int gcd(int a, int b)&#123; return b == 0 ? a : gcd(b, a % b);&#125;int main()&#123; scanf("%d", &amp;n); for(int i = 1; i &lt; n; i++)&#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;p); addEdge(u, v, p % 3); addEdge(v, u, p % 3); &#125; root = 0, mxson[0] = INF, sum = n; findRoot(1, 0); solve(root); int g = gcd(ans, n*n); printf("%d/%d", ans / g, n * n / g); return 0;&#125; [IOI]Race题意给一棵树，每条边有权。求一条简单路径，权值和等于 K ，且边的数量最小。输出最小边数题解发现这道不能容斥…所以我们想办法通过子树信息直接计算经过分治点的路径的答案记$tmp[i]$为当前子树中，路径长为$i$的最小边数，于是对于当前根$x$，我们每次遍历它的子树，先用$tmp[]$和正在遍历的子树更新答案（代码中的 $updAns()$ 函数），再用正在遍历的这颗子树更新$tmp[]$（代码中的 $updTmp()$ 函数），这样就保证了不会把不合法的路径算进来Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int INF = 1e9;const int N = 200005;int n, k, u, v, p;struct Edge&#123; int nxt, to, dis;&#125;edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to, int dis)&#123; edge[++edgeNum].nxt = head[from]; edge[edgeNum].to = to; edge[edgeNum].dis = dis; head[from] = edgeNum;&#125;int root, mxson[N], size[N], sum;bool vis[N];void findRoot(int x, int f)&#123; size[x] = 1, mxson[x] = 0; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to] || edge[i].to == f) continue; findRoot(edge[i].to, x); size[x] += size[edge[i].to]; mxson[x] = max(mxson[x], size[edge[i].to]); &#125; mxson[x] = max(mxson[x], sum - size[x]); if(mxson[x] &lt; mxson[root]) root = x;&#125;int ans = INF, tmp[1000005];void updTmp(int x, int f, int dis, int d)&#123; if(dis &lt;= k) tmp[dis] = min(tmp[dis], d); for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to] || edge[i].to == f) continue; updTmp(edge[i].to, x, dis + edge[i].dis, d + 1); &#125;&#125;void updAns(int x, int f, int dis, int d)&#123; if(dis &lt;= k) ans = min(ans, d + tmp[k-dis]); for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to] || edge[i].to == f) continue; updAns(edge[i].to, x, dis + edge[i].dis, d + 1); &#125;&#125;void clearTmp(int x, int f, int dis)&#123; if(dis &lt;= k) tmp[dis] = INF; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to] || edge[i].to == f) continue; clearTmp(edge[i].to, x, dis + edge[i].dis); &#125;&#125;void solve(int x)&#123; vis[x] = 1, tmp[0] = 0; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to]) continue; updAns(edge[i].to, x, edge[i].dis, 1); updTmp(edge[i].to, x, edge[i].dis, 1); &#125; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to]) continue; clearTmp(edge[i].to, x, edge[i].dis); &#125; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to]) continue; root = 0, sum = size[edge[i].to]; findRoot(edge[i].to, 0); solve(root); &#125;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;k); for(int i = 1; i &lt; n; i++)&#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;p); addEdge(u+1, v+1, p); addEdge(v+1, u+1, p); &#125; for(int i = 0; i &lt;= k; i++) tmp[i] = INF; root = 0, mxson[0] = INF, sum = n; findRoot(1, 0); solve(root); if(ans == INF) puts("-1"); else printf("%d\n", ans); return 0;&#125; —— 完 ——]]></content>
      <categories>
        <category>图论</category>
        <category>树</category>
        <category>点分治</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2017 D1 T2]时间复杂度（栈，模拟）]]></title>
    <url>%2F2018%2F04%2F14%2FNOIP2017-D1-T2-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%88%E6%A0%88%EF%BC%8C%E6%A8%A1%E6%8B%9F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并 给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序， 于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。 A++语言的循环结构如下：123F i x y 循环体E 其中F i x y表示新建变量 $i$（变量 $i$ 不可与未被销毁的变量重名）并初始化为 $x$， 然后判断 $i$ 和 $y$ 的大小关系，若 $i$ 小于等于 $y$ 则进入循环，否则不进入。每次循环结束后 $i$ 都会被修改成 $i +1$，一旦 $i$ 大于 $y$ 终止循环。 $x$ 和 $y$ 可以是正整数（$x$ 和 $y$ 的大小关系不定）或变量 $n$。$n$ 是一个表示数据规模的变量，在时间复杂度计算中需保留该变量而不能将其视为常数，该数远大于 100。 “E”表示循环体结束。循环体结束时，这个循环体新建的变量也被销毁。 注：本题中为了书写方便，在描述复杂度时，使用大写英文字母“O”表示通常意义下“Θ”的概念。 输入输入文件第一行一个正整数 $t$，表示有 $t$（$t \le 10$）个程序需要计算时间复杂度。 每个程序我们只需抽取其中 F i x y和E即可计算时间复杂度。注意：循环结构允许嵌套。 接下来每个程序的第一行包含一个正整数 $L$ 和一个字符串，$L$ 代表程序行数，字符串表示这个程序的复杂度，O(1)表示常数复杂度，O(n^w)表示复杂度为$n^w$，其中w是一个小于100的正整数（输入中不包含引号），输入保证复杂度只有O(1)和O(n^w) 两种类型。 接下来 $L$ 行代表程序中循环结构中的F i x y或者 E。 程序行若以F开头，表示进入一个循环，之后有空格分离的三个字符（串）i x y， 其中 $i$ 是一个小写字母（保证不为$n$），表示新建的变量名，$x$ 和 $y$ 可能是正整数或 $n$ ，已知若为正整数则一定小于 100。 程序行若以E开头，则表示循环体结束。 输出输出文件共 $t$ 行，对应输入的 $t$ 个程序，每行输出”Yes”或”No”或者”ERR”（输出中不包含引号），若程序实际复杂度与输入给出的复杂度一致则输出”Yes”，不一致则输出”No”，若程序有语法错误（其中语法错误只有: ① F 和 E 不匹配 ②新建的变量与已经存在但未被销毁的变量重复两种情况），则输出”ERR” 。 注意：即使在程序不会执行的循环体中出现了语法错误也会编译错误，要输出 ERR。 样例输入1234567891011121314151617181920212223242526272829303132333482 O(1)F i 1 1E2 O(n^1)F x 1 nE1 O(1)F x 1 n4 O(n^2)F x 5 nF y 10 nEE4 O(n^2)F x 9 nEF y 2 nE4 O(n^1)F x 9 nF y n 4EE4 O(1)F y n 4F x 9 nEE4 O(n^2)F x 1 nF x 1 10EE 样例输出12345678YesYesERRYesNoYesYesERR 输入输出样例解释第一个程序 $i$ 从 1 到 1 是常数复杂度。第二个程序 $x$ 从 1 到 $n$ 是 $n$ 的一次方的复杂度。第三个程序有一个 F 开启循环却没有 E 结束，语法错误。第四个程序二重循环，$n$ 的平方的复杂度。第五个程序两个一重循环，$n$ 的一次方的复杂度。第六个程序第一重循环正常，但第二重循环开始即终止（因为$n$远大于100，100大于4）。第七个程序第一重循环无法进入，故为常数复杂度。第八个程序第二重循环中的变量 $x$ 与第一重循环中的变量重复，出现语法错误②，输出 ERR。 数据规模与约定对于 30%的数据：不存在语法错误，数据保证小明给出的每个程序的前 $L/2$ 行一定为以 F 开头的语句，第 $L/2+1$ 行至第 $L$ 行一定为以 $E$ 开头的语句，$L \le 10$，若 $x$、$y$ 均 为整数，$x$ 一定小于 $y$，且只有 $y$ 有可能为 $n$。对于 50%的数据：不存在语法错误，$L \le 100$，且若 $x$、$y$ 均为整数，$x$ 一定小于 $y$， 且只有 $y$ 有可能为 $n$。对于 70%的数据：不存在语法错误，$L \le 100$。对于 100%的数据：$L \le 100$。 解题思路由于循环必须要让F与E配对，联想到括号匹配问题，所以用栈来模拟。为了方便计算，我在栈里维护了三个值，分别表示当前循环所用变量名、程序执行到当前循环时的复杂度、当前循环是否处于被跳过的循环之中（即程序不会执行到）。在压栈时维护一下这三个值就好了，最后的复杂度即为最大的可被执行到的复杂度。最后，注意一下关于字符串的读入处理就好了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int T, L, kind, w;//kind == 1:O(1); kind == 2: O(n^w)int top, ans;char com[100], opt[100];bool used[1000], err;struct Node&#123; char ch; int c;//执行至此的时间复杂度 bool dir;//是否处于直接跳过的循环中 &#125;sta[1000];void solve()&#123; scanf("%d ", &amp;L); cin.getline(com, 99); if(com[2] == '1') kind = 1; else&#123; int now = 4; while(com[now] &gt;= '0' &amp;&amp; com[now] &lt;= '9')&#123; w = w * 10 + com[now] - '0'; now++; &#125; kind = 2; &#125; for(int i = 1; i &lt;= L; i++)&#123; cin.getline(opt, 99); if(err) continue; if(opt[0] == 'F')&#123; if(used[opt[2]])&#123; err = 1; continue; &#125; used[opt[2]] = 1; int now = 4, l = 0, r = 0, pre = 0, nxt = 0; while((opt[now] &gt;= '0' &amp;&amp; opt[now] &lt;= '9') || opt[now] == 'n')&#123; if(opt[now] == 'n') pre = 1; else l = l * 10 + opt[now] - '0'; now++; &#125; now++; while((opt[now] &gt;= '0' &amp;&amp; opt[now] &lt;= '9') || (opt[now] == 'n'))&#123; if(opt[now] == 'n') nxt = 1; else r = r * 10 + opt[now] - '0'; now++; &#125; if(pre == 1 &amp;&amp; nxt == 1)&#123; sta[top+1] = (Node)&#123;opt[2], sta[top].c, sta[top].dir&#125;; top++; if(sta[top].dir == 0) ans = max(ans, sta[top].c); &#125; else if(pre == 1 &amp;&amp; nxt == 0)&#123; sta[top+1] = (Node)&#123;opt[2], sta[top].c, 1&#125;; top++; &#125; else if(pre == 0 &amp;&amp; nxt == 1)&#123; sta[top+1] = (Node)&#123;opt[2], sta[top].c + 1, sta[top].dir&#125;; top++; if(sta[top].dir == 0) ans = max(ans, sta[top].c); &#125; else if(pre == 0 &amp;&amp; nxt == 0)&#123; if(l &lt;= r)&#123; sta[top+1] = (Node)&#123;opt[2], sta[top].c, sta[top].dir&#125;; top++; if(sta[top].dir == 0) ans = max(ans, sta[top].c); &#125; else&#123; sta[top+1] = (Node)&#123;opt[2], sta[top].c, 1&#125;; top++; &#125; &#125; &#125; else if(opt[0] == 'E')&#123; if(top == 0) err = 1; else&#123; used[sta[top].ch] = 0; top--; &#125; &#125; &#125; if(top) err = 1; if(err)&#123; puts("ERR"); return; &#125; if(kind == 1 &amp;&amp; ans == 0)&#123; puts("Yes"); return; &#125; if(kind == 2 &amp;&amp; w == ans)&#123; puts("Yes"); return; &#125; puts("No"); return;&#125;void init()&#123; memset(sta, 0, sizeof sta); top = 0; memset(com, 0, sizeof com); memset(opt, 0, sizeof opt); memset(used, 0, sizeof used); err = 0; ans = 0; kind = w = 0;&#125;int main()&#123; scanf("%d", &amp;T); while(T--)&#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>模拟</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2017 D1 T1]小凯的疑惑（数论）]]></title>
    <url>%2F2018%2F04%2F14%2FNOIP2017-D1-T1-%E5%B0%8F%E5%87%AF%E7%9A%84%E7%96%91%E6%83%91%EF%BC%88%E6%95%B0%E8%AE%BA%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述小凯手中有两种面值的金币，两种面值均为正整数且彼此互素。每种金币小凯都有 无数个。在不找零的情况下，仅凭这两种金币，有些物品他是无法准确支付的。现在小凯想知道在无法准确支付的物品中，最贵的价值是多少金币？注意：输入数据保证存在小凯无法准确支付的商品。 输入输入数据仅一行，包含两个正整数 $a$ 和 $ b $，它们之间用一个空格隔开，表示小凯手 中金币的面值。 输出输出文件仅一行，一个正整数 $ N $，表示不找零的情况下，小凯用手中的金币不能准确支付的最贵的物品的价值。 样例输入13 7 样例输出111 样例说明小凯手中有面值为3和7的金币无数个，在不找零的前提下无法准确支付价值为1、 2、4、5、8、11 的物品，其中最贵的物品价值为 11，比 11 贵的物品都能买到，比如：$ 12 = 3 \times 4 + 7 \times 0 $$ 13 = 3 \times 2 + 7 \times 1 $$ 14 = 3 \times 0 + 7 \times 2 $$ 15 = 3 \times 5 + 7 \times 0 $ 数据范围与约定对于 30%的数据： $ 1 \le a,b \le 50 $。对于 60%的数据： $ 1 \le a,b \le 10^4 $。对于 100%的数据：$ 1 \le a,b \le 10^9 $。 解题思路因为$ (a,b) = 1 $，所以$ \{a, 2a, 3a, …, (b-1)a\} $为模$ b $的完全剩余系。设$ T $是一个$ a, b $无法表示的数且$ T \equiv ka(mod \ b) $，$ (1 \le k \le b-1) $.若$ T \ge ka $，则$ T $一定可以表示为$ ka+nb $，$ (n \ge 0) $，所以$ T &lt; ka $，则此时$ T $最大为$ ka-b $.显然，当$ k $最大时$ T $最大，所以$ T = (b-1)a-b = ab - a - b $. Code123456789#include&lt;cstdio&gt;using namespace std;typedef long long LL;LL a, b;int main()&#123; scanf("%lld%lld", &amp;a, &amp;b); printf("%lld", a * b - a - b); return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello, world!]]></title>
    <url>%2F2018%2F04%2F07%2FHello-world-0%2F</url>
    <content type="text"><![CDATA[搞了一个下午+一个晚上，终于把hexo+github博客搭建起来了……（尚待后续优化） 这个博客用于几个板块：OI/ACM 学习笔记（主要），学习总结，随笔，其他 12break?continue!]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
