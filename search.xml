<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>[Codeforces 940E]Cashback（动态规划，单调队列，贪心）</title>
      <link href="/2018/04/30/Codeforces-940E-Cashback%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E8%B4%AA%E5%BF%83%EF%BC%89/"/>
      <url>/2018/04/30/Codeforces-940E-Cashback%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E8%B4%AA%E5%BF%83%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="E-Cashback"><a href="#E-Cashback" class="headerlink" title="E. Cashback"></a>E. Cashback</h2><p>time limit per test: 2 seconds<br>memory limit per test: 256 megabytes<br>input: standard input<br>output: standard output</p><p><em>Since you are the best Wraith King, Nizhniy Magazin <mir> at the centre of Vinnytsia is offering you a discount.</mir></em><br>You are given an array $a$ of length $n$ and an integer $c$.<br>The value of some array $b$ of length $k$ is the sum of its elements except for the $\lfloor \frac{k}{c} \rfloor$ smallest. For example, the value of the array $[3,1,6,5,2]$ with $c=2$ is $3+6+5=14$.<br>Among all possible partitions of a into contiguous subarrays output the smallest possible sum of the values of these subarrays.</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>The first line contains integers n and c ($1≤n,c≤100000$).<br>The second line contains n integers ai ($1≤a_i≤10^9$) — elements of a.</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>Output a single integer  — the smallest possible sum of values of these subarrays of some partition of $a$.</p><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><div class="table-container"><table><thead><tr><th>input</th><th>output</th></tr></thead><tbody><tr><td>3 5<br>1 2 3</td><td>6</td></tr><tr><td>12 10<br>1 1 10 10 10 10 10 10 9 10 10 10</td><td>92</td></tr><tr><td>7 2<br>2 3 6 4 5 7 1</td><td>17</td></tr><tr><td>8 4<br>1 3 4 5 5 3 4 1</td><td>23</td></tr></tbody></table></div><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><p>In the first example any partition yields 6 as the sum.<br>In the second example one of the optimal partitions is $[1,1],[10,10,10,10,10,10,9,10,10,10]$ with the values 2 and 90 respectively.<br>In the third example one of the optimal partitions is $[2,3],[6,4,5,7],[1]$ with the values 3, 13 and 1 respectively.<br>In the fourth example one of the optimal partitions is $[1],[3,4,5,5,3,4],[1]$ with the values 1, 21 and 1 respectively.</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这当然是一道dp题。<br>我们先设$dp[i]$表示前$i$个数字划分后的最小代价，那么转移就是$dp[i]=min{dp[k]+cal(k+1, i)\ |\ 1 \leqslant k &lt; i}$，其中$cal(l, r)$是计算$l$到$r$作为整体时的代价。<br>复杂度？$cal(l,r)$可以用multiset之类的做到$O(\log n)$完成，但是dp方程里面有两层循环，所以复杂度高达$O(n^2\log n)$，差远了。</p><p>怎么优化呢？这里我们可以发现一个贪心：划分的每一块长度要么是1，要么是c。证明：如果块的长度小于c，那么代价是所有值的和，与把这些值划分成一份一份的等价；如果块的长度大于c，我们把它们划分成几个长为c或1的块，答案一定不会更差（去除数量相同，但区间更小，更有机会去除掉大一点的数，手动模拟一下就知道了）。<br>综上所述，我们的dp长这样：</p><ul><li>dp状态：$dp[i]$表示前$i$个数字划分后的最小代价</li><li>dp方程：$dp[i] = min\big(dp[i-1] + a[i], dp[i-c] + sum(i-c+1, i) - min(i-c+1, i)\big)$<br>由于长为c的段只会去除最小的值，所以上文中的$cal()$变成了此处的$min()$<br>sum(l,r)表示$l$到$r$的和，可以前缀和优化到$O(1)$<br>min(l,r)表示$l$到$r$的最小值，由于$l$~$r$长度固定为c，所以可以单调队列$O(n)$的预处理出来</li><li>dp顺序：由dp方程可知，$i$从小到大for即可</li><li>边界条件：$dp[0] = 0$</li></ul><p>时间复杂度 $O(n)$</p><hr><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n, c, hd, tl;</span><br><span class="line">LL a[N], sum[N], mnC[N], dp[N];</span><br><span class="line">pair&lt;LL, <span class="keyword">int</span>&gt; q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;c);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">sum[i] = sum[i<span class="number">-1</span>] + a[i];</span><br><span class="line"><span class="keyword">while</span>(hd &lt; tl &amp;&amp; q[tl<span class="number">-1</span>].first &gt; a[i])tl--;</span><br><span class="line">q[tl++] = make_pair(a[i], i);</span><br><span class="line"><span class="keyword">while</span>(hd &lt; tl &amp;&amp; q[hd].second &lt;= max(i - c, <span class="number">0</span>))hd++;</span><br><span class="line">mnC[i] = q[hd].first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0x7f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">dp[i] = dp[i<span class="number">-1</span>] + a[i];</span><br><span class="line"><span class="keyword">if</span>(i - c &gt;= <span class="number">0</span>)dp[i] = min(dp[i], dp[i-c] + sum[i] - sum[i-c] - mnC[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>, dp[n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 动态规划 </category>
          
          <category> 数据结构 </category>
          
          <category> 队列 </category>
          
          <category> 单调队列 </category>
          
          <category> 贪心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[NOIP2017 D2 T3]列队（线段树/平衡树）</title>
      <link href="/2018/04/30/NOIP2017-D2-T3-%E5%88%97%E9%98%9F%EF%BC%88%E7%BA%BF%E6%AE%B5%E6%A0%91-%E5%B9%B3%E8%A1%A1%E6%A0%91%EF%BC%89/"/>
      <url>/2018/04/30/NOIP2017-D2-T3-%E5%88%97%E9%98%9F%EF%BC%88%E7%BA%BF%E6%AE%B5%E6%A0%91-%E5%B9%B3%E8%A1%A1%E6%A0%91%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Sylvia 是一个热爱学习的女♂孩子。<br>前段时间，Sylvia 参加了学校的军训。众所周知，军训的时候需要站方阵。<br>Sylvia 所在的方阵中有$n \times m$名学生，方阵的行数为 $n$，列数为 $m$。<br>为了便于管理，教官在训练开始时，按照从前到后，从左到右的顺序给方阵中 的学生从 1 到 $n \times m$ 编上了号码（参见后面的样例）。即：初始时，第 $i$ 行第 $j$ 列 的学生的编号是$(i-1)\times m + j$。<br>然而在练习方阵的时候，经常会有学生因为各种各样的事情需要离队。在一天 中，一共发生了 $q$件这样的离队事件。每一次离队事件可以用数对$(x,y) (1 \le x \le n, 1 \le y \le m)$描述，表示第 $x$ 行第 $y$ 列的学生离队。<br>在有学生离队后，队伍中出现了一个空位。为了队伍的整齐，教官会依次下达 这样的两条指令：</p><ol><li>向左看齐。这时第一列保持不动，所有学生向左填补空缺。不难发现在这条 指令之后，空位在第 $x$ 行第 $m$ 列。</li><li>向前看齐。这时第一行保持不动，所有学生向前填补空缺。不难发现在这条 指令之后，空位在第 $n$ 行第 $m$ 列。</li></ol><p>教官规定不能有两个或更多学生同时离队。即在前一个离队的学生归队之后， 下一个学生才能离队。因此在每一个离队的学生要归队时，队伍中有且仅有第 $n$ 行 第 $m$ 列一个空位，这时这个学生会自然地填补到这个位置。<br>因为站方阵真的很无聊，所以 Sylvia 想要计算每一次离队事件中，离队的同学 的编号是多少。<br>注意：每一个同学的编号不会随着离队事件的发生而改变，在发生离队事件后 方阵中同学的编号可能是乱序的。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>输入共 $q+1$行。<br>第 1 行包含 3 个用空格分隔的正整数 $n, m, q$，表示方阵大小是 $n$ 行 $m$ 列，一共发 生了 $q$ 次事件。<br>接下来 $q$ 行按照事件发生顺序描述了 $q$ 件事件。每一行是两个整数 $x, y$，用一个空 格分隔，表示这个离队事件中离队的学生当时排在第 $x$ 行第 $y$ 列。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>按照事件输入的顺序，每一个事件输出一行一个整数，表示这个离队事件中离队学 生的编号。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 2 3</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h2><p>$n,m,q \leq 3 \times 10^5$<br>数据保证每一个事件满足 $1 \le x \le n,1 \le y \le m$</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>一道数据结构的好题。<br>首先我们发现，每次操作只会更改某一行和最后一列的状态，那么我们可以单独把最后一列拿出来用一个数据结构维护，再用$n$个数据结构维护每一行的前$m-1$个元素。<br>那用什么数据结构好呢？</p><h2 id="一、线段树"><a href="#一、线段树" class="headerlink" title="一、线段树"></a>一、线段树</h2><p>线段树是最容易想到的，共开$n+1$颗线段树，前$n$颗维护每行前$m-1$个元素，第$n+1$颗维护最后一列的元素。<br>每次对$(x,y)$操作都可以转化为一个基本操作：从一颗线段树里面拿出一个元素加到一颗线段树的末尾，具体来说：</p><ul><li>如果$y = m$，只需要从“列线段树”里<strong>拿出</strong>第$x$个元素加到它本身末尾</li><li>否则，从第$x$颗“行线段树”里<strong>拿出</strong>第$y$个元素加到“列线段树”末尾，再从“列线段树”里<strong>拿出</strong>第$x$个元素加到“行线段树”末尾</li></ul><p>所谓的<strong>“拿出”</strong>操作就是一个在线段树上二分查找的过程，为此我们要在线段树每个节点上记录一个size，<strong>表示当前节点表示的区间里面还剩多少个元素</strong>。<br>另外，每颗线段树要多开$q$的区间长度（想想操作过程就明白了）。</p><p>但是，以上并不是这道题的难点，这道题的特殊之处在于你无法直接开满$n+1$颗线段树！<br>怎么办呢，我们可以<strong>动态开点</strong>来解决，也就是说当你要用某个点时再开它（想想主席树）。这样我们只需要$NlogN$的空间就够了。</p><p>时间复杂度 $O(q\log (n+q))$</p><h2 id="二、平衡树"><a href="#二、平衡树" class="headerlink" title="二、平衡树"></a>二、平衡树</h2><p>既然线段树可以，平衡树当然也可以了！<br>同样的思路：每次操作都可以转化为从一颗平衡树上二分查找第k大的值，把它加到一颗平衡树的末尾。</p><p>怎么解决空间问题？由于有一些人至始至终都站在一起，我们可以在平衡树上只用一个节点表示这个区间$[l,r]$（编号从$l$到$r$的人），当我们发现这个区间中的某个人（如编号为$k$的人）要离队时，再把它split成两个小区间（$[l,k-1],[k+1,r]$），输出$k$，这样就能保证空间复杂度为 $NlogN$。</p><p>时间复杂度$O(q\log n)$</p><h2 id="三、树状数组"><a href="#三、树状数组" class="headerlink" title="三、树状数组"></a>三、树状数组</h2><p>有待学习…</p><hr><h1 id="Code-1（线段树）"><a href="#Code-1（线段树）" class="headerlink" title="Code#1（线段树）"></a>Code#1（线段树）</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300005</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, q, qx, qy, p[N], root[N];</span><br><span class="line">LL t;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> son[<span class="number">2</span>];</span><br><span class="line">LL val, size;</span><br><span class="line">&#125;tr[N*<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OPT_segTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> kind)</span></span>&#123;</span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">int</span> temp = (kind == <span class="number">0</span> ? m - <span class="number">1</span> : n);</span><br><span class="line"><span class="keyword">if</span>(l &lt;= temp &amp;&amp; r &lt;= temp)tr[cnt].size = r - l + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(l &lt;= temp &amp;&amp; r &gt; temp)tr[cnt].size = temp - l + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(l &gt; temp &amp;&amp; r &gt; temp)tr[cnt].size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">tr[id].size = tr[tr[id].son[<span class="number">0</span>]].size + tr[tr[id].son[<span class="number">1</span>]].size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">getKth</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> l, <span class="keyword">int</span> r, LL k, <span class="keyword">int</span> kind)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line"><span class="keyword">if</span>(!tr[id].val)&#123;</span><br><span class="line"><span class="keyword">if</span>(kind == <span class="number">0</span>)tr[id].val = <span class="number">1l</span>l * (qx - <span class="number">1</span>) * m + l;</span><br><span class="line"><span class="keyword">else</span>tr[id].val = <span class="number">1l</span>l * l * m;</span><br><span class="line">&#125;</span><br><span class="line">tr[id].size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> tr[id].val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!tr[id].son[<span class="number">0</span>])tr[id].son[<span class="number">0</span>] = newNode(l, mid, kind);</span><br><span class="line"><span class="keyword">if</span>(!tr[id].son[<span class="number">1</span>])tr[id].son[<span class="number">1</span>] = newNode(mid+<span class="number">1</span>, r, kind);</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(tr[tr[id].son[<span class="number">0</span>]].size &gt;= k)res = getKth(tr[id].son[<span class="number">0</span>], l, mid, k, kind);</span><br><span class="line"><span class="keyword">else</span>res = getKth(tr[id].son[<span class="number">1</span>], mid+<span class="number">1</span>, r, k - tr[tr[id].son[<span class="number">0</span>]].size, kind);</span><br><span class="line">pushup(id);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos, LL val, <span class="keyword">int</span> kind)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">tr[id].val = val;</span><br><span class="line">tr[id].size = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!tr[id].son[<span class="number">0</span>])tr[id].son[<span class="number">0</span>] = newNode(l, mid, kind);</span><br><span class="line"><span class="keyword">if</span>(!tr[id].son[<span class="number">1</span>])tr[id].son[<span class="number">1</span>] = newNode(mid+<span class="number">1</span>, r, kind);</span><br><span class="line"><span class="keyword">if</span>(pos &lt;= mid)insert(tr[id].son[<span class="number">0</span>], l, mid, pos, val, kind);</span><br><span class="line"><span class="keyword">else</span>insert(tr[id].son[<span class="number">1</span>], mid+<span class="number">1</span>, r, pos, val, kind);</span><br><span class="line">pushup(id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;Seg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)p[i] = m - <span class="number">1</span>;</span><br><span class="line">p[n+<span class="number">1</span>] = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)root[i] = Seg.newNode(<span class="number">1</span>, m - <span class="number">1</span> + q, <span class="number">0</span>);</span><br><span class="line">root[n+<span class="number">1</span>] = Seg.newNode(<span class="number">1</span>, n + q, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;qx, &amp;qy);</span><br><span class="line"><span class="keyword">if</span>(qy == m)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, t = Seg.getKth(root[n+<span class="number">1</span>], <span class="number">1</span>, n + q, qx, <span class="number">1</span>));</span><br><span class="line">Seg.insert(root[n+<span class="number">1</span>], <span class="number">1</span>, n + q, ++p[n+<span class="number">1</span>], t, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, t = Seg.getKth(root[qx], <span class="number">1</span>, m - <span class="number">1</span> + q, qy, <span class="number">0</span>));</span><br><span class="line">Seg.insert(root[n+<span class="number">1</span>], <span class="number">1</span>, n + q, ++p[n+<span class="number">1</span>], t, <span class="number">1</span>);</span><br><span class="line">t = Seg.getKth(root[n+<span class="number">1</span>], <span class="number">1</span>, n + q, qx, <span class="number">1</span>);</span><br><span class="line">Seg.insert(root[qx], <span class="number">1</span>, m - <span class="number">1</span> + q, ++p[qx], t, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Code-2（Splay）"><a href="#Code-2（Splay）" class="headerlink" title="Code#2（Splay）"></a>Code#2（Splay）</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300005</span>;</span><br><span class="line"><span class="keyword">int</span> qx, qy, rt[N];</span><br><span class="line">LL t, n, m, q;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Splay</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> son[<span class="number">2</span>], fa;</span><br><span class="line">LL val, l, r, size;</span><br><span class="line">&#125;tr[N*<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OPT_Splay</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">tr[id].size = tr[id].r - tr[id].l + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(tr[id].son[<span class="number">0</span>])tr[id].size += tr[tr[id].son[<span class="number">0</span>]].size;</span><br><span class="line"><span class="keyword">if</span>(tr[id].son[<span class="number">1</span>])tr[id].size += tr[tr[id].son[<span class="number">1</span>]].size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">newNode</span><span class="params">(LL l, LL r)</span></span>&#123;</span><br><span class="line">cnt++;</span><br><span class="line">tr[cnt].fa = tr[cnt].son[<span class="number">0</span>] = tr[cnt].son[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">tr[cnt].size = (tr[cnt].r = r) - (tr[cnt].l = l) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> kind)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> y = tr[x].fa, z = tr[y].fa, A = tr[y].son[kind], B = tr[x].son[kind], C = tr[x].son[!kind];</span><br><span class="line">tr[x].son[kind] = y, tr[x].fa = z;</span><br><span class="line">tr[y].fa = x, tr[y].son[!kind] = B;</span><br><span class="line">tr[z].son[tr[z].son[<span class="number">1</span>] == y] = x, tr[B].fa = y;</span><br><span class="line">pushup(y), pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> &amp;root, <span class="keyword">int</span> x, <span class="keyword">int</span> goal)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x == goal)<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">while</span>(tr[x].fa != goal)&#123;</span><br><span class="line"><span class="keyword">int</span> y = tr[x].fa, z = tr[y].fa;</span><br><span class="line"><span class="keyword">int</span> isrson1 = tr[y].son[<span class="number">1</span>] == x, isrson2 = tr[z].son[<span class="number">1</span>] == y;</span><br><span class="line"><span class="keyword">if</span>(z == goal)rotate(x, !isrson1);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(isrson1 == isrson2)rotate(y, !isrson2);</span><br><span class="line"><span class="keyword">else</span>rotate(x, !isrson1);</span><br><span class="line">rotate(x, !isrson2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(goal == <span class="number">0</span>)root = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">selectLast</span><span class="params">(<span class="keyword">int</span> &amp;root)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> now = root;</span><br><span class="line"><span class="keyword">while</span>(tr[now].son[<span class="number">1</span>])now = tr[now].son[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;root, LL val)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = newNode(val, val);</span><br><span class="line"><span class="keyword">int</span> pos = selectLast(root);</span><br><span class="line">tr[pos].son[<span class="number">1</span>] = temp;</span><br><span class="line">tr[temp].fa = pos;</span><br><span class="line">splay(root, temp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">split</span><span class="params">(<span class="keyword">int</span> &amp;root, <span class="keyword">int</span> now, LL k)</span></span>&#123;</span><br><span class="line">splay(root, now, <span class="number">0</span>);</span><br><span class="line">k += tr[now].l - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> temp = newNode(k+<span class="number">1</span>, tr[now].r);</span><br><span class="line">tr[now].r = k - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!tr[now].son[<span class="number">1</span>])&#123;</span><br><span class="line">tr[now].son[<span class="number">1</span>] = temp;</span><br><span class="line">tr[temp].fa = now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">tr[temp].son[<span class="number">1</span>] = tr[now].son[<span class="number">1</span>];</span><br><span class="line">tr[tr[temp].son[<span class="number">1</span>]].fa = temp;</span><br><span class="line">tr[now].son[<span class="number">1</span>] = temp;</span><br><span class="line">tr[temp].fa = now;</span><br><span class="line">&#125;</span><br><span class="line">pushup(temp), pushup(now);</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">getKth</span><span class="params">(<span class="keyword">int</span> &amp;root, LL k)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> now = root;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(k &lt;= tr[tr[now].son[<span class="number">0</span>]].size)now = tr[now].son[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">k -= tr[tr[now].son[<span class="number">0</span>]].size;</span><br><span class="line"><span class="keyword">if</span>(k &lt;= tr[now].r - tr[now].l + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> split(root, now, k);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">k -= (tr[now].r - tr[now].l + <span class="number">1</span>);</span><br><span class="line">now = tr[now].son[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;BST;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)rt[i] = BST.newNode((i - <span class="number">1</span>) * m + <span class="number">1</span>, i * m - <span class="number">1</span>);</span><br><span class="line">rt[n+<span class="number">1</span>] = BST.newNode(m, m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)BST.insert(rt[n+<span class="number">1</span>], i * m);</span><br><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;qx, &amp;qy);</span><br><span class="line"><span class="keyword">if</span>(qy == m)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, t = BST.getKth(rt[n+<span class="number">1</span>], qx));</span><br><span class="line">BST.insert(rt[n+<span class="number">1</span>], t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, t = BST.getKth(rt[qx], qy));</span><br><span class="line">BST.insert(rt[n+<span class="number">1</span>], t);</span><br><span class="line">BST.insert(rt[qx], BST.getKth(rt[n+<span class="number">1</span>], qx));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 线段树 </category>
          
          <category> 平衡树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NOIP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[NOIP2017 D2 T2]宝藏（状压dp）</title>
      <link href="/2018/04/30/NOIP2017-D2-T2-%E5%AE%9D%E8%97%8F%EF%BC%88%E7%8A%B6%E5%8E%8Bdp%EF%BC%89/"/>
      <url>/2018/04/30/NOIP2017-D2-T2-%E5%AE%9D%E8%97%8F%EF%BC%88%E7%8A%B6%E5%8E%8Bdp%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>参与考古挖掘的小明得到了一份藏宝图，藏宝图上标出了 $n$ 个深埋在地下的宝藏屋， 也给出了这 $n$ 个宝藏屋之间可供开发的 $m$ 条道路和它们的长度。</p><p>小明决心亲自前往挖掘所有宝藏屋中的宝藏。但是，每个宝藏屋距离地面都很远， 也就是说，从地面打通一条到某个宝藏屋的道路是很困难的，而开发宝藏屋之间的道路 则相对容易很多。</p><p>小明的决心感动了考古挖掘的赞助商，赞助商决定免费赞助他打通一条从地面到某 个宝藏屋的通道，通往哪个宝藏屋则由小明来决定。</p><p>在此基础上，小明还需要考虑如何开凿宝藏屋之间的道路。已经开凿出的道路可以 任意通行不消耗代价。每开凿出一条新道路，小明就会与考古队一起挖掘出由该条道路 所能到达的宝藏屋的宝藏。另外，小明不想开发无用道路，即两个已经被挖掘过的宝藏 屋之间的道路无需再开发。<br>新开发一条道路的代价是：</p><script type="math/tex; mode=display">L \times K</script><p>$L$代表这条道路的长度，$K$代表从赞助商帮你打通的宝藏屋到这条道路起点的宝藏屋所经过的 宝藏屋的数量（包括赞助商帮你打通的宝藏屋和这条道路起点的宝藏屋） 。</p><p>请你编写程序为小明选定由赞助商打通的宝藏屋和之后开凿的道路，使得工程总代价最小，并输出这个最小值。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>第一行两个用空格分离的正整数 $n$ 和 $m$，代表宝藏屋的个数和道路数。</p><p>接下来 $m$ 行，每行三个用空格分离的正整数，分别是由一条道路连接的两个宝藏 屋的编号（编号为 $1$~$n$），和这条道路的长度 $v$。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>输出共一行，一个正整数，表示最小的总代价。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><p>样例输入1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4 5 </span><br><span class="line">1 2 1 </span><br><span class="line">1 3 3 </span><br><span class="line">1 4 1 </span><br><span class="line">2 3 4 </span><br><span class="line">3 4 1</span><br></pre></td></tr></table></figure></p><p>样例输入2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4 5 </span><br><span class="line">1 2 1 </span><br><span class="line">1 3 3 </span><br><span class="line">1 4 1 </span><br><span class="line">2 3 4 </span><br><span class="line">3 4 2</span><br></pre></td></tr></table></figure></p><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><p>样例输出1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure></p><p>样例输出2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure></p><h2 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h2><p>对于 20% 的数据： 保证输入是一棵树，$1 \le n \le 8$ , $v \le 5000$ 且所有的 v 都相等。<br>对于 40% 的数据： $1 \le n \le 8$，$0 \le m \le 1000$ , $v \le 5000$ 且所有的 v 都相等。<br>对于 70% 的数据： $1 \le n \le 8$，$0 \le m \le 1000$，$v \le 5000$<br>对于 100% 的数据： $1 \le n \le 12$，$0 \le m \le 1000$ , $v \le 500000$</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先，很容易发现打通后的道路一定是一棵树，并且，若以起点为根并令其深度为$0$，则题目中的 $K$ 即为这条路所连向的点的深度。</p><p>观察数据范围，$n \le 12$，显然是状压dp：</p><ul><li><strong>dp状态</strong>：$dp[i][S]$ 表示考虑到树的第$i$层，前$i$层已选的点的集合为$S$（二进制状压）的最小代价。</li><li><strong>dp方程</strong>（刷表法）：<br> 已知$dp[i][S]$时，可枚举所有由不在$S$中的点构成的集合作为第$i+1$层，则状态转移为<script type="math/tex">dp[i][S] \to dp[i+1][S|S'] + (i+1) \times \Sigma \  min\{G[a][b]|a \in S , b \in S',S \cap S' = \emptyset \}</script><br> 简单一点，就是<script type="math/tex">dp[i][S] \to dp[i+1][S|S'] + (i+1) \times sval[S'][S] \}</script><br> 其中$sval[A][B]$表示集合A到集合B的最短距离，即集合A中所有点到集合B的最短距离之和。可以先预处理出每个点到每个集合的最短距离$pval[i][S]$（也就是点$i$到集合$S$中所有点的距离的最小值），然后用$pval[i][B]$更新$sval[A][B]$。</li><li><strong>dp顺序</strong>：由dp方程可得：从小到大枚举层数，再枚举集合即可</li><li><strong>边界条件</strong>：枚举根节点，设为$root$，则$dp[0][1&lt;&lt;(root-1)] = 0$</li></ul><h1 id="状压相关技巧"><a href="#状压相关技巧" class="headerlink" title="状压相关技巧"></a>状压相关技巧</h1><ul><li>若$S$是$U$的子集，则$S$关于$U$的补集：$S ^\wedge U$</li><li>判断点$k$是否在集合$S$中（即$S$的第$k-1$位是否为$1$）：<code>S &amp; (1 &lt;&lt; (k-1)) ！= 0 ? &quot;Yes&quot; : &quot;No&quot;;</code></li><li>枚举$S$的子集：<code>for(int i = S; i; i = (i - 1) &amp; S){...}</code></li></ul><hr><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">13</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, g[N][N], u, v, p, U;</span><br><span class="line">LL dp[N][<span class="number">1</span>&lt;&lt;N], ans = <span class="number">1e14</span>, sval[<span class="number">1</span>&lt;&lt;N][<span class="number">1</span>&lt;&lt;N], pval[N][<span class="number">1</span>&lt;&lt;N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= U; j++)</span><br><span class="line">            dp[i][j] = INF;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>&lt;&lt;(root<span class="number">-1</span>)] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    U = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//initialize g[i][j]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(i ^ j)</span><br><span class="line">                g[i][j] = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= U; j++)</span><br><span class="line">            pval[i][j] = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= U; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= U; j++)</span><br><span class="line">            sval[i][j] = INF;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;p);</span><br><span class="line">        g[u][v] = min(g[u][v], p);</span><br><span class="line">        g[v][u] = min(g[v][u], p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//initialize pval[i][S]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= U; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">                <span class="keyword">if</span>(j &amp; (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>)))</span><br><span class="line">                    pval[i][j] = min(pval[i][j], <span class="number">1l</span>l*g[i][k]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= U; i++)&#123;<span class="comment">//initialize sval[A][B]</span></span><br><span class="line">        <span class="keyword">int</span> C = i ^ U;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s = C; s; s = (s - <span class="number">1</span>) &amp; C)&#123;</span><br><span class="line">            LL temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                <span class="keyword">if</span>(s &amp; (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>)))</span><br><span class="line">                    temp += pval[j][i];</span><br><span class="line">            sval[s][i] = temp &gt;= INF ? INF : temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> root = <span class="number">1</span>; root &lt;= n; root++)&#123;<span class="comment">//dp</span></span><br><span class="line">        init(root);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">0</span>; S &lt;= U; S++)</span><br><span class="line">                <span class="keyword">if</span>(dp[i][S] != INF)&#123;</span><br><span class="line">                    <span class="keyword">int</span> C = S ^ U;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> s = C; s; s = (s - <span class="number">1</span>) &amp; C)</span><br><span class="line">                        dp[i+<span class="number">1</span>][S|s] = min(dp[i+<span class="number">1</span>][S|s], dp[i][S] + (i + <span class="number">1</span>) * sval[s][S]);</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)ans = min(ans, dp[i][U]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 动态规划 </category>
          
          <category> 状压dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NOIP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[NOIP2017 D2 T1]奶酪（并查集）</title>
      <link href="/2018/04/30/NOIP2017-D2-T1-%E5%A5%B6%E9%85%AA%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89/"/>
      <url>/2018/04/30/NOIP2017-D2-T1-%E5%A5%B6%E9%85%AA%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>现有一块大奶酪，它的高度为 $h$，它的长度和宽度我们可以认为是无限大的，奶酪中间有许多半径相同的球形空洞。我们可以在这块奶酪中建立空间坐标系，在坐标系中，奶酪的下表面为$z=0$，奶酪的上表面为$z = h$。<br>现在，奶酪的下表面有一只小老鼠 Jerry，它知道奶酪中所有空洞的球心所在的坐 标。如果两个空洞相切或是相交，则 Jerry 可以从其中一个空洞跑到另一个空洞，特别地，如果一个空洞与下表面相切或是相交，Jerry 则可以从奶酪下表面跑进空洞；如果一个空洞与上表面相切或是相交，Jerry 则可以从空洞跑到奶酪上表面。<br>位于奶酪下表面的 Jerry 想知道，在不破坏奶酪的情况下，能否利用已有的空洞跑到奶酪的上表面去?<br>空间内两点$P_1(x_1,y_1,z_1)$、$P2(x_2,y_2,z_2)$的距离公式如下：</p><script type="math/tex; mode=display">\mathrm{dist}(P_1,P_2)=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}</script><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>每个输入文件包含多组数据。<br>输入文件的第一行，包含一个正整数 $T$，代表该输入文件中所含的数据组数。<br>接下来是 $T$ 组数据，每组数据的格式如下： 第一行包含三个正整数 $n,h$ 和 $r$，两个数之间以一个空格分开，分别代表奶酪中空洞的数量，奶酪的高度和空洞的半径。<br>接下来的 $n$ 行，每行包含三个整数 $x,y,z$，两个数之间以一个空格分开，表示空洞球心坐标为$(x,y,z)$。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>输出文件包含 $T$ 行，分别对应 $T$ 组数据的答案，如果在第 $i$ 组数据中，Jerry 能从下表面跑到上表面，则输出 “Yes”，如果不能，则输出 “No” （均不包含引号）。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">3 </span><br><span class="line">2 4 1 </span><br><span class="line">0 0 1 </span><br><span class="line">0 0 3 </span><br><span class="line">2 5 1 </span><br><span class="line">0 0 1 </span><br><span class="line">0 0 4 </span><br><span class="line">2 5 2 </span><br><span class="line">0 0 2 </span><br><span class="line">2 0 4</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><p>对于 20%的数据，$n = 1$，$1 \le h,r \le 10,000$，坐标的绝对值不超过 10,000。</p><p>对于 40%的数据，$1 \le n \le 8$， $1 \le h,r \le 10,000$，坐标的绝对值不超过 10,000。</p><p>对于80%的数据， $1 \le n \le 1,000$， $1 \le h , r \le 10,000$，坐标的绝对值不超过10,000。</p><p>对于 100%的数据，$1 \le n \le 1,000$，$1 \le h , r \le 1,000,000,000$，$T \le 20$，坐标的绝对值不超过 1,000,000,000。</p><hr><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>设下底面为点$S=n+1$，上底面为点$T=n+2$，枚举两个点看它们是否连通，连通即将它们用并查集并起来，最后看$S$与$T$是否连通即可。</p><hr><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> LB;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> CASES, n, h, S, T;</span><br><span class="line">LL r;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line">&#125;node[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LB <span class="title">dist</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((LB)(node[a].x-node[b].x)*(node[a].x-node[b].x)+(LB)(node[a].y-node[b].y)*(node[a].y-node[b].y)+(LB)(node[a].z-node[b].z)*(node[a].z-node[b].z));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n+<span class="number">2</span>; i++)fa[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findfa</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x] != x)fa[x] = findfa(fa[x]);</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionn</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    fa[findfa(y)] = findfa(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;CASES);</span><br><span class="line">    <span class="keyword">while</span>(CASES--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>, &amp;n, &amp;h, &amp;r);</span><br><span class="line">        init();</span><br><span class="line">        S = n + <span class="number">1</span>, T = n + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;node[i].x, &amp;node[i].y, &amp;node[i].z);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dist(i, j) &lt;= <span class="number">2</span> * r &amp;&amp; findfa(i) != findfa(j))</span><br><span class="line">                    unionn(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node[i].z + r &gt;= h)unionn(i, T);</span><br><span class="line">            <span class="keyword">if</span>(node[i].z - r &lt;= <span class="number">0</span>)unionn(i, S);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(findfa(T) == findfa(S))<span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">        <span class="keyword">else</span><span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 并查集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NOIP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>普通平衡树/文艺平衡树/二逼平衡树</title>
      <link href="/2018/04/30/%E6%99%AE%E9%80%9A%E5%B9%B3%E8%A1%A1%E6%A0%91-%E6%96%87%E8%89%BA%E5%B9%B3%E8%A1%A1%E6%A0%91-%E4%BA%8C%E9%80%BC%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
      <url>/2018/04/30/%E6%99%AE%E9%80%9A%E5%B9%B3%E8%A1%A1%E6%A0%91-%E6%96%87%E8%89%BA%E5%B9%B3%E8%A1%A1%E6%A0%91-%E4%BA%8C%E9%80%BC%E5%B9%B3%E8%A1%A1%E6%A0%91/</url>
      <content type="html"><![CDATA[<h1 id="普通平衡树"><a href="#普通平衡树" class="headerlink" title="普通平衡树"></a>普通平衡树</h1><p>题目链接：<br><a href="https://www.luogu.org/problemnew/show/3369" target="_blank" rel="noopener">luogu3369</a><br><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3224" target="_blank" rel="noopener">bzoj3224</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>平衡树模板题，我分别用了 [非旋Treap] 和 [Splay] AC了本题。</p><h3 id="一、Splay"><a href="#一、Splay" class="headerlink" title="一、Splay"></a>一、Splay</h3><p>每个节点表示一个值，同时记录该点及其子树大小、该点表示的值的出现次数、左右儿子、父节点。</p><ul><li>插入：将x前驱旋至根，x后继旋至根的右儿子，那么根的左儿子的右儿子即为要插入的位置，如果此位置上无数，则新建一个节点；否则该位置的出现次数和大小加1。<ul><li><strong>注意：为了避免找不到x前驱和后继，应事先插入一个值为-INF和值为INF的节点。</strong></li></ul></li><li>删除：将x前驱旋至根，x后继旋至根的右儿子，那么根的左儿子的右儿子即为要删除的节点，如果此节点大小为1，直接删除；否则该位置的出现次数和大小减1。</li><li>查x排名：将x旋至根，则x排名为根的左儿子大小+1</li><li>查排名为x的数：从根向下查找，如果当前节点的左儿子大小+1=x，则返回当前节点的值；否则，如果当前节点的左儿子大小$\geq$x，则向其右儿子查找；否则，向其左儿子查找。</li><li>求x前驱：从根向下查找，如果当前节点的值小于等于x，更新ans并向其右儿子查找；否则，向其左儿子查找。更新时，不断取max即可。</li><li>求x后继：从根向下查找，如果当前节点的值大于等于x，更新ans并向其左儿子查找；否则，向其右儿子查找。更新时，不断取min即可。</li></ul><p>时间复杂度：每次操作 $O(log_2n)$</p><h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code#1"></a>Code#1</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n, opt, q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>, root = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Splay_tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fa, son[<span class="number">2</span>], size, val, times;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x)&#123;</span><br><span class="line">        tr[x].size = tr[x].times;</span><br><span class="line">        <span class="keyword">if</span>(tr[x].son[<span class="number">0</span>])tr[x].size += tr[tr[x].son[<span class="number">0</span>]].size;</span><br><span class="line">        <span class="keyword">if</span>(tr[x].son[<span class="number">1</span>])tr[x].size += tr[tr[x].son[<span class="number">1</span>]].size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> kind)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = tr[x].fa, z = tr[y].fa, A = tr[y].son[kind], B = tr[x].son[kind], C = tr[x].son[!kind];</span><br><span class="line">    tr[x].son[kind] = y, tr[x].fa = z;</span><br><span class="line">    tr[y].son[!kind] = B, tr[y].fa = x, tr[B].fa = y;</span><br><span class="line">    tr[z].son[tr[z].son[<span class="number">1</span>] == y] = x;</span><br><span class="line">    pushup(y), pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> goal)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == goal)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(tr[x].fa != goal)&#123;</span><br><span class="line">        <span class="keyword">int</span> y = tr[x].fa, z = tr[y].fa;</span><br><span class="line">        <span class="keyword">int</span> isrson1 = tr[y].son[<span class="number">1</span>] == x, isrson2 = tr[z].son[<span class="number">1</span>] == y;</span><br><span class="line">        <span class="keyword">if</span>(z == goal)rotate(x, !isrson1);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(isrson1 == isrson2)rotate(y, !isrson2);</span><br><span class="line">            <span class="keyword">else</span>rotate(x, !isrson1);</span><br><span class="line">            rotate(x, !isrson2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(goal == <span class="number">0</span>)root = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = root;</span><br><span class="line">    <span class="keyword">while</span>(now)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[now].val == x)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tr[now].val &lt; x)now = tr[now].son[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tr[now].val &gt; x)now = tr[now].son[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!now)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getPre</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = root, ans = -INF;</span><br><span class="line">    <span class="keyword">while</span>(now)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[now].val &lt; x)&#123;</span><br><span class="line">            ans = max(ans, tr[now].val);</span><br><span class="line">            now = tr[now].son[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>now = tr[now].son[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getSub</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = root, ans = INF;</span><br><span class="line">    <span class="keyword">while</span>(now)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[now].val &gt; x)&#123;</span><br><span class="line">            ans = min(ans, tr[now].val);</span><br><span class="line">            now = tr[now].son[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>now = tr[now].son[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getRank</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = root, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(now)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[now].val == x)&#123;</span><br><span class="line">            ans += tr[tr[now].son[<span class="number">0</span>]].size + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tr[now].val &lt; x)&#123;</span><br><span class="line">            ans += tr[tr[now].son[<span class="number">0</span>]].size + tr[now].times;</span><br><span class="line">            now = tr[now].son[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>now = tr[now].son[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    ++cnt;</span><br><span class="line">    tr[cnt].val = val;</span><br><span class="line">    tr[cnt].fa = f;</span><br><span class="line">    tr[cnt].son[<span class="number">0</span>] = tr[cnt].son[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    tr[cnt].size = tr[cnt].times = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    splay(select(getPre(x)), <span class="number">0</span>);</span><br><span class="line">    splay(select(getSub(x)), root);</span><br><span class="line">    <span class="keyword">int</span> t = tr[tr[root].son[<span class="number">1</span>]].son[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(!t)</span><br><span class="line">        tr[tr[root].son[<span class="number">1</span>]].son[<span class="number">0</span>] = newNode(x, tr[root].son[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">else</span>tr[t].times++, tr[t].size++;</span><br><span class="line">    pushup(tr[root].son[<span class="number">1</span>]);</span><br><span class="line">    pushup(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    splay(select(getPre(x)), <span class="number">0</span>);</span><br><span class="line">    splay(select(getSub(x)), root);</span><br><span class="line">    <span class="keyword">int</span> t = tr[tr[root].son[<span class="number">1</span>]].son[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(!t || tr[t].times == <span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">    tr[t].times--, tr[t].size--;</span><br><span class="line">    <span class="keyword">if</span>(tr[t].times == <span class="number">0</span>)tr[tr[root].son[<span class="number">1</span>]].son[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    pushup(tr[root].son[<span class="number">1</span>]);</span><br><span class="line">    pushup(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">findRank</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = root;</span><br><span class="line">    <span class="keyword">while</span>(now)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[tr[now].son[<span class="number">0</span>]].size + <span class="number">1</span> &lt;= x &amp;&amp; x &lt;= tr[tr[now].son[<span class="number">0</span>]].size + tr[now].times)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tr[tr[now].son[<span class="number">0</span>]].size + <span class="number">1</span> &gt; x)</span><br><span class="line">            now = tr[now].son[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tr[tr[now].son[<span class="number">0</span>]].size + tr[now].times &lt; x)&#123;</span><br><span class="line">            x -= tr[tr[now].son[<span class="number">0</span>]].size + tr[now].times;</span><br><span class="line">            now = tr[now].son[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tr[now].val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    root = newNode(-INF, <span class="number">0</span>);</span><br><span class="line">    tr[root].son[<span class="number">1</span>] = newNode(INF, root), pushup(root);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;opt, &amp;q);</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">1</span>)insert(q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">2</span>)del(q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">3</span>)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, getRank(q));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">4</span>)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, findRank(q+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">5</span>)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, getPre(q));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">6</span>)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, getSub(q));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、非旋Treap"><a href="#二、非旋Treap" class="headerlink" title="二、非旋Treap"></a>二、非旋Treap</h3><p>每个节点表示一个值，同时记录该点及其子树大小、左右儿子。</p><ul><li>插入：从x处split，新建一个值为x的节点，再将三部分merge起来。（注：从x处分开：x在前一部分，下同）</li><li>删除：从x、x+1处split成三部分（记为l、t、r），将t的左右儿子merge起来，这样就删除了一个节点，再将三部分merge起来。</li><li>查x排名：从x-1处split，则x排名为前一部分的大小+1</li><li>查排名为x的数：同Splay</li><li>求x前驱：同Splay</li><li>求x后继：同Splay</li></ul><p>时间复杂度：每次操作 $O(log_2n)$</p><h4 id="Code-2"><a href="#Code-2" class="headerlink" title="Code#2"></a>Code#2</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n, opt, q;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Treap</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> val, son[<span class="number">2</span>], size, hp;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OPT_Treap</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> cnt, root;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">cnt++;</span><br><span class="line">tr[cnt].val = val;</span><br><span class="line">tr[cnt].hp = rand();</span><br><span class="line">tr[cnt].son[<span class="number">0</span>] = tr[cnt].son[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">tr[cnt].size = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">tr[id].size = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(tr[id].son[<span class="number">0</span>])tr[id].size += tr[tr[id].son[<span class="number">0</span>]].size;</span><br><span class="line"><span class="keyword">if</span>(tr[id].son[<span class="number">1</span>])tr[id].size += tr[tr[id].son[<span class="number">1</span>]].size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">0</span>)<span class="keyword">return</span> b;</span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">0</span>)<span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">if</span>(tr[a].hp &lt;= tr[b].hp)&#123;</span><br><span class="line">pushdown(a);</span><br><span class="line">tr[a].son[<span class="number">1</span>] = merge(tr[a].son[<span class="number">1</span>], b);</span><br><span class="line">pushup(a);</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">pushdown(b);</span><br><span class="line">tr[b].son[<span class="number">0</span>] = merge(a, tr[b].son[<span class="number">0</span>]);</span><br><span class="line">pushup(b);</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> k, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!id)&#123;</span><br><span class="line">x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">pushdown(id);</span><br><span class="line"><span class="keyword">if</span>(tr[id].val &gt; k)</span><br><span class="line">y = id, split(tr[id].son[<span class="number">0</span>], k, x, tr[id].son[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">x = id, split(tr[id].son[<span class="number">1</span>], k, tr[id].son[<span class="number">1</span>], y);</span><br><span class="line">pushup(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">split(root, val, l, r);</span><br><span class="line"><span class="keyword">int</span> t = newNode(val);</span><br><span class="line">root = merge(merge(l, t), r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">split(root, val - <span class="number">1</span>, l, t);</span><br><span class="line">split(t, val, t, r);</span><br><span class="line">t = merge(tr[t].son[<span class="number">0</span>], tr[t].son[<span class="number">1</span>]);</span><br><span class="line">root = merge(merge(l, t), r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getRank</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>, l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">split(root, x<span class="number">-1</span>, l, r);</span><br><span class="line">ans = tr[l].size + <span class="number">1</span>;</span><br><span class="line">root = merge(l, r);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getKth</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> now = root;</span><br><span class="line"><span class="keyword">while</span>(now)&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[tr[now].son[<span class="number">0</span>]].size + <span class="number">1</span> == k)<span class="keyword">return</span> tr[now].val;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(tr[tr[now].son[<span class="number">0</span>]].size &gt;= k)now = tr[now].son[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span>k -= (tr[tr[now].son[<span class="number">0</span>]].size + <span class="number">1</span>), now = tr[now].son[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getPre</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = -INF, now = root;</span><br><span class="line"><span class="keyword">while</span>(now)&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[now].val &gt;= x)now = tr[now].son[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ans = max(ans, tr[now].val);</span><br><span class="line">now = tr[now].son[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getSub</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = INF, now = root;</span><br><span class="line"><span class="keyword">while</span>(now)&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[now].val &lt;= x)now = tr[now].son[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ans = min(ans, tr[now].val);</span><br><span class="line">now = tr[now].son[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;BST;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">srand(<span class="number">200127</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">BST.root = BST.newNode(INF);</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;opt, &amp;q);</span><br><span class="line"><span class="keyword">if</span>(opt == <span class="number">1</span>)BST.insert(q);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">2</span>)BST.del(q);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">3</span>)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, BST.getRank(q));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">4</span>)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, BST.getKth(q));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">5</span>)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, BST.getPre(q));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">6</span>)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, BST.getSub(q));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="文艺平衡树"><a href="#文艺平衡树" class="headerlink" title="文艺平衡树"></a>文艺平衡树</h1><p>题目链接：<br><a href="https://www.luogu.org/problemnew/show/3391" target="_blank" rel="noopener">luogu3391</a><br><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3223" target="_blank" rel="noopener">bzoj3223</a></p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="一、Splay-1"><a href="#一、Splay-1" class="headerlink" title="一、Splay"></a>一、Splay</h3><p>这道题只有区间翻转操作，线段树不好维护，只有用平衡树了。<br>对于一次$[l,r]$的区间翻转，把$l-1$旋至根，$r+1$旋至根的右儿子，那么$[l,r]$就在根的右儿子的左儿子处了。和线段树一样，我们可以将它的左右儿子互换后打上一个翻转标记(rev ^= 1)，之后再pushdown。</p><h4 id="Code-3"><a href="#Code-3" class="headerlink" title="Code#3"></a>Code#3</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, ql, qr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt, root;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Splay_tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fa, son[<span class="number">2</span>], size, val;</span><br><span class="line">    <span class="keyword">bool</span> rev;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x)&#123;</span><br><span class="line">        tr[x].size = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(tr[x].son[<span class="number">0</span>])tr[x].size += tr[tr[x].son[<span class="number">0</span>]].size;</span><br><span class="line">        <span class="keyword">if</span>(tr[x].son[<span class="number">1</span>])tr[x].size += tr[tr[x].son[<span class="number">1</span>]].size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].rev)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[x].son[<span class="number">0</span>])&#123;</span><br><span class="line">            tr[tr[x].son[<span class="number">0</span>]].rev ^= <span class="number">1</span>;</span><br><span class="line">            swap(tr[tr[x].son[<span class="number">0</span>]].son[<span class="number">0</span>], tr[tr[x].son[<span class="number">0</span>]].son[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tr[x].son[<span class="number">1</span>])&#123;</span><br><span class="line">            tr[tr[x].son[<span class="number">1</span>]].rev ^= <span class="number">1</span>;</span><br><span class="line">            swap(tr[tr[x].son[<span class="number">1</span>]].son[<span class="number">0</span>], tr[tr[x].son[<span class="number">1</span>]].son[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        tr[x].rev = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> kind)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = tr[x].fa, z = tr[y].fa, A = tr[y].son[kind], B = tr[x].son[kind], C = tr[x].son[!kind];</span><br><span class="line">    tr[x].son[kind] = y, tr[x].fa = z;</span><br><span class="line">    tr[y].son[!kind] = B, tr[y].fa = x;</span><br><span class="line">    tr[z].son[tr[z].son[<span class="number">1</span>] == y] = x;</span><br><span class="line">    tr[B].fa = y;</span><br><span class="line">    pushup(y), pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> goal)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == goal)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(tr[x].fa != goal)&#123;</span><br><span class="line">        <span class="keyword">int</span> y = tr[x].fa, z = tr[y].fa;</span><br><span class="line">        pushdown(z), pushdown(y), pushdown(x);</span><br><span class="line">        <span class="keyword">int</span> isrson1 = tr[y].son[<span class="number">1</span>] == x, isrson2 = tr[z].son[<span class="number">1</span>] == y;</span><br><span class="line">        <span class="keyword">if</span>(z == goal)rotate(x, !isrson1);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(isrson1 == isrson2)rotate(y, !isrson2);</span><br><span class="line">            <span class="keyword">else</span>rotate(x, !isrson1);</span><br><span class="line">            rotate(x, !isrson2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(goal == <span class="number">0</span>)root = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    tr[cnt].val = val;</span><br><span class="line">    tr[cnt].fa = f;</span><br><span class="line">    tr[cnt].son[<span class="number">0</span>] = tr[cnt].son[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    tr[cnt].size = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = root;</span><br><span class="line">    pushdown(now);</span><br><span class="line">    <span class="keyword">while</span>(tr[tr[now].son[<span class="number">0</span>]].size + <span class="number">1</span> != x)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[tr[now].son[<span class="number">0</span>]].size + <span class="number">1</span> &gt; x)now = tr[now].son[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            x -= tr[tr[now].son[<span class="number">0</span>]].size + <span class="number">1</span>;</span><br><span class="line">            now = tr[now].son[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        pushdown(now);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    splay(select(l<span class="number">-1</span>), <span class="number">0</span>);</span><br><span class="line">    splay(select(r+<span class="number">1</span>), root);</span><br><span class="line">    <span class="keyword">int</span> t = tr[tr[root].son[<span class="number">1</span>]].son[<span class="number">0</span>];</span><br><span class="line">    tr[t].rev ^= <span class="number">1</span>;</span><br><span class="line">    swap(tr[t].son[<span class="number">0</span>], tr[t].son[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, x = ++cnt;</span><br><span class="line">    tr[x].val = mid - <span class="number">1</span>;</span><br><span class="line">    tr[x].size = <span class="number">1</span>;</span><br><span class="line">    tr[x].fa = f;</span><br><span class="line">    tr[x].rev = <span class="number">0</span>;</span><br><span class="line">    tr[x].son[<span class="number">0</span>] = build(l, mid<span class="number">-1</span>, x);</span><br><span class="line">    tr[x].son[<span class="number">1</span>] = build(mid+<span class="number">1</span>, r, x);</span><br><span class="line">    pushup(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    pushdown(x);</span><br><span class="line">    <span class="keyword">if</span>(tr[x].son[<span class="number">0</span>])print(tr[x].son[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(tr[x].val &gt;= <span class="number">1</span> &amp;&amp; tr[x].val &lt;= n)<span class="built_in">printf</span>(<span class="string">"%d "</span>, tr[x].val);</span><br><span class="line">    <span class="keyword">if</span>(tr[x].son[<span class="number">1</span>])print(tr[x].son[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    root = build(<span class="number">1</span>, n+<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;ql, &amp;qr);</span><br><span class="line">        reverse(ql+<span class="number">1</span>, qr+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    print(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、非旋Treap-1"><a href="#二、非旋Treap-1" class="headerlink" title="二、非旋Treap"></a>二、非旋Treap</h3><p>同上。</p><h4 id="Code-4"><a href="#Code-4" class="headerlink" title="Code#4"></a>Code#4</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, ql, qr;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Treap</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> val, size, son[<span class="number">2</span>], hp;</span><br><span class="line"><span class="keyword">bool</span> rev;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OPT_Treap</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> cnt, root;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">cnt++;</span><br><span class="line">tr[cnt].val = val;</span><br><span class="line">tr[cnt].hp = rand();</span><br><span class="line">tr[cnt].size = <span class="number">1</span>;</span><br><span class="line">tr[cnt].son[<span class="number">0</span>] = tr[cnt].son[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">tr[cnt].rev = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!id)<span class="keyword">return</span>;</span><br><span class="line">tr[id].size = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(tr[id].son[<span class="number">0</span>])tr[id].size += tr[tr[id].son[<span class="number">0</span>]].size;</span><br><span class="line"><span class="keyword">if</span>(tr[id].son[<span class="number">1</span>])tr[id].size += tr[tr[id].son[<span class="number">1</span>]].size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!tr[id].rev)<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(tr[id].son[<span class="number">0</span>])&#123;</span><br><span class="line"><span class="keyword">int</span> t = tr[id].son[<span class="number">0</span>];</span><br><span class="line">tr[t].rev ^= <span class="number">1</span>;</span><br><span class="line">swap(tr[t].son[<span class="number">0</span>], tr[t].son[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tr[id].son[<span class="number">1</span>])&#123;</span><br><span class="line"><span class="keyword">int</span> t = tr[id].son[<span class="number">1</span>];</span><br><span class="line">tr[t].rev ^= <span class="number">1</span>;</span><br><span class="line">swap(tr[t].son[<span class="number">0</span>], tr[t].son[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">tr[id].rev ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">0</span>)<span class="keyword">return</span> b;</span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">0</span>)<span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">if</span>(tr[a].hp &lt;= tr[b].hp)&#123;</span><br><span class="line">pushdown(a);</span><br><span class="line">tr[a].son[<span class="number">1</span>] = merge(tr[a].son[<span class="number">1</span>], b);</span><br><span class="line">pushup(a);</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">pushdown(b);</span><br><span class="line">tr[b].son[<span class="number">0</span>] = merge(a, tr[b].son[<span class="number">0</span>]);</span><br><span class="line">pushup(b);</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> k, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!id)&#123;</span><br><span class="line">x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">pushdown(id);</span><br><span class="line"><span class="keyword">if</span>(tr[tr[id].son[<span class="number">0</span>]].size &gt;= k)</span><br><span class="line">y = id, split(tr[id].son[<span class="number">0</span>], k, x, tr[id].son[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">x = id, split(tr[id].son[<span class="number">1</span>], k - tr[tr[id].son[<span class="number">0</span>]].size - <span class="number">1</span>, tr[id].son[<span class="number">1</span>], y);</span><br><span class="line">pushup(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> L, t, R;</span><br><span class="line">split(root, l - <span class="number">1</span>, L, t);</span><br><span class="line">split(t, r - l + <span class="number">1</span>, t, R);</span><br><span class="line">tr[t].rev ^= <span class="number">1</span>;</span><br><span class="line">swap(tr[t].son[<span class="number">0</span>], tr[t].son[<span class="number">1</span>]);</span><br><span class="line">root = merge(merge(L, t), R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &gt; r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> t = newNode(mid);</span><br><span class="line">tr[t].son[<span class="number">0</span>] = build(l, mid - <span class="number">1</span>);</span><br><span class="line">tr[t].son[<span class="number">1</span>] = build(mid + <span class="number">1</span>, r);</span><br><span class="line">pushup(t);</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;BST;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">BST.pushdown(x);</span><br><span class="line"><span class="keyword">if</span>(tr[x].son[<span class="number">0</span>])print(tr[x].son[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, tr[x].val);</span><br><span class="line"><span class="keyword">if</span>(tr[x].son[<span class="number">1</span>])print(tr[x].son[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">srand(<span class="number">200127</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">BST.root = BST.build(<span class="number">1</span>, n);</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;ql, &amp;qr);</span><br><span class="line">BST.reverse(ql, qr);</span><br><span class="line">&#125;</span><br><span class="line">print(BST.root);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="二逼平衡树"><a href="#二逼平衡树" class="headerlink" title="二逼平衡树"></a>二逼平衡树</h1><p>题目链接：<br><a href="https://www.luogu.org/problemnew/show/3380" target="_blank" rel="noopener">luogu3380</a><br><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3196" target="_blank" rel="noopener">bzoj3196</a></p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="一、线段树套Splay"><a href="#一、线段树套Splay" class="headerlink" title="一、线段树套Splay"></a>一、线段树套Splay</h3><p>这道题与普通平衡树唯一的不同就在于所有查询都是区间查询，那么我们需要在平衡树外面套一层线段树以供区间查询，即线段树套平衡树。<br>当然，<strong>并非真的要在每个线段树节点内建一颗平衡树，存一下在这个节点的平衡树的根的编号就行了。</strong></p><ul><li>查询区间内k的排名：在线段树上递归找查询的区间，在相应节点上的平衡树上查询比k小的数的个数，回溯时将所有答案相加得到了区间内比k小的数的个数，最后+1就是排名；</li><li>查询区间内排名为k的值：这个要麻烦一点，由于不同线段树节点上的答案不能进行合并，只能考虑二分答案，问题转化为二分出的答案在区间内的排名问题，即第一问；</li><li>修改某位置的值：修改即先删除原值，再插入新值；在线段树上找到该节点，对所经路线上所有线段树里的平衡树进行删除插入操作；</li><li>查询k在区间内的前驱：同第一问，只不过在更新答案时不是相加，而是取max；</li><li>查询k在区间内的后继：同第一问，只不过在更新答案时不是相加，而是取min。</li></ul><h4 id="Code-5"><a href="#Code-5" class="headerlink" title="Code#5"></a>Code#5</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lid id&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rid id&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((A[id].l+A[id].r)&gt;&gt;1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50005</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[N], opt, ql, qr, qk, qpos, tmp;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">splay</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> size, times, val, son[<span class="number">2</span>], fa;</span><br><span class="line">&#125;B[(<span class="keyword">int</span>)<span class="number">4e6</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segTree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, root;</span><br><span class="line">&#125;A[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OPT_splay</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x)&#123;</span><br><span class="line">            B[x].size = B[x].times;</span><br><span class="line">            <span class="keyword">if</span>(B[x].son[<span class="number">0</span>])B[x].size += B[B[x].son[<span class="number">0</span>]].size;</span><br><span class="line">            <span class="keyword">if</span>(B[x].son[<span class="number">1</span>])B[x].size += B[B[x].son[<span class="number">1</span>]].size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> kind)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y = B[x].fa, z = B[y].fa, a = B[y].son[kind], b = B[x].son[kind], c = B[x].son[!kind];</span><br><span class="line">        B[x].fa = z, B[x].son[kind] = y;</span><br><span class="line">        B[y].fa = x, B[y].son[!kind] = b;</span><br><span class="line">        B[z].son[B[z].son[<span class="number">1</span>] == y] = x;</span><br><span class="line">        B[b].fa = y;</span><br><span class="line">        pushup(y), pushup(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> goal, <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == goal)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span>(B[x].fa != goal)&#123;</span><br><span class="line">            <span class="keyword">int</span> y = B[x].fa, z = B[y].fa;</span><br><span class="line">            <span class="keyword">int</span> isrson1 = B[y].son[<span class="number">1</span>] == x, isrson2 = B[z].son[<span class="number">1</span>] == y;</span><br><span class="line">            <span class="keyword">if</span>(z == goal)rotate(x, !isrson1);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(isrson1 == isrson2)rotate(y, !isrson2);</span><br><span class="line">                <span class="keyword">else</span>rotate(x, !isrson1);</span><br><span class="line">                rotate(x, !isrson2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(goal == <span class="number">0</span>)A[id].root = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        B[cnt].fa = fa;</span><br><span class="line">        B[cnt].val = val;</span><br><span class="line">        B[cnt].size = B[cnt].times = <span class="number">1</span>;</span><br><span class="line">        B[cnt].son[<span class="number">0</span>] = B[cnt].son[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getPre</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now = A[id].root, res = -INF;</span><br><span class="line">        <span class="keyword">while</span>(now)&#123;</span><br><span class="line">            <span class="keyword">if</span>(B[now].val &lt; x)&#123;</span><br><span class="line">                res = max(res, B[now].val);</span><br><span class="line">                now = B[now].son[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>now = B[now].son[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getSub</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now = A[id].root, res = INF;</span><br><span class="line">        <span class="keyword">while</span>(now)&#123;</span><br><span class="line">            <span class="keyword">if</span>(B[now].val &gt; x)&#123;</span><br><span class="line">                res = min(res, B[now].val);</span><br><span class="line">                now = B[now].son[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>now = B[now].son[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now = A[id].root;</span><br><span class="line">        <span class="keyword">while</span>(now)&#123;</span><br><span class="line">            <span class="keyword">if</span>(B[now].val == x)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(B[now].val &gt; x)now = B[now].son[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(B[now].val &lt; x)now = B[now].son[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!now)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getRank</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(select(x, id) != <span class="number">-1</span>)splay(select(x, id), <span class="number">0</span>, id);</span><br><span class="line">        <span class="keyword">else</span>splay(select(getSub(x, id), id), <span class="number">0</span>, id);</span><br><span class="line">        <span class="keyword">return</span> B[B[A[id].root].son[<span class="number">0</span>]].size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        splay(select(getPre(val, id), id), <span class="number">0</span>, id);</span><br><span class="line">        splay(select(getSub(val, id), id), A[id].root, id);</span><br><span class="line">        <span class="keyword">int</span> t = B[B[A[id].root].son[<span class="number">1</span>]].son[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(!t)B[B[A[id].root].son[<span class="number">1</span>]].son[<span class="number">0</span>] = newNode(val, B[A[id].root].son[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span>B[t].times++, B[t].size++;</span><br><span class="line">        pushup(B[A[id].root].son[<span class="number">1</span>]);</span><br><span class="line">        pushup(A[id].root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        splay(select(getPre(val, id), id), <span class="number">0</span>, id);</span><br><span class="line">        splay(select(getSub(val, id), id), A[id].root, id);</span><br><span class="line">        <span class="keyword">int</span> t = B[B[A[id].root].son[<span class="number">1</span>]].son[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(!t || B[t].times == <span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        B[t].times--, B[t].size--;</span><br><span class="line">        <span class="keyword">if</span>(B[t].times == <span class="number">0</span>)B[B[A[id].root].son[<span class="number">1</span>]].son[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        pushup(B[A[id].root].son[<span class="number">1</span>]);</span><br><span class="line">        pushup(A[id].root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Splay;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OPT_segTree</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        A[id].root = Splay.newNode(-INF, <span class="number">0</span>);</span><br><span class="line">        B[A[id].root].son[<span class="number">1</span>] = Splay.newNode(INF, A[id].root);</span><br><span class="line">        A[id].l = l, A[id].r = r;</span><br><span class="line">        <span class="keyword">if</span>(A[id].l == A[id].r)<span class="keyword">return</span>;</span><br><span class="line">        build(lid, l, mid);</span><br><span class="line">        build(rid, mid+<span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> pos, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        Splay.insert(val, id);</span><br><span class="line">        <span class="keyword">if</span>(A[id].l == A[id].r)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos &lt;= mid)insert(lid, pos, val);</span><br><span class="line">        <span class="keyword">else</span>insert(rid, pos, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRank</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[id].l == l &amp;&amp; A[id].r == r)<span class="keyword">return</span> Splay.getRank(x, id) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(r &lt;= mid)<span class="keyword">return</span> getRank(lid, l, r, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l &gt; mid)<span class="keyword">return</span> getRank(rid, l, r, x);</span><br><span class="line">        <span class="keyword">else</span><span class="keyword">return</span> getRank(lid, l, mid, x) + getRank(rid, mid+<span class="number">1</span>, r, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getKth</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>, L = <span class="number">0</span>, R = <span class="number">1e8</span>;</span><br><span class="line">        <span class="keyword">while</span>(L &lt;= R)&#123;</span><br><span class="line">            <span class="keyword">int</span> Mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> t1 = getRank(<span class="number">1</span>, l, r, Mid) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> t2 = getRank(<span class="number">1</span>, l, r, Mid+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(t1 &lt;= k &amp;&amp; k &lt;= t2)&#123; ans = Mid; <span class="keyword">break</span>; &#125;</span><br><span class="line">            <span class="keyword">if</span>(t2 &lt; k)L = Mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(t1 &gt; k)R = Mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> pos, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        Splay.del(a[pos], id);</span><br><span class="line">        Splay.insert(val, id);</span><br><span class="line">        <span class="keyword">if</span>(A[id].l == A[id].r)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos &lt;= mid)modify(lid, pos, val);</span><br><span class="line">        <span class="keyword">else</span>modify(rid, pos, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPre</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[id].l == l &amp;&amp; A[id].r == r)<span class="keyword">return</span> Splay.getPre(x, id);</span><br><span class="line">        <span class="keyword">if</span>(r &lt;= mid)<span class="keyword">return</span> getPre(lid, l, r, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l &gt; mid)<span class="keyword">return</span> getPre(rid, l, r, x);</span><br><span class="line">        <span class="keyword">else</span><span class="keyword">return</span> max(getPre(lid, l, mid, x), getPre(rid, mid+<span class="number">1</span>, r, x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSub</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[id].l == l &amp;&amp; A[id].r == r)<span class="keyword">return</span> Splay.getSub(x, id);</span><br><span class="line">        <span class="keyword">if</span>(r &lt;= mid)<span class="keyword">return</span> getSub(lid, l, r, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l &gt; mid)<span class="keyword">return</span> getSub(rid, l, r, x);</span><br><span class="line">        <span class="keyword">else</span><span class="keyword">return</span> min(getSub(lid, l, mid, x), getSub(rid, mid+<span class="number">1</span>, r, x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Seg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    Seg.build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        Seg.insert(<span class="number">1</span>, i, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;opt);</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">3</span>)<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;qpos, &amp;qk);</span><br><span class="line">        <span class="keyword">else</span><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;ql, &amp;qr, &amp;qk);</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Seg.getRank(<span class="number">1</span>, ql, qr, qk) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">2</span>)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Seg.getKth(ql, qr, qk));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">3</span>)Seg.modify(<span class="number">1</span>, qpos, qk), a[qpos] = qk;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">4</span>)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Seg.getPre(<span class="number">1</span>, ql, qr, qk));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">5</span>)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Seg.getSub(<span class="number">1</span>, ql, qr, qk));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、线段树套非旋Treap"><a href="#二、线段树套非旋Treap" class="headerlink" title="二、线段树套非旋Treap"></a>二、线段树套非旋Treap</h3><p>同上。</p><h4 id="Code-6"><a href="#Code-6" class="headerlink" title="Code#6"></a>Code#6</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lid id&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rid id&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((A[id].l + A[id].r) &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50005</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, opt, ql, qr, qk, qpos, a[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Treap</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> val, son[<span class="number">2</span>], size, hp;</span><br><span class="line">&#125;B[(<span class="keyword">int</span>)<span class="number">4e6</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r, root;</span><br><span class="line">&#125;A[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OPT_Treap</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">cnt++;</span><br><span class="line">B[cnt].val = val;</span><br><span class="line">B[cnt].son[<span class="number">0</span>] = B[cnt].son[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">B[cnt].size = <span class="number">1</span>;</span><br><span class="line">B[cnt].hp = rand();</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!id)<span class="keyword">return</span>;</span><br><span class="line">B[id].size = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(B[id].son[<span class="number">0</span>])B[id].size += B[B[id].son[<span class="number">0</span>]].size;</span><br><span class="line"><span class="keyword">if</span>(B[id].son[<span class="number">1</span>])B[id].size += B[B[id].son[<span class="number">1</span>]].size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">0</span>)<span class="keyword">return</span> b;</span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">0</span>)<span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">if</span>(B[a].hp &lt;= B[b].hp)&#123;</span><br><span class="line">B[a].son[<span class="number">1</span>] = merge(B[a].son[<span class="number">1</span>], b);</span><br><span class="line">pushup(a);</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">B[b].son[<span class="number">0</span>] = merge(a, B[b].son[<span class="number">0</span>]);</span><br><span class="line">pushup(b);</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> k, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!id)&#123;</span><br><span class="line">x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(B[id].val &gt; k)</span><br><span class="line">y = id, split(B[id].son[<span class="number">0</span>], k, x, B[id].son[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">x = id, split(B[id].son[<span class="number">1</span>], k, B[id].son[<span class="number">1</span>], y);</span><br><span class="line">pushup(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">split(rt, val, l, r);</span><br><span class="line"><span class="keyword">int</span> t = newNode(val);</span><br><span class="line">rt = merge(merge(l, t), r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">split(rt, val - <span class="number">1</span>, l, t);</span><br><span class="line">split(t, val, t, r);</span><br><span class="line">t = merge(B[t].son[<span class="number">0</span>], B[t].son[<span class="number">1</span>]);</span><br><span class="line">rt = merge(merge(l, t), r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getRank</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">split(rt, x - <span class="number">1</span>, l, r);</span><br><span class="line"><span class="keyword">int</span> ans = B[l].size + <span class="number">1</span>;</span><br><span class="line">rt = merge(l, r);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getPre</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> now = rt, ans = -INF;</span><br><span class="line"><span class="keyword">while</span>(now)&#123;</span><br><span class="line"><span class="keyword">if</span>(B[now].val &lt; x)&#123;</span><br><span class="line">ans = max(ans, B[now].val);</span><br><span class="line">now = B[now].son[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>now = B[now].son[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getSub</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> now = rt, ans = INF;</span><br><span class="line"><span class="keyword">while</span>(now)&#123;</span><br><span class="line"><span class="keyword">if</span>(B[now].val &gt; x)&#123;</span><br><span class="line">ans = min(ans, B[now].val);</span><br><span class="line">now = B[now].son[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>now = B[now].son[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;BST;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OPT_segTree</span>&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">A[id].l = l, A[id].r = r;</span><br><span class="line">A[id].root = BST.newNode(INF);</span><br><span class="line"><span class="keyword">if</span>(A[id].l == A[id].r)<span class="keyword">return</span>;</span><br><span class="line">build(lid, l, mid);</span><br><span class="line">build(rid, mid+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> pos, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">BST.insert(A[id].root, val);</span><br><span class="line"><span class="keyword">if</span>(A[id].l == A[id].r)<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(pos &lt;= mid)insert(lid, pos, val);</span><br><span class="line"><span class="keyword">else</span>insert(rid, pos, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> pos, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">BST.del(A[id].root, a[pos]);</span><br><span class="line">BST.insert(A[id].root, val);</span><br><span class="line"><span class="keyword">if</span>(A[id].l == A[id].r)<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(pos &lt;= mid)modify(lid, pos, val);</span><br><span class="line"><span class="keyword">else</span>modify(rid, pos, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> kind)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(A[id].l == l &amp;&amp; A[id].r == r)&#123;</span><br><span class="line"><span class="keyword">if</span>(kind == <span class="number">0</span>)<span class="keyword">return</span> BST.getRank(A[id].root, x);</span><br><span class="line"><span class="keyword">if</span>(kind == <span class="number">1</span>)<span class="keyword">return</span> BST.getPre(A[id].root, x);</span><br><span class="line"><span class="keyword">if</span>(kind == <span class="number">2</span>)<span class="keyword">return</span> BST.getSub(A[id].root, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(r &lt;= mid)<span class="keyword">return</span> query(lid, l, r, x, kind);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(l &gt; mid)<span class="keyword">return</span> query(rid, l, r, x, kind);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(kind == <span class="number">0</span>)<span class="keyword">return</span> query(lid, l, mid, x, kind) + query(rid, mid+<span class="number">1</span>, r, x, kind) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(kind == <span class="number">1</span>)<span class="keyword">return</span> max(query(lid, l, mid, x, kind), query(rid, mid+<span class="number">1</span>, r, x, kind));</span><br><span class="line"><span class="keyword">if</span>(kind == <span class="number">2</span>)<span class="keyword">return</span> min(query(lid, l, mid, x, kind), query(rid, mid+<span class="number">1</span>, r, x, kind));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getKth</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> L = <span class="number">0</span>, R = <span class="number">1e8</span>, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(L &lt;= R)&#123;</span><br><span class="line"><span class="keyword">int</span> Mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> t1 = query(<span class="number">1</span>, l, r, Mid, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> t2 = query(<span class="number">1</span>, l, r, Mid+<span class="number">1</span>, <span class="number">0</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(t1 &lt;= k &amp;&amp; k &lt;= t2)&#123; ans = Mid; <span class="keyword">break</span>; &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(t2 &lt; k)L = Mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(t1 &gt; k)R = Mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;Seg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">srand(<span class="number">200127</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">BST.cnt = <span class="number">0</span>;</span><br><span class="line">Seg.build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">Seg.insert(<span class="number">1</span>, i, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;opt);</span><br><span class="line"><span class="keyword">if</span>(opt == <span class="number">3</span>)<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;qpos, &amp;qk);</span><br><span class="line"><span class="keyword">else</span><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;ql, &amp;qr, &amp;qk);</span><br><span class="line"><span class="keyword">if</span>(opt == <span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Seg.query(<span class="number">1</span>, ql, qr, qk, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">2</span>)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Seg.getKth(ql, qr, qk));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">3</span>)Seg.modify(<span class="number">1</span>, qpos, qk), a[qpos] = qk;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">4</span>)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Seg.query(<span class="number">1</span>, ql, qr, qk, <span class="number">1</span>));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">5</span>)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Seg.query(<span class="number">1</span>, ql, qr, qk, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、树状数组套值域线段树（带修改主席树）"><a href="#三、树状数组套值域线段树（带修改主席树）" class="headerlink" title="三、树状数组套值域线段树（带修改主席树）"></a>三、树状数组套值域线段树（带修改主席树）</h3><p>hmm…这道题其实可以不用平衡树做，因为要求第k大，自然而然想到主席树可以做到，但这道题有修改操作，普通的维护前缀和的主席树修改一次就要把后面所有树都改了，所以修改一次的时间复杂度就是$O(NlogN)$的，显然不行。于是，带修改主席树应运而生：我们不再让值域线段树们维护前缀和了，而是让它们维护树状数组上对应的约$logN$个点，这样一次修改的时间复杂度就降到了$O(log_2^2N)$。</p><ul><li>查询区间内k的排名：相当于找比k小的数有多少个（答案是个数+1）。在值域线段树上二分查找k时，如果往右儿子走，就把左儿子大小加进答案里去就行了；</li><li>查询区间内排名为k的值：找到树状数组里面相关的值域线段树（存进一个数组，见代码中的A[]和B[]），算出当前点左儿子大小，再决定是向左还是向右二分下去；</li><li>修改某位置的值：修改即先删除原值，再插入新值；找到树状数组里面相关的值域线段树，对每棵树都进行删除和插入操作；</li><li>查询k在区间内的前驱：查询区间内比k小的数有多少个，如果没有，输出-INF；否则输出区间内相应排名的值；</li><li>查询k在区间内的后继：查询区间内比k大的数有多少个，如果没有，输出INF；否则输出区间内相应排名的值。</li></ul><p>涉及到值域线段树一般都要<strong>离散化</strong>，以保证空间；同时，这道题还必须<strong>动态开点</strong>才能保证空间。</p><h4 id="Code-7"><a href="#Code-7" class="headerlink" title="Code#7"></a>Code#7</h4><p>纪念我的第一份超过200行的代码…<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50005</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[N], t[N&lt;&lt;<span class="number">1</span>], f[N&lt;&lt;<span class="number">1</span>], MX, A[<span class="number">20</span>], B[<span class="number">20</span>];<span class="comment">//因为有询问操作，t[]和f[]空间一定要开够!</span></span><br><span class="line"><span class="keyword">int</span> root[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> opt, l, r, k, pos;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> size, son[<span class="number">2</span>];</span><br><span class="line">&#125;tr[N*<span class="number">15</span>*<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readin</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]), t[++t[<span class="number">0</span>]] = a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q[i].opt);</span><br><span class="line"><span class="keyword">if</span>(q[i].opt != <span class="number">3</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;q[i].l, &amp;q[i].r, &amp;q[i].k);</span><br><span class="line"><span class="keyword">if</span>(q[i].opt != <span class="number">2</span>)t[++t[<span class="number">0</span>]] = q[i].k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;q[i].pos, &amp;q[i].k);</span><br><span class="line">t[++t[<span class="number">0</span>]] = q[i].k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">disc</span><span class="params">()</span></span>&#123;</span><br><span class="line">sort(t+<span class="number">1</span>, t+t[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> len = unique(t+<span class="number">1</span>, t+t[<span class="number">0</span>]+<span class="number">1</span>) - (t+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> temp = lower_bound(t+<span class="number">1</span>, t+len+<span class="number">1</span>, a[i]) - t;</span><br><span class="line">f[temp] = a[i], a[i] = temp;</span><br><span class="line">MX = max(MX, temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(q[i].opt == <span class="number">2</span>)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> temp = lower_bound(t+<span class="number">1</span>, t+len+<span class="number">1</span>, q[i].k) - t;</span><br><span class="line">f[temp] = q[i].k, q[i].k = temp;</span><br><span class="line">MX = max(MX, temp);</span><br><span class="line">&#125;</span><br><span class="line">f[MX+<span class="number">1</span>] = -INF;</span><br><span class="line">f[MX+<span class="number">2</span>] = INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> X[])</span></span>&#123;</span><br><span class="line">X[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = x; i; i -= lowbit(i))&#123;</span><br><span class="line"><span class="keyword">if</span>(!root[i])root[i] = ++cnt;</span><br><span class="line">X[++X[<span class="number">0</span>]] = root[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> X[])</span></span>&#123;</span><br><span class="line">X[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i))&#123;</span><br><span class="line"><span class="keyword">if</span>(!root[i])root[i] = ++cnt;</span><br><span class="line">X[++X[<span class="number">0</span>]] = root[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">tr[id].size = tr[tr[id].son[<span class="number">0</span>]].size + tr[tr[id].son[<span class="number">1</span>]].size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;id, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!id)id = ++cnt;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">tr[id].size++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(val &lt;= mid)insert(tr[id].son[<span class="number">0</span>], l, mid, val);</span><br><span class="line"><span class="keyword">else</span>insert(tr[id].son[<span class="number">1</span>], mid+<span class="number">1</span>, r, val);</span><br><span class="line">pushup(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> &amp;id, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!id)id = ++cnt;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[id].size &gt; <span class="number">0</span>)tr[id].size--;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(val &lt;= mid)del(tr[id].son[<span class="number">0</span>], l, mid, val);</span><br><span class="line"><span class="keyword">else</span>del(tr[id].son[<span class="number">1</span>], mid+<span class="number">1</span>, r, val);</span><br><span class="line">pushup(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSmaller</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(k &lt;= mid)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A[<span class="number">0</span>]; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!tr[A[i]].son[<span class="number">0</span>])tr[A[i]].son[<span class="number">0</span>] = ++cnt;</span><br><span class="line">A[i] = tr[A[i]].son[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= B[<span class="number">0</span>]; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!tr[B[i]].son[<span class="number">0</span>])tr[B[i]].son[<span class="number">0</span>] = ++cnt;</span><br><span class="line">B[i] = tr[B[i]].son[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> getSmaller(l, mid, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A[<span class="number">0</span>]; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!tr[A[i]].son[<span class="number">1</span>])tr[A[i]].son[<span class="number">1</span>] = ++cnt;</span><br><span class="line">res -= tr[tr[A[i]].son[<span class="number">0</span>]].size;</span><br><span class="line">A[i] = tr[A[i]].son[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= B[<span class="number">0</span>]; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!tr[B[i]].son[<span class="number">1</span>])tr[B[i]].son[<span class="number">1</span>] = ++cnt;</span><br><span class="line">res += tr[tr[B[i]].son[<span class="number">0</span>]].size;</span><br><span class="line">B[i] = tr[B[i]].son[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res + getSmaller(mid+<span class="number">1</span>, r, k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBigger</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(k &lt;= mid)&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A[<span class="number">0</span>]; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!tr[A[i]].son[<span class="number">0</span>])tr[A[i]].son[<span class="number">0</span>] = ++cnt;</span><br><span class="line">res -= tr[tr[A[i]].son[<span class="number">1</span>]].size;</span><br><span class="line">A[i] = tr[A[i]].son[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= B[<span class="number">0</span>]; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!tr[B[i]].son[<span class="number">0</span>])tr[B[i]].son[<span class="number">0</span>] = ++cnt;</span><br><span class="line">res += tr[tr[B[i]].son[<span class="number">1</span>]].size;</span><br><span class="line">B[i] = tr[B[i]].son[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res + getBigger(l, mid, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A[<span class="number">0</span>]; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!tr[A[i]].son[<span class="number">1</span>])tr[A[i]].son[<span class="number">1</span>] = ++cnt;</span><br><span class="line">A[i] = tr[A[i]].son[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= B[<span class="number">0</span>]; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!tr[B[i]].son[<span class="number">1</span>])tr[B[i]].son[<span class="number">1</span>] = ++cnt;</span><br><span class="line">B[i] = tr[B[i]].son[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> getBigger(mid+<span class="number">1</span>, r, k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getKth</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r)<span class="keyword">return</span> l;</span><br><span class="line"><span class="keyword">int</span> lsize = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A[<span class="number">0</span>]; i++)lsize -= tr[tr[A[i]].son[<span class="number">0</span>]].size;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= B[<span class="number">0</span>]; i++)lsize += tr[tr[B[i]].son[<span class="number">0</span>]].size;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(lsize &gt;= k)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A[<span class="number">0</span>]; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!tr[A[i]].son[<span class="number">0</span>])tr[A[i]].son[<span class="number">0</span>] = ++cnt;</span><br><span class="line">A[i] = tr[A[i]].son[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= B[<span class="number">0</span>]; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!tr[B[i]].son[<span class="number">0</span>])tr[B[i]].son[<span class="number">0</span>] = ++cnt;</span><br><span class="line">B[i] = tr[B[i]].son[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> getKth(l, mid, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A[<span class="number">0</span>]; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!tr[A[i]].son[<span class="number">1</span>])tr[A[i]].son[<span class="number">1</span>] = ++cnt;</span><br><span class="line">A[i] = tr[A[i]].son[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= B[<span class="number">0</span>]; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!tr[B[i]].son[<span class="number">1</span>])tr[B[i]].son[<span class="number">1</span>] = ++cnt;</span><br><span class="line">B[i] = tr[B[i]].son[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> getKth(mid+<span class="number">1</span>, r, k - lsize);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getPre</span><span class="params">(<span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">init1(ql<span class="number">-1</span>, A), init1(qr, B);</span><br><span class="line"><span class="keyword">int</span> rank = getSmaller(<span class="number">1</span>, MX, k) + <span class="number">1</span>;</span><br><span class="line">init1(ql<span class="number">-1</span>, A), init1(qr, B);</span><br><span class="line"><span class="keyword">if</span>(rank == <span class="number">1</span>)<span class="keyword">return</span> MX+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span><span class="keyword">return</span> getKth(<span class="number">1</span>, MX, rank<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getSub</span><span class="params">(<span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">init1(ql<span class="number">-1</span>, A), init1(qr, B);</span><br><span class="line"><span class="keyword">int</span> rank = getBigger(<span class="number">1</span>, MX, k) + <span class="number">1</span>;</span><br><span class="line">init1(ql<span class="number">-1</span>, A), init1(qr, B);</span><br><span class="line"><span class="keyword">if</span>(rank == <span class="number">1</span>)<span class="keyword">return</span> MX+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span><span class="keyword">return</span> getKth(<span class="number">1</span>, MX, qr - ql + <span class="number">3</span> - rank);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">readin();</span><br><span class="line">disc();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">init2(i, A);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= A[<span class="number">0</span>]; j++)</span><br><span class="line">insert(A[j], <span class="number">1</span>, MX, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="keyword">switch</span>(q[i].opt)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: init1(q[i].l<span class="number">-1</span>, A); init1(q[i].r, B); <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, getSmaller(<span class="number">1</span>, MX, q[i].k) + <span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: init1(q[i].l<span class="number">-1</span>, A); init1(q[i].r, B); <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[getKth(<span class="number">1</span>, MX, q[i].k)]); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:&#123;</span><br><span class="line">init2(q[i].pos, A);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= A[<span class="number">0</span>]; j++)&#123;</span><br><span class="line">del(A[j], <span class="number">1</span>, MX, a[q[i].pos]);</span><br><span class="line">insert(A[j], <span class="number">1</span>, MX, q[i].k);</span><br><span class="line">&#125;</span><br><span class="line">a[q[i].pos] = q[i].k;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>: <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[getPre(q[i].l, q[i].r, q[i].k)]); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>: <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[getSub(q[i].l, q[i].r, q[i].k)]); <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 平衡树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BZOJ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[ZJOI2008]树的统计（树链剖分，线段树）</title>
      <link href="/2018/04/29/ZJOI2008-%E6%A0%91%E7%9A%84%E7%BB%9F%E8%AE%A1%EF%BC%88%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%EF%BC%8C%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89/"/>
      <url>/2018/04/29/ZJOI2008-%E6%A0%91%E7%9A%84%E7%BB%9F%E8%AE%A1%EF%BC%88%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%EF%BC%8C%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>一棵树上有n个节点，编号分别为1到n，每个节点都有一个权值w。<a id="more"></a><br>我们将以下面的形式来要求你对这棵树完成一些操作：<br>I. CHANGE u t : 把结点u的权值改为t<br>II. QMAX u v: 询问从点u到点v的路径上的节点的最大权值<br>III. QSUM u v: 询问从点u到点v的路径上的节点的权值和<br>注意：从点u到点v的路径上的节点包括u和v本身</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件的第一行为一个整数n，表示节点的个数。<br>接下来n – 1行，每行2个整数a和b，表示节点a和节点b之间有一条边相连。<br>接下来一行n个整数，第i个整数wi表示节点i的权值。<br>接下来1行，为一个整数q，表示操作的总数。<br>接下来q行，每行一个操作，以“CHANGE u t”或者“QMAX u v”或者“QSUM u v”的形式给出。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每个“QMAX”或者“QSUM”的操作，每行输出一个整数表示要求输出的结果。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">4 1</span><br><span class="line">4 2 1 3</span><br><span class="line">12</span><br><span class="line">QMAX 3 4</span><br><span class="line">QMAX 3 3</span><br><span class="line">QMAX 3 2</span><br><span class="line">QMAX 2 3</span><br><span class="line">QSUM 3 4</span><br><span class="line">QSUM 2 1</span><br><span class="line">CHANGE 1 5</span><br><span class="line">QMAX 3 4</span><br><span class="line">CHANGE 3 6</span><br><span class="line">QMAX 3 4</span><br><span class="line">QMAX 2 4</span><br><span class="line">QSUM 3 4</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">10</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">16</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>对于100％的数据，保证$1 \leq n \leq 30000，0 \leq q \leq 200000$；中途操作中保证每个节点的权值w在$-30000$到$30000$之间。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这是一道树链剖分的模板题了。<br>注意权值有可能为负数，所以求最大值时要<strong>初始化为-INF</strong></p><p>复杂度$O(n \log ^2n)$</p><hr><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">1e16</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">30005</span>;</span><br><span class="line"><span class="keyword">int</span> n, u, v, q;</span><br><span class="line"><span class="keyword">char</span> opt[<span class="number">10</span>];</span><br><span class="line">LL a[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> nxt, to;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], edgeNum;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">edge[++edgeNum].nxt = head[from];</span><br><span class="line">edge[edgeNum].to = to;</span><br><span class="line">head[from] = edgeNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size[N], fa[N], dep[N], son[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span>, fa[x] = f, dep[x] = depth, son[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(edge[i].to == f)<span class="keyword">continue</span>;</span><br><span class="line">dfs1(edge[i].to, x, depth+<span class="number">1</span>);</span><br><span class="line">size[x] += size[edge[i].to];</span><br><span class="line"><span class="keyword">if</span>(size[edge[i].to] &gt; size[son[x]])son[x] = edge[i].to;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> st[N], ed[N], belong[N], dfsClock, fun[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> top)</span></span>&#123;</span><br><span class="line">st[x] = ++dfsClock, fun[dfsClock] = x;</span><br><span class="line">belong[x] = top;</span><br><span class="line"><span class="keyword">if</span>(son[x])dfs2(son[x], top);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(edge[i].to == fa[x] || edge[i].to == son[x])<span class="keyword">continue</span>;</span><br><span class="line">dfs2(edge[i].to, edge[i].to);</span><br><span class="line">&#125;</span><br><span class="line">ed[x] = dfsClock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lid id&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rid id&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((tr[id].l+tr[id].r)&gt;&gt;1)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r;</span><br><span class="line">LL mx, sum;</span><br><span class="line">segTree()&#123;</span><br><span class="line">l = r = <span class="number">0</span>;</span><br><span class="line">sum = <span class="number">0l</span>l;</span><br><span class="line">mx = -INF;</span><br><span class="line">&#125;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">tr[id].mx = max(tr[lid].mx, tr[rid].mx);</span><br><span class="line">tr[id].sum = tr[lid].sum + tr[rid].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">tr[id].l = l, tr[id].r = r;</span><br><span class="line"><span class="keyword">if</span>(tr[id].l == tr[id].r)&#123;</span><br><span class="line">tr[id].mx = tr[id].sum = a[fun[l]];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">build(lid, l, mid);</span><br><span class="line">build(rid, mid+<span class="number">1</span>, r);</span><br><span class="line">pushup(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[id].l == l &amp;&amp; tr[id].r == r)</span><br><span class="line"><span class="keyword">return</span> k == <span class="number">0</span> ? tr[id].mx : tr[id].sum;</span><br><span class="line"><span class="keyword">if</span>(r &lt;= mid)<span class="keyword">return</span> query(lid, l, r, k);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(l &gt; mid)<span class="keyword">return</span> query(rid, l, r, k);</span><br><span class="line"><span class="keyword">else</span><span class="keyword">return</span> k == <span class="number">0</span> ? max(query(lid, l, mid, k), query(rid, mid+<span class="number">1</span>, r, k)) : query(lid, l, mid, k) + query(rid, mid+<span class="number">1</span>, r, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> pos, LL v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[id].l == tr[id].r)&#123;</span><br><span class="line">tr[id].sum = tr[id].mx = v;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pos &lt;= mid)modify(lid, pos, v);</span><br><span class="line"><span class="keyword">else</span>modify(rid, pos, v);</span><br><span class="line">pushup(id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;seg;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">LL res = k == <span class="number">0</span> ? -INF : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(belong[u] != belong[v])&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[belong[u]] &lt; dep[belong[v]])swap(u, v);</span><br><span class="line">res = k == <span class="number">0</span> ? max(res, seg.query(<span class="number">1</span>, st[belong[u]], st[u], <span class="number">0</span>)) : res + seg.query(<span class="number">1</span>, st[belong[u]], st[u], <span class="number">1</span>);</span><br><span class="line">u = fa[belong[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u] &gt; dep[v])swap(u, v);</span><br><span class="line">res = k == <span class="number">0</span> ? max(res, seg.query(<span class="number">1</span>, st[u], st[v], <span class="number">0</span>)) : res + seg.query(<span class="number">1</span>, st[u], st[v], <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">addEdge(u, v);</span><br><span class="line">addEdge(v, u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">dfs1(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">dfs2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">seg.build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>, opt, &amp;u, &amp;v);</span><br><span class="line"><span class="keyword">if</span>(opt[<span class="number">0</span>] == <span class="string">'C'</span>)</span><br><span class="line">seg.modify(<span class="number">1</span>, st[u], <span class="number">1l</span>l*v);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(opt[<span class="number">1</span>] == <span class="string">'M'</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(u, v, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(opt[<span class="number">1</span>] == <span class="string">'S'</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(u, v, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 线段树 </category>
          
          <category> 图论 </category>
          
          <category> 树 </category>
          
          <category> 树链剖分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZJOI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[SDOI2011]染色（树链剖分，线段树）</title>
      <link href="/2018/04/28/SDOI2011-%E6%9F%93%E8%89%B2%EF%BC%88%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%EF%BC%8C%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89/"/>
      <url>/2018/04/28/SDOI2011-%E6%9F%93%E8%89%B2%EF%BC%88%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%EF%BC%8C%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>给定一棵有n个节点的无根树和m个操作，操作有2类：<a id="more"></a><br>1、将节点a到节点b路径上所有点都染成颜色c；<br>2、询问节点a到节点b路径上的颜色段数量（连续相同颜色被认为是同一段），<br>如“112221”由3段组成：“11”、“222”和“1”。<br>请你写一个程序依次完成这m个操作。</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>第一行包含2个整数n和m，分别表示节点数和操作数；<br>第二行包含n个正整数表示n个节点的初始颜色<br>下面 n-1 行每行包含两个整数x和y，表示x和y之间有一条无向边。<br>下面 m 行每行描述一个操作：<br>“C a b c”表示这是一个染色操作，把节点a到节点b路径上所有点（包括a和b）都染成颜色c；<br>“Q a b”表示这是一个询问操作，询问节点a到节点b（包括a和b）路径上的颜色段数量。</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>对于每个询问操作，输出一行答案。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">6 5</span><br><span class="line">2 2 1 2 1 1</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">2 5</span><br><span class="line">2 6</span><br><span class="line">Q 3 5</span><br><span class="line">C 2 1 1</span><br><span class="line">Q 3 5</span><br><span class="line">C 5 1 2</span><br><span class="line">Q 3 5</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><p>$N \leq 10^5, M \leq 10^5$，所有的颜色C为整数且在$[0, 10^9]$之间。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题思路应该是很好想到的——树链剖分+线段树<br>显然，合并两个颜色段时，如果合并点两侧颜色相同，那么颜色段数量为左右两段数量之和再减一，否则就是它们的和。根据这个基本性质——<br>线段树维护3个值：颜色段数量(cnt)、左端颜色(lcol)、右端颜色(rcol)，于是<code>tr[id].cnt = tr[lid].cnt + tr[rid].cnt - (tr[lid].rcol == tr[rid].lcol);</code><br>树链剖分询问时（即往上“跳”时），记录一下上一次询问的端点颜色，如果本次询问的相应端点颜色在合并点处与上次询问端点颜色相等，就要减一。<br>至此本题解决。</p><p>复杂度$O(n\log ^2n)$</p><hr><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[N], u, v, qa, qb, qc;</span><br><span class="line"><span class="keyword">char</span> opt[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> nxt, to;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], edgeNum;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">edge[++edgeNum].nxt = head[from];</span><br><span class="line">edge[edgeNum].to = to;</span><br><span class="line">head[from] = edgeNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N], dep[N], size[N], son[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">fa[x] = f, dep[x] = depth, size[x] = <span class="number">1</span>, son[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(edge[i].to == f)<span class="keyword">continue</span>;</span><br><span class="line">dfs1(edge[i].to, x, depth+<span class="number">1</span>);</span><br><span class="line">size[x] += size[edge[i].to];</span><br><span class="line"><span class="keyword">if</span>(size[edge[i].to] &gt; size[son[x]])son[x] = edge[i].to;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> belong[N], st[N], ed[N], dfsClock, fun[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> top)</span></span>&#123;</span><br><span class="line">st[x] = ++dfsClock, fun[dfsClock] = x;</span><br><span class="line">belong[x] = top;</span><br><span class="line"><span class="keyword">if</span>(son[x])dfs2(son[x], top);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(edge[i].to == fa[x] || edge[i].to == son[x])<span class="keyword">continue</span>;</span><br><span class="line">dfs2(edge[i].to, edge[i].to);</span><br><span class="line">&#125;</span><br><span class="line">ed[x] = dfsClock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lid id&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rid id&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((tr[id].l+tr[id].r)&gt;&gt;1)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r, lcol, rcol, cnt, cov;</span><br><span class="line">segTree()&#123;</span><br><span class="line">l = r = lcol = rcol = cnt = cov = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">tr[id].cnt = tr[lid].cnt + tr[rid].cnt - (tr[lid].rcol == tr[rid].lcol);</span><br><span class="line">tr[id].lcol = tr[lid].lcol;</span><br><span class="line">tr[id].rcol = tr[rid].rcol;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[id].l == tr[id].r)<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(tr[id].cov)&#123;</span><br><span class="line"><span class="keyword">int</span> t = tr[id].cov;</span><br><span class="line">tr[lid].cov = tr[rid].cov = t;</span><br><span class="line">tr[lid].lcol = tr[lid].rcol = t;</span><br><span class="line">tr[rid].lcol = tr[rid].rcol = t;</span><br><span class="line">tr[lid].cnt = tr[rid].cnt = <span class="number">1</span>;</span><br><span class="line">tr[id].cov = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">tr[id].l = l, tr[id].r = r;</span><br><span class="line"><span class="keyword">if</span>(tr[id].l == tr[id].r)&#123;</span><br><span class="line">tr[id].cnt = <span class="number">1</span>;</span><br><span class="line">tr[id].lcol = tr[id].rcol = a[fun[l]];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">build(lid, l, mid);</span><br><span class="line">build(rid, mid+<span class="number">1</span>, r);</span><br><span class="line">pushup(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cover</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">pushdown(id);</span><br><span class="line"><span class="keyword">if</span>(tr[id].l == l &amp;&amp; tr[id].r == r)&#123;</span><br><span class="line">tr[id].cov = c;</span><br><span class="line">tr[id].cnt = <span class="number">1</span>;</span><br><span class="line">tr[id].lcol = tr[id].rcol = c;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(r &lt;= mid)cover(lid, l, r, c);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(l &gt; mid)cover(rid, l, r, c);</span><br><span class="line"><span class="keyword">else</span>cover(lid, l, mid, c), cover(rid, mid+<span class="number">1</span>, r, c);</span><br><span class="line">pushup(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">segTree <span class="title">query</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">pushdown(id);</span><br><span class="line"><span class="keyword">if</span>(tr[id].l == l &amp;&amp; tr[id].r == r)<span class="keyword">return</span> tr[id];</span><br><span class="line"><span class="keyword">if</span>(r &lt;= mid)<span class="keyword">return</span> query(lid, l, r);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(l &gt; mid)<span class="keyword">return</span> query(rid, l, r);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">segTree t1 = query(lid, l, mid), t2 = query(rid, mid+<span class="number">1</span>, r), t;</span><br><span class="line">t.cnt = t1.cnt + t2.cnt - (t1.rcol == t2.lcol);</span><br><span class="line">t.lcol = t1.lcol, t.rcol = t2.rcol;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;seg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cover</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(belong[u] != belong[v])&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[belong[u]] &lt; dep[belong[v]])swap(u, v);</span><br><span class="line">seg.cover(<span class="number">1</span>, st[belong[u]], st[u], c);</span><br><span class="line">u = fa[belong[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u] &gt; dep[v])swap(u, v);</span><br><span class="line">seg.cover(<span class="number">1</span>, st[u], st[v], c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>, lastu = <span class="number">0</span>, lastv = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(belong[u] != belong[v])&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[belong[u]] &lt; dep[belong[v]])swap(u, v), swap(lastu, lastv);</span><br><span class="line">segTree t = seg.query(<span class="number">1</span>, st[belong[u]], st[u]);</span><br><span class="line">ans += t.cnt - (t.rcol == lastu);</span><br><span class="line">lastu = t.lcol;</span><br><span class="line">u = fa[belong[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u] &gt; dep[v])swap(u, v), swap(lastu, lastv);</span><br><span class="line">segTree t = seg.query(<span class="number">1</span>, st[u], st[v]);</span><br><span class="line">ans += t.cnt - (t.lcol == lastu) - (t.rcol == lastv);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]), a[i]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">addEdge(u, v);</span><br><span class="line">addEdge(v, u);</span><br><span class="line">&#125;</span><br><span class="line">dfs1(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">dfs2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">seg.build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, opt);</span><br><span class="line"><span class="keyword">if</span>(opt[<span class="number">0</span>] == <span class="string">'C'</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;qa, &amp;qb, &amp;qc);</span><br><span class="line">qc++;</span><br><span class="line">cover(qa, qb, qc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(opt[<span class="number">0</span>] == <span class="string">'Q'</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;qa, &amp;qb);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(qa, qb));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 线段树 </category>
          
          <category> 图论 </category>
          
          <category> 树 </category>
          
          <category> 树链剖分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SDOI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>点分治学习笔记</title>
      <link href="/2018/04/22/%E7%82%B9%E5%88%86%E6%B2%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/04/22/%E7%82%B9%E5%88%86%E6%B2%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>点分治主要解决<strong>树上路径问题</strong>，其主要思想是把一颗有根树以根为分治点分为一个森林（其实就是各个子树），解决经过当前根的路径后在子树里继续分治，从而将问题“分而治之”。</p><p>这里面，根的选择非常重要。为了保证复杂度，我们的分治点应该尽可能的“居中”，所以分治点一般选择正在处理的树的重心。</p><hr><h1 id="套路"><a href="#套路" class="headerlink" title="套路"></a>套路</h1><ol><li>找到当前树的重心作为根</li><li>解决通过这个根的路径的答案（一般有两种方法，一种是通过与子树容斥，一种是直接计算子树贡献）</li><li>递归解决子树</li></ol><hr><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="求重心"><a href="#求重心" class="headerlink" title="求重心"></a>求重心</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//root = 0, mxson[0] = INF, sum = n;</span></span><br><span class="line"><span class="comment">//root = 0, mxson[0] = INF, sum = size[edge[i].to];</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span>, mxson[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[edge[i].to] || edge[i].to == f)<span class="keyword">continue</span>;</span><br><span class="line">findRoot(edge[i].to, x);</span><br><span class="line">size[x] += size[edge[i].to];</span><br><span class="line">mxson[x] = max(mxson[x], size[edge[i].to]);</span><br><span class="line">&#125;</span><br><span class="line">mxson[x] = max(mxson[x], sum - size[x]);</span><br><span class="line"><span class="keyword">if</span>(mxson[x] &lt; mxson[root])root = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>size[]是子树大小，mxson[]是最大子树大小，root是重心，sum是当前整颗树的大小<br><strong>注意</strong>每次 findRoot() 前要初始化 root 和 sum</p><h2 id="分治计算"><a href="#分治计算" class="headerlink" title="分治计算"></a>分治计算</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">cal(x);<span class="comment">//如果此处计算时将子树中一些不合法的路径的贡献也算进去了，那么需要容斥，即在下方*处减掉子树贡献；如果不容斥，就直接利用每颗子树的信息计算答案</span></span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[edge[i].to])<span class="keyword">continue</span>;</span><br><span class="line">cal(edge[i].to);<span class="comment">//*</span></span><br><span class="line">root = <span class="number">0</span>, sum = size[edge[i].to], mxson[<span class="number">0</span>] = INF;</span><br><span class="line">findRoot(edge[i].to, <span class="number">0</span>);</span><br><span class="line">solve(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vis[]标记此点是否计算过，cal()计算以x为根、经过根的路径的答案</p><hr><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>不要再分治时用memset O(n) 地进行初始化，否则点分治好不容易保证的复杂度就被毁了。</p><hr><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="poj1741-tree"><a href="#poj1741-tree" class="headerlink" title="poj1741 tree"></a>poj1741 tree</h2><p><strong>题意</strong><br>给一棵树，边有边权，问两点之间的距离小于等于K的点对有多少个。<br><strong>题解</strong><br>点分治时用容斥做：计算以x为根的子树时直接将求得的dis排序后O(n)求答案，然后再减去每个子树中被统计了的不合法答案<br><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10005</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, u, v, p;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> nxt, to, dis;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], edgeNum;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> dis)</span></span>&#123;</span><br><span class="line">edge[++edgeNum].nxt = head[from];</span><br><span class="line">edge[edgeNum].to = to;</span><br><span class="line">edge[edgeNum].dis = dis;</span><br><span class="line">head[from] = edgeNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> root, sum, size[N], mxson[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span>, mxson[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(edge[i].to == f || vis[edge[i].to])<span class="keyword">continue</span>;</span><br><span class="line">findRoot(edge[i].to, x);</span><br><span class="line">size[x] += size[edge[i].to];</span><br><span class="line">mxson[x] = max(mxson[x], size[edge[i].to]);</span><br><span class="line">&#125;</span><br><span class="line">mxson[x] = max(mxson[x], sum - size[x]);</span><br><span class="line"><span class="keyword">if</span>(mxson[x] &lt; mxson[root])root = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[N], ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getDis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">dis[++dis[<span class="number">0</span>]] = d;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(edge[i].to == f || vis[edge[i].to])<span class="keyword">continue</span>;</span><br><span class="line">getDis(edge[i].to, x, d + edge[i].dis);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= dis[<span class="number">0</span>]; i++)dis[i] = <span class="number">0</span>;</span><br><span class="line">dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">getDis(x, <span class="number">0</span>, d);</span><br><span class="line">sort(dis+<span class="number">1</span>, dis+dis[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = dis[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[l] + dis[r] &lt;= k)res += r - l, l++;</span><br><span class="line"><span class="keyword">else</span>r--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">ans += cal(x, <span class="number">0</span>);</span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[edge[i].to])<span class="keyword">continue</span>;</span><br><span class="line">ans -= cal(edge[i].to, edge[i].dis);</span><br><span class="line">root = <span class="number">0</span>, mxson[<span class="number">0</span>] = INF, sum = size[edge[i].to];</span><br><span class="line">findRoot(edge[i].to, <span class="number">0</span>);</span><br><span class="line">solve(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(edge, <span class="number">0</span>, <span class="keyword">sizeof</span> edge);</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">edgeNum = <span class="number">0</span>;</span><br><span class="line">root = sum = ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(size, <span class="number">0</span>, <span class="keyword">sizeof</span> size);</span><br><span class="line"><span class="built_in">memset</span>(mxson, <span class="number">0</span>, <span class="keyword">sizeof</span> mxson);</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; k == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;p);</span><br><span class="line">addEdge(u, v, p);</span><br><span class="line">addEdge(v, u, p);</span><br><span class="line">&#125;</span><br><span class="line">sum = n, root = <span class="number">0</span>, mxson[<span class="number">0</span>] = INF;</span><br><span class="line">findRoot(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">solve(root);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="luogu3806-【模板】点分治1"><a href="#luogu3806-【模板】点分治1" class="headerlink" title="luogu3806 【模板】点分治1"></a>luogu3806 【模板】点分治1</h2><p><strong>题意</strong><br>给定一棵有n个点的树，多次询问树上距离为k的点对是否存在。<br><strong>题解</strong><br>和上一题差不多，也是容斥，只不过我们把所有k的答案一次性求出来，每次询问O(1)回答。<br><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10005</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k[<span class="number">105</span>], u, v, p;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> nxt, to, dis;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], edgeNum;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> dis)</span></span>&#123;</span><br><span class="line">edge[++edgeNum].nxt = head[from];</span><br><span class="line">edge[edgeNum].to = to;</span><br><span class="line">edge[edgeNum].dis = dis;</span><br><span class="line">head[from] = edgeNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size[N], mxson[N], dis[N], root, sum;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span>, mxson[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[edge[i].to] || edge[i].to == f)<span class="keyword">continue</span>;</span><br><span class="line">findRoot(edge[i].to, x);</span><br><span class="line">size[x] += size[edge[i].to];</span><br><span class="line">mxson[x] = max(mxson[x], size[edge[i].to]);</span><br><span class="line">&#125;</span><br><span class="line">mxson[x] = max(mxson[x], sum - size[x]);</span><br><span class="line"><span class="keyword">if</span>(mxson[x] &lt; mxson[root])root = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getDis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">dis[++dis[<span class="number">0</span>]] = d;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(edge[i].to == f || vis[edge[i].to])<span class="keyword">continue</span>;</span><br><span class="line">getDis(edge[i].to, x, d + edge[i].dis);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d, <span class="keyword">int</span> fl)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= dis[<span class="number">0</span>]; i++)dis[i] = <span class="number">0</span>;</span><br><span class="line">dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">getDis(x, <span class="number">0</span>, d);</span><br><span class="line">sort(dis+<span class="number">1</span>, dis+dis[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= dis[<span class="number">0</span>]; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[i] + dis[i] &gt; k[j])<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> l = lower_bound(dis+i, dis+dis[<span class="number">0</span>]+<span class="number">1</span>, k[j]-dis[i]) - dis;</span><br><span class="line"><span class="keyword">if</span>(dis[l] + dis[i] != k[j])<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> r = upper_bound(dis+i, dis+dis[<span class="number">0</span>]+<span class="number">1</span>, k[j]-dis[i]) - dis;</span><br><span class="line">cnt[k[j]] += (r - l) * fl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">cal(x, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[edge[i].to])<span class="keyword">continue</span>;</span><br><span class="line">cal(edge[i].to, edge[i].dis, <span class="number">-1</span>);</span><br><span class="line">root = <span class="number">0</span>, sum = size[edge[i].to], mxson[<span class="number">0</span>] = INF;</span><br><span class="line">findRoot(edge[i].to, <span class="number">0</span>);</span><br><span class="line">solve(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;p);</span><br><span class="line">addEdge(u, v, p);</span><br><span class="line">addEdge(v, u, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k[i]);</span><br><span class="line">root = <span class="number">0</span>, sum = n, mxson[<span class="number">0</span>] = INF;</span><br><span class="line">findRoot(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">solve(root);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line"><span class="built_in">puts</span>(cnt[k[i]] &gt; <span class="number">0</span> ? <span class="string">"AYE"</span> : <span class="string">"NAY"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="国家集训队-聪聪可可"><a href="#国家集训队-聪聪可可" class="headerlink" title="[国家集训队] 聪聪可可"></a>[国家集训队] 聪聪可可</h2><p><strong>题意</strong><br>求边权和是3的倍数的点对个数<br><strong>题解</strong><br>思路和上面两道题大同小异，而且更简单了：不用对dis排序，只需记录下距当前根dis为0,1,2的点的个数(cnt)，则答案就是$cnt[0] * cnt[0] + cnt[1] * cnt[2] * 2$<br>当然这样做也要容斥<br><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> n, u, v, p;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> nxt, to, dis;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], edgeNum;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> dis)</span></span>&#123;</span><br><span class="line">edge[++edgeNum].nxt = head[from];</span><br><span class="line">edge[edgeNum].to = to;</span><br><span class="line">edge[edgeNum].dis = dis;</span><br><span class="line">head[from] = edgeNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> root, mxson[N], sum, size[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span>, mxson[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[edge[i].to] || edge[i].to == f)<span class="keyword">continue</span>;</span><br><span class="line">findRoot(edge[i].to, x);</span><br><span class="line">size[x] += size[edge[i].to];</span><br><span class="line">mxson[x] = max(mxson[x], size[edge[i].to]);</span><br><span class="line">&#125;</span><br><span class="line">mxson[x] = max(mxson[x], sum - size[x]);</span><br><span class="line"><span class="keyword">if</span>(mxson[x] &lt; mxson[root])root = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getDis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">cnt[d%<span class="number">3</span>]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[edge[i].to] || edge[i].to == f)<span class="keyword">continue</span>;</span><br><span class="line">getDis(edge[i].to, x, (d + edge[i].dis) % <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">cnt[<span class="number">0</span>] = cnt[<span class="number">1</span>] = cnt[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">getDis(x, <span class="number">0</span>, d);</span><br><span class="line"><span class="keyword">return</span> cnt[<span class="number">0</span>] * cnt[<span class="number">0</span>] + cnt[<span class="number">1</span>] * cnt[<span class="number">2</span>] * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">ans += cal(x, <span class="number">0</span>);</span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[edge[i].to])<span class="keyword">continue</span>;</span><br><span class="line">ans -= cal(edge[i].to, edge[i].dis % <span class="number">3</span>);</span><br><span class="line">root = <span class="number">0</span>, sum = size[edge[i].to], mxson[<span class="number">0</span>] = INF;</span><br><span class="line">findRoot(edge[i].to, <span class="number">0</span>);</span><br><span class="line">solve(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;p);</span><br><span class="line">addEdge(u, v, p % <span class="number">3</span>);</span><br><span class="line">addEdge(v, u, p % <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">root = <span class="number">0</span>, mxson[<span class="number">0</span>] = INF, sum = n;</span><br><span class="line">findRoot(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">solve(root);</span><br><span class="line"><span class="keyword">int</span> g = gcd(ans, n*n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d/%d"</span>, ans / g,  n * n / g);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="IOI-Race"><a href="#IOI-Race" class="headerlink" title="[IOI]Race"></a>[IOI]Race</h2><p><strong>题意</strong><br>给一棵树，每条边有权。求一条简单路径，权值和等于 K ，且边的数量最小。输出最小边数<br><strong>题解</strong><br>发现这道不能容斥…所以我们想办法通过子树信息直接计算经过分治点的路径的答案<br>记$tmp[i]$为当前子树中，路径长为$i$的最小边数，于是对于当前根$x$，我们每次遍历它的子树，先用$tmp[]$和正在遍历的子树更新答案（代码中的 $updAns()$ 函数），再用正在遍历的这颗子树更新$tmp[]$（代码中的 $updTmp()$ 函数），这样就保证了不会把不合法的路径算进来<br><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200005</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, u, v, p;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> nxt, to, dis;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], edgeNum;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> dis)</span></span>&#123;</span><br><span class="line">edge[++edgeNum].nxt = head[from];</span><br><span class="line">edge[edgeNum].to = to;</span><br><span class="line">edge[edgeNum].dis = dis;</span><br><span class="line">head[from] = edgeNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> root, mxson[N], size[N], sum;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span>, mxson[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[edge[i].to] || edge[i].to == f)<span class="keyword">continue</span>;</span><br><span class="line">findRoot(edge[i].to, x);</span><br><span class="line">size[x] += size[edge[i].to];</span><br><span class="line">mxson[x] = max(mxson[x], size[edge[i].to]);</span><br><span class="line">&#125;</span><br><span class="line">mxson[x] = max(mxson[x], sum - size[x]);</span><br><span class="line"><span class="keyword">if</span>(mxson[x] &lt; mxson[root])root = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = INF, tmp[<span class="number">1000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updTmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> dis, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dis &lt;= k)tmp[dis] = min(tmp[dis], d);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[edge[i].to] || edge[i].to == f)<span class="keyword">continue</span>;</span><br><span class="line">updTmp(edge[i].to, x, dis + edge[i].dis, d + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updAns</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> dis, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dis &lt;= k)ans = min(ans, d + tmp[k-dis]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[edge[i].to] || edge[i].to == f)<span class="keyword">continue</span>;</span><br><span class="line">updAns(edge[i].to, x, dis + edge[i].dis, d + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearTmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> dis)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dis &lt;= k)tmp[dis] = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[edge[i].to] || edge[i].to == f)<span class="keyword">continue</span>;</span><br><span class="line">clearTmp(edge[i].to, x, dis + edge[i].dis);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x] = <span class="number">1</span>, tmp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[edge[i].to])<span class="keyword">continue</span>;</span><br><span class="line">updAns(edge[i].to, x, edge[i].dis, <span class="number">1</span>);</span><br><span class="line">updTmp(edge[i].to, x, edge[i].dis, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[edge[i].to])<span class="keyword">continue</span>;</span><br><span class="line">clearTmp(edge[i].to, x, edge[i].dis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[edge[i].to])<span class="keyword">continue</span>;</span><br><span class="line">root = <span class="number">0</span>, sum = size[edge[i].to];</span><br><span class="line">findRoot(edge[i].to, <span class="number">0</span>);</span><br><span class="line">solve(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;p);</span><br><span class="line">addEdge(u+<span class="number">1</span>, v+<span class="number">1</span>, p);</span><br><span class="line">addEdge(v+<span class="number">1</span>, u+<span class="number">1</span>, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++)tmp[i] = INF;</span><br><span class="line">root = <span class="number">0</span>, mxson[<span class="number">0</span>] = INF, sum = n;</span><br><span class="line">findRoot(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">solve(root);</span><br><span class="line"><span class="keyword">if</span>(ans == INF)<span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line"><span class="keyword">else</span><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>—— 完 ——</p>]]></content>
      
      <categories>
          
          <category> 图论 </category>
          
          <category> 树 </category>
          
          <category> 点分治 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[NOIP2017 D1 T2]时间复杂度（栈，模拟）</title>
      <link href="/2018/04/14/NOIP2017-D1-T2-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%88%E6%A0%88%EF%BC%8C%E6%A8%A1%E6%8B%9F%EF%BC%89/"/>
      <url>/2018/04/14/NOIP2017-D1-T2-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%88%E6%A0%88%EF%BC%8C%E6%A8%A1%E6%8B%9F%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并 给出了他自己算出的时间复杂度，<a id="more"></a>可他的编程老师实在不想一个一个检查小明的程序， 于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。</p><p>A++语言的循环结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">F i x y</span><br><span class="line">循环体</span><br><span class="line">E</span><br></pre></td></tr></table></figure></p><p>其中F i x y表示新建变量 $i$（变量 $i$ 不可与未被销毁的变量重名）并初始化为 $x$， 然后判断 $i$ 和 $y$ 的大小关系，若 $i$ 小于等于 $y$ 则进入循环，否则不进入。每次循环结束后 $i$ 都会被修改成 $i +1$，一旦 $i$ 大于 $y$ 终止循环。</p><p>$x$ 和 $y$ 可以是正整数（$x$ 和 $y$ 的大小关系不定）或变量 $n$。$n$ 是一个表示数据规模的变量，在时间复杂度计算中需保留该变量而不能将其视为常数，该数远大于 100。</p><p>“E”表示循环体结束。循环体结束时，这个循环体新建的变量也被销毁。</p><p>注：本题中为了书写方便，在描述复杂度时，使用大写英文字母“O”表示通常意义下“Θ”的概念。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>输入文件第一行一个正整数 $t$，表示有 $t$（$t \le 10$）个程序需要计算时间复杂度。 每个程序我们只需抽取其中 F i x y和E即可计算时间复杂度。注意：循环结构允许嵌套。</p><p>接下来每个程序的第一行包含一个正整数 $L$ 和一个字符串，$L$ 代表程序行数，字符串表示这个程序的复杂度，O(1)表示常数复杂度，O(n^w)表示复杂度为$n^w$，其中w是一个小于100的正整数（输入中不包含引号），输入保证复杂度只有O(1)和O(n^w) 两种类型。</p><p>接下来 $L$ 行代表程序中循环结构中的F i x y或者 E。 程序行若以F开头，表示进入一个循环，之后有空格分离的三个字符（串）i x y， 其中 $i$ 是一个小写字母（保证不为$n$），表示新建的变量名，$x$ 和 $y$ 可能是正整数或 $n$ ，已知若为正整数则一定小于 100。</p><p>程序行若以E开头，则表示循环体结束。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>输出文件共 $t$ 行，对应输入的 $t$ 个程序，每行输出”Yes”或”No”或者”ERR”（输出中不包含引号），若程序实际复杂度与输入给出的复杂度一致则输出”Yes”，不一致则输出”No”，若程序有语法错误（其中语法错误只有: ① F 和 E 不匹配 ②新建的变量与已经存在但未被销毁的变量重复两种情况），则输出”ERR” 。</p><p>注意：即使在程序不会执行的循环体中出现了语法错误也会编译错误，要输出 ERR。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">2 O(1)</span><br><span class="line">F i 1 1</span><br><span class="line">E</span><br><span class="line">2 O(n^1)</span><br><span class="line">F x 1 n</span><br><span class="line">E</span><br><span class="line">1 O(1)</span><br><span class="line">F x 1 n</span><br><span class="line">4 O(n^2)</span><br><span class="line">F x 5 n</span><br><span class="line">F y 10 n</span><br><span class="line">E</span><br><span class="line">E</span><br><span class="line">4 O(n^2)</span><br><span class="line">F x 9 n</span><br><span class="line">E</span><br><span class="line">F y 2 n</span><br><span class="line">E</span><br><span class="line">4 O(n^1)</span><br><span class="line">F x 9 n</span><br><span class="line">F y n 4</span><br><span class="line">E</span><br><span class="line">E</span><br><span class="line">4 O(1)</span><br><span class="line">F y n 4</span><br><span class="line">F x 9 n</span><br><span class="line">E</span><br><span class="line">E</span><br><span class="line">4 O(n^2)</span><br><span class="line">F x 1 n</span><br><span class="line">F x 1 10</span><br><span class="line">E</span><br><span class="line">E</span><br></pre></td></tr></table></figure><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">ERR</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">ERR</span><br></pre></td></tr></table></figure><h2 id="输入输出样例解释"><a href="#输入输出样例解释" class="headerlink" title="输入输出样例解释"></a>输入输出样例解释</h2><p>第一个程序 $i$ 从 1 到 1 是常数复杂度。<br>第二个程序 $x$ 从 1 到 $n$ 是 $n$ 的一次方的复杂度。<br>第三个程序有一个 F 开启循环却没有 E 结束，语法错误。<br>第四个程序二重循环，$n$ 的平方的复杂度。<br>第五个程序两个一重循环，$n$ 的一次方的复杂度。<br>第六个程序第一重循环正常，但第二重循环开始即终止（因为$n$远大于100，100大于4）。<br>第七个程序第一重循环无法进入，故为常数复杂度。<br>第八个程序第二重循环中的变量 $x$ 与第一重循环中的变量重复，出现语法错误②，输出 ERR。</p><h2 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h2><p>对于 30%的数据：不存在语法错误，数据保证小明给出的每个程序的前 $L/2$ 行一定为以 F 开头的语句，第 $L/2+1$ 行至第 $L$ 行一定为以 $E$ 开头的语句，$L \le 10$，若 $x$、$y$ 均 为整数，$x$ 一定小于 $y$，且只有 $y$ 有可能为 $n$。<br>对于 50%的数据：不存在语法错误，$L \le 100$，且若 $x$、$y$ 均为整数，$x$ 一定小于 $y$， 且只有 $y$ 有可能为 $n$。<br>对于 70%的数据：不存在语法错误，$L \le 100$。<br>对于 100%的数据：$L \le 100$。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>由于循环必须要让F与E配对，联想到括号匹配问题，所以用栈来模拟。<br>为了方便计算，我在栈里维护了三个值，分别表示当前循环所用变量名、程序执行到当前循环时的复杂度、当前循环是否处于被跳过的循环之中（即程序不会执行到）。在压栈时维护一下这三个值就好了，最后的复杂度即为最大的可被执行到的复杂度。<br>最后，注意一下关于字符串的读入处理就好了。</p><hr><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, L, kind, w;<span class="comment">//kind == 1:O(1); kind == 2: O(n^w)</span></span><br><span class="line"><span class="keyword">int</span> top, ans;</span><br><span class="line"><span class="keyword">char</span> com[<span class="number">100</span>], opt[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">bool</span> used[<span class="number">1000</span>], err;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">int</span> c;<span class="comment">//执行至此的时间复杂度 </span></span><br><span class="line"><span class="keyword">bool</span> dir;<span class="comment">//是否处于直接跳过的循环中 </span></span><br><span class="line">&#125;sta[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d "</span>, &amp;L);</span><br><span class="line"><span class="built_in">cin</span>.getline(com, <span class="number">99</span>);</span><br><span class="line"><span class="keyword">if</span>(com[<span class="number">2</span>] == <span class="string">'1'</span>)kind = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> now = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">while</span>(com[now] &gt;= <span class="string">'0'</span> &amp;&amp; com[now] &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">w = w * <span class="number">10</span> + com[now] - <span class="string">'0'</span>;</span><br><span class="line">now++;</span><br><span class="line">&#125;</span><br><span class="line">kind = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= L; i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>.getline(opt, <span class="number">99</span>);</span><br><span class="line"><span class="keyword">if</span>(err)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(opt[<span class="number">0</span>] == <span class="string">'F'</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(used[opt[<span class="number">2</span>]])&#123; err = <span class="number">1</span>; <span class="keyword">continue</span>; &#125;</span><br><span class="line">used[opt[<span class="number">2</span>]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> now = <span class="number">4</span>, l = <span class="number">0</span>, r = <span class="number">0</span>, pre = <span class="number">0</span>, nxt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((opt[now] &gt;= <span class="string">'0'</span> &amp;&amp; opt[now] &lt;= <span class="string">'9'</span>) || opt[now] == <span class="string">'n'</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(opt[now] == <span class="string">'n'</span>)pre = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span>l = l * <span class="number">10</span> + opt[now] - <span class="string">'0'</span>;</span><br><span class="line">now++;</span><br><span class="line">&#125;</span><br><span class="line">now++;</span><br><span class="line"><span class="keyword">while</span>((opt[now] &gt;= <span class="string">'0'</span> &amp;&amp; opt[now] &lt;= <span class="string">'9'</span>) || (opt[now] == <span class="string">'n'</span>))&#123;</span><br><span class="line"><span class="keyword">if</span>(opt[now] == <span class="string">'n'</span>)nxt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span>r = r * <span class="number">10</span> + opt[now] - <span class="string">'0'</span>;</span><br><span class="line">now++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pre == <span class="number">1</span> &amp;&amp; nxt == <span class="number">1</span>)&#123;</span><br><span class="line">sta[top+<span class="number">1</span>] = (Node)&#123;opt[<span class="number">2</span>], sta[top].c, sta[top].dir&#125;;</span><br><span class="line">top++;</span><br><span class="line"><span class="keyword">if</span>(sta[top].dir == <span class="number">0</span>)ans = max(ans, sta[top].c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pre == <span class="number">1</span> &amp;&amp; nxt == <span class="number">0</span>)&#123;</span><br><span class="line">sta[top+<span class="number">1</span>] = (Node)&#123;opt[<span class="number">2</span>], sta[top].c, <span class="number">1</span>&#125;;</span><br><span class="line">top++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pre == <span class="number">0</span> &amp;&amp; nxt == <span class="number">1</span>)&#123;</span><br><span class="line">sta[top+<span class="number">1</span>] = (Node)&#123;opt[<span class="number">2</span>], sta[top].c + <span class="number">1</span>, sta[top].dir&#125;;</span><br><span class="line">top++;</span><br><span class="line"><span class="keyword">if</span>(sta[top].dir == <span class="number">0</span>)ans = max(ans, sta[top].c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pre == <span class="number">0</span> &amp;&amp; nxt == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= r)&#123;</span><br><span class="line">sta[top+<span class="number">1</span>] = (Node)&#123;opt[<span class="number">2</span>], sta[top].c, sta[top].dir&#125;;</span><br><span class="line">top++;</span><br><span class="line"><span class="keyword">if</span>(sta[top].dir == <span class="number">0</span>)ans = max(ans, sta[top].c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">sta[top+<span class="number">1</span>] = (Node)&#123;opt[<span class="number">2</span>], sta[top].c, <span class="number">1</span>&#125;;</span><br><span class="line">top++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(opt[<span class="number">0</span>] == <span class="string">'E'</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(top == <span class="number">0</span>)err = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">used[sta[top].ch] = <span class="number">0</span>;</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(top)err = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(err)&#123; <span class="built_in">puts</span>(<span class="string">"ERR"</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="keyword">if</span>(kind == <span class="number">1</span> &amp;&amp; ans == <span class="number">0</span>)&#123; <span class="built_in">puts</span>(<span class="string">"Yes"</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="keyword">if</span>(kind == <span class="number">2</span> &amp;&amp; w == ans)&#123; <span class="built_in">puts</span>(<span class="string">"Yes"</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"No"</span>); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(sta, <span class="number">0</span>, <span class="keyword">sizeof</span> sta); top = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(com, <span class="number">0</span>, <span class="keyword">sizeof</span> com);</span><br><span class="line"><span class="built_in">memset</span>(opt, <span class="number">0</span>, <span class="keyword">sizeof</span> opt);</span><br><span class="line"><span class="built_in">memset</span>(used, <span class="number">0</span>, <span class="keyword">sizeof</span> used);</span><br><span class="line">err = <span class="number">0</span>;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line">kind = w = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line">init();</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 模拟 </category>
          
          <category> 数据结构 </category>
          
          <category> 栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NOIP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[NOIP2017 D1 T1]小凯的疑惑（数论）</title>
      <link href="/2018/04/14/NOIP2017-D1-T1-%E5%B0%8F%E5%87%AF%E7%9A%84%E7%96%91%E6%83%91%EF%BC%88%E6%95%B0%E8%AE%BA%EF%BC%89/"/>
      <url>/2018/04/14/NOIP2017-D1-T1-%E5%B0%8F%E5%87%AF%E7%9A%84%E7%96%91%E6%83%91%EF%BC%88%E6%95%B0%E8%AE%BA%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>小凯手中有两种面值的金币，两种面值均为正整数且彼此互素。每种金币小凯都有 无数个。在不找零的情况下，仅凭这两种金币，有些物品他是无法准确支付的。现在小凯想知道在无法准确支付的物品中，最贵的价值是多少金币？注意：输入数据保证存在小凯无法准确支付的商品。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>输入数据仅一行，包含两个正整数 $a$ 和 $ b $，它们之间用一个空格隔开，表示小凯手 中金币的面值。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>输出文件仅一行，一个正整数 $ N $，表示不找零的情况下，小凯用手中的金币不能准确支付的最贵的物品的价值。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 7</span><br></pre></td></tr></table></figure><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h2 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h2><p>小凯手中有面值为3和7的金币无数个，在不找零的前提下无法准确支付价值为1、 2、4、5、8、11 的物品，其中最贵的物品价值为 11，比 11 贵的物品都能买到，比如：<br>$ 12 = 3 \times 4 + 7 \times 0 $<br>$ 13 = 3 \times 2 + 7 \times 1 $<br>$ 14 = 3 \times 0 + 7 \times 2 $<br>$ 15 = 3 \times 5 + 7 \times 0 $</p><h2 id="数据范围与约定"><a href="#数据范围与约定" class="headerlink" title="数据范围与约定"></a>数据范围与约定</h2><p>对于 30%的数据： $ 1 \le a,b \le 50 $。<br>对于 60%的数据： $ 1 \le a,b \le 10^4 $。<br>对于 100%的数据：$ 1 \le a,b \le 10^9 $。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>因为$ (a,b) = 1 $，所以$ {a, 2a, 3a, …, (b-1)a} $为模$ b $的完全剩余系。<br>设$ T $是一个$ a, b $无法表示的数且$ T \equiv ka(mod \ b) $，$ (1 \le k \le b-1) $.<br>若$ T \ge ka $，则$ T $一定可以表示为$ ka+nb $，$ (n \ge 0) $，所以$ T &lt; ka $，则此时$ T $最大为$ ka-b $.<br>显然，当$ k $最大时$ T $最大，所以$ T = (b-1)a-b = ab - a - b $.</p><hr><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">LL a, b;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,  a * b - a - b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NOIP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello, world!</title>
      <link href="/2018/04/07/Hello-world-0/"/>
      <url>/2018/04/07/Hello-world-0/</url>
      <content type="html"><![CDATA[<p>搞了一个下午+一个晚上，终于把hexo+github博客搭建起来了……（尚待后续优化）</p><p>这个博客用于几个板块：OI/ACM 学习笔记（主要），学习总结，随笔，其他</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>?</span><br><span class="line"><span class="keyword">continue</span>!</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/04/06/hello-world/"/>
      <url>/2018/04/06/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
