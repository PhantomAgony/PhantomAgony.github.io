<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>点分治学习笔记</title>
      <link href="/2018/04/22/%E7%82%B9%E5%88%86%E6%B2%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/04/22/%E7%82%B9%E5%88%86%E6%B2%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>点分治主要解决<strong>树上路径问题</strong>，其主要思想是把一颗有根树以根为分治点分为一个森林（其实就是各个子树），解决经过当前根的路径后在子树里继续分治，从而将问题“分而治之”。</p><p>这里面，根的选择非常重要。为了保证复杂度，我们的分治点应该尽可能的“居中”，所以分治点一般选择正在处理的树的重心。<br><a id="more"></a></p><hr><h1 id="套路"><a href="#套路" class="headerlink" title="套路"></a>套路</h1><ol><li>找到当前树的重心作为根</li><li>解决通过这个根的路径的答案（一般有两种方法，一种是通过与子树容斥，一种是直接计算子树贡献）</li><li>递归解决子树</li></ol><hr><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="求重心"><a href="#求重心" class="headerlink" title="求重心"></a>求重心</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//root = 0, mxson[0] = INF, sum = n;</span></span><br><span class="line"><span class="comment">//root = 0, mxson[0] = INF, sum = size[edge[i].to];</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span>, mxson[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[edge[i].to] || edge[i].to == f)<span class="keyword">continue</span>;</span><br><span class="line">findRoot(edge[i].to, x);</span><br><span class="line">size[x] += size[edge[i].to];</span><br><span class="line">mxson[x] = max(mxson[x], size[edge[i].to]);</span><br><span class="line">&#125;</span><br><span class="line">mxson[x] = max(mxson[x], sum - size[x]);</span><br><span class="line"><span class="keyword">if</span>(mxson[x] &lt; mxson[root])root = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>size[]是子树大小，mxson[]是最大子树大小，root是重心，sum是当前整颗树的大小<br><strong>注意</strong>每次 findRoot() 前要初始化 root 和 sum</p><h2 id="分治计算"><a href="#分治计算" class="headerlink" title="分治计算"></a>分治计算</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">cal(x);<span class="comment">//如果此处计算时将子树中一些不合法的路径的贡献也算进去了，那么需要容斥，即在下方*处减掉子树贡献；如果不容斥，就直接利用每颗子树的信息计算答案</span></span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[edge[i].to])<span class="keyword">continue</span>;</span><br><span class="line">cal(edge[i].to);<span class="comment">//*</span></span><br><span class="line">root = <span class="number">0</span>, sum = size[edge[i].to], mxson[<span class="number">0</span>] = INF;</span><br><span class="line">findRoot(edge[i].to, <span class="number">0</span>);</span><br><span class="line">solve(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vis[]标记此点是否计算过，cal()计算以x为根、经过根的路径的答案</p><hr><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>不要再分治时用memset O(n) 地进行初始化，否则点分治好不容易保证的复杂度就被毁了。</p><hr><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="poj1741-tree"><a href="#poj1741-tree" class="headerlink" title="poj1741 tree"></a>poj1741 tree</h2><p><strong>题意</strong><br>给一棵树，边有边权，问两点之间的距离小于等于K的点对有多少个。<br><strong>题解</strong><br>点分治时用容斥做：计算以x为根的子树时直接将求得的dis排序后O(n)求答案，然后再减去每个子树中被统计了的不合法答案<br><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10005</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, u, v, p;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> nxt, to, dis;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], edgeNum;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> dis)</span></span>&#123;</span><br><span class="line">edge[++edgeNum].nxt = head[from];</span><br><span class="line">edge[edgeNum].to = to;</span><br><span class="line">edge[edgeNum].dis = dis;</span><br><span class="line">head[from] = edgeNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> root, sum, size[N], mxson[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span>, mxson[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(edge[i].to == f || vis[edge[i].to])<span class="keyword">continue</span>;</span><br><span class="line">findRoot(edge[i].to, x);</span><br><span class="line">size[x] += size[edge[i].to];</span><br><span class="line">mxson[x] = max(mxson[x], size[edge[i].to]);</span><br><span class="line">&#125;</span><br><span class="line">mxson[x] = max(mxson[x], sum - size[x]);</span><br><span class="line"><span class="keyword">if</span>(mxson[x] &lt; mxson[root])root = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[N], ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getDis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">dis[++dis[<span class="number">0</span>]] = d;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(edge[i].to == f || vis[edge[i].to])<span class="keyword">continue</span>;</span><br><span class="line">getDis(edge[i].to, x, d + edge[i].dis);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= dis[<span class="number">0</span>]; i++)dis[i] = <span class="number">0</span>;</span><br><span class="line">dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">getDis(x, <span class="number">0</span>, d);</span><br><span class="line">sort(dis+<span class="number">1</span>, dis+dis[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = dis[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[l] + dis[r] &lt;= k)res += r - l, l++;</span><br><span class="line"><span class="keyword">else</span>r--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">ans += cal(x, <span class="number">0</span>);</span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[edge[i].to])<span class="keyword">continue</span>;</span><br><span class="line">ans -= cal(edge[i].to, edge[i].dis);</span><br><span class="line">root = <span class="number">0</span>, mxson[<span class="number">0</span>] = INF, sum = size[edge[i].to];</span><br><span class="line">findRoot(edge[i].to, <span class="number">0</span>);</span><br><span class="line">solve(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(edge, <span class="number">0</span>, <span class="keyword">sizeof</span> edge);</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">edgeNum = <span class="number">0</span>;</span><br><span class="line">root = sum = ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(size, <span class="number">0</span>, <span class="keyword">sizeof</span> size);</span><br><span class="line"><span class="built_in">memset</span>(mxson, <span class="number">0</span>, <span class="keyword">sizeof</span> mxson);</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; k == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;p);</span><br><span class="line">addEdge(u, v, p);</span><br><span class="line">addEdge(v, u, p);</span><br><span class="line">&#125;</span><br><span class="line">sum = n, root = <span class="number">0</span>, mxson[<span class="number">0</span>] = INF;</span><br><span class="line">findRoot(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">solve(root);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="luogu3806-【模板】点分治1"><a href="#luogu3806-【模板】点分治1" class="headerlink" title="luogu3806 【模板】点分治1"></a>luogu3806 【模板】点分治1</h2><p><strong>题意</strong><br>给定一棵有n个点的树，多次询问树上距离为k的点对是否存在。<br><strong>题解</strong><br>和上一题差不多，也是容斥，只不过我们把所有k的答案一次性求出来，每次询问O(1)回答。<br><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10005</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k[<span class="number">105</span>], u, v, p;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> nxt, to, dis;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], edgeNum;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> dis)</span></span>&#123;</span><br><span class="line">edge[++edgeNum].nxt = head[from];</span><br><span class="line">edge[edgeNum].to = to;</span><br><span class="line">edge[edgeNum].dis = dis;</span><br><span class="line">head[from] = edgeNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size[N], mxson[N], dis[N], root, sum;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span>, mxson[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[edge[i].to] || edge[i].to == f)<span class="keyword">continue</span>;</span><br><span class="line">findRoot(edge[i].to, x);</span><br><span class="line">size[x] += size[edge[i].to];</span><br><span class="line">mxson[x] = max(mxson[x], size[edge[i].to]);</span><br><span class="line">&#125;</span><br><span class="line">mxson[x] = max(mxson[x], sum - size[x]);</span><br><span class="line"><span class="keyword">if</span>(mxson[x] &lt; mxson[root])root = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getDis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">dis[++dis[<span class="number">0</span>]] = d;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(edge[i].to == f || vis[edge[i].to])<span class="keyword">continue</span>;</span><br><span class="line">getDis(edge[i].to, x, d + edge[i].dis);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d, <span class="keyword">int</span> fl)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= dis[<span class="number">0</span>]; i++)dis[i] = <span class="number">0</span>;</span><br><span class="line">dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">getDis(x, <span class="number">0</span>, d);</span><br><span class="line">sort(dis+<span class="number">1</span>, dis+dis[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= dis[<span class="number">0</span>]; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[i] + dis[i] &gt; k[j])<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> l = lower_bound(dis+i, dis+dis[<span class="number">0</span>]+<span class="number">1</span>, k[j]-dis[i]) - dis;</span><br><span class="line"><span class="keyword">if</span>(dis[l] + dis[i] != k[j])<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> r = upper_bound(dis+i, dis+dis[<span class="number">0</span>]+<span class="number">1</span>, k[j]-dis[i]) - dis;</span><br><span class="line">cnt[k[j]] += (r - l) * fl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">cal(x, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[edge[i].to])<span class="keyword">continue</span>;</span><br><span class="line">cal(edge[i].to, edge[i].dis, <span class="number">-1</span>);</span><br><span class="line">root = <span class="number">0</span>, sum = size[edge[i].to], mxson[<span class="number">0</span>] = INF;</span><br><span class="line">findRoot(edge[i].to, <span class="number">0</span>);</span><br><span class="line">solve(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;p);</span><br><span class="line">addEdge(u, v, p);</span><br><span class="line">addEdge(v, u, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k[i]);</span><br><span class="line">root = <span class="number">0</span>, sum = n, mxson[<span class="number">0</span>] = INF;</span><br><span class="line">findRoot(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">solve(root);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line"><span class="built_in">puts</span>(cnt[k[i]] &gt; <span class="number">0</span> ? <span class="string">"AYE"</span> : <span class="string">"NAY"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="国家集训队-聪聪可可"><a href="#国家集训队-聪聪可可" class="headerlink" title="[国家集训队] 聪聪可可"></a>[国家集训队] 聪聪可可</h2><p><strong>题意</strong><br>求边权和是3的倍数的点对个数<br><strong>题解</strong><br>思路和上面两道题大同小异，而且更简单了：不用对dis排序，只需记录下距当前根dis为0,1,2的点的个数(cnt)，则答案就是$cnt[0] * cnt[0] + cnt[1] * cnt[2] * 2$<br>当然这样做也要容斥<br><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> n, u, v, p;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> nxt, to, dis;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], edgeNum;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> dis)</span></span>&#123;</span><br><span class="line">edge[++edgeNum].nxt = head[from];</span><br><span class="line">edge[edgeNum].to = to;</span><br><span class="line">edge[edgeNum].dis = dis;</span><br><span class="line">head[from] = edgeNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> root, mxson[N], sum, size[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span>, mxson[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[edge[i].to] || edge[i].to == f)<span class="keyword">continue</span>;</span><br><span class="line">findRoot(edge[i].to, x);</span><br><span class="line">size[x] += size[edge[i].to];</span><br><span class="line">mxson[x] = max(mxson[x], size[edge[i].to]);</span><br><span class="line">&#125;</span><br><span class="line">mxson[x] = max(mxson[x], sum - size[x]);</span><br><span class="line"><span class="keyword">if</span>(mxson[x] &lt; mxson[root])root = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getDis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">cnt[d%<span class="number">3</span>]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[edge[i].to] || edge[i].to == f)<span class="keyword">continue</span>;</span><br><span class="line">getDis(edge[i].to, x, (d + edge[i].dis) % <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">cnt[<span class="number">0</span>] = cnt[<span class="number">1</span>] = cnt[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">getDis(x, <span class="number">0</span>, d);</span><br><span class="line"><span class="keyword">return</span> cnt[<span class="number">0</span>] * cnt[<span class="number">0</span>] + cnt[<span class="number">1</span>] * cnt[<span class="number">2</span>] * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">ans += cal(x, <span class="number">0</span>);</span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[edge[i].to])<span class="keyword">continue</span>;</span><br><span class="line">ans -= cal(edge[i].to, edge[i].dis % <span class="number">3</span>);</span><br><span class="line">root = <span class="number">0</span>, sum = size[edge[i].to], mxson[<span class="number">0</span>] = INF;</span><br><span class="line">findRoot(edge[i].to, <span class="number">0</span>);</span><br><span class="line">solve(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;p);</span><br><span class="line">addEdge(u, v, p % <span class="number">3</span>);</span><br><span class="line">addEdge(v, u, p % <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">root = <span class="number">0</span>, mxson[<span class="number">0</span>] = INF, sum = n;</span><br><span class="line">findRoot(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">solve(root);</span><br><span class="line"><span class="keyword">int</span> g = gcd(ans, n*n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d/%d"</span>, ans / g,  n * n / g);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="IOI-Race"><a href="#IOI-Race" class="headerlink" title="[IOI]Race"></a>[IOI]Race</h2><p><strong>题意</strong><br>给一棵树，每条边有权。求一条简单路径，权值和等于 K ，且边的数量最小。输出最小边数<br><strong>题解</strong><br>发现这道不能容斥…所以我们想办法通过子树信息直接计算经过分治点的路径的答案<br>记$tmp[i]$为当前子树中，路径长为$i$的最小边数，于是对于当前根$x$，我们每次遍历它的子树，先用$tmp[]$和正在遍历的子树更新答案（代码中的 $updAns()$ 函数），再用正在遍历的这颗子树更新$tmp[]$（代码中的 $updTmp()$ 函数），这样就保证了不会把不合法的路径算进来<br><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200005</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, u, v, p;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> nxt, to, dis;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], edgeNum;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> dis)</span></span>&#123;</span><br><span class="line">edge[++edgeNum].nxt = head[from];</span><br><span class="line">edge[edgeNum].to = to;</span><br><span class="line">edge[edgeNum].dis = dis;</span><br><span class="line">head[from] = edgeNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> root, mxson[N], size[N], sum;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span>, mxson[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[edge[i].to] || edge[i].to == f)<span class="keyword">continue</span>;</span><br><span class="line">findRoot(edge[i].to, x);</span><br><span class="line">size[x] += size[edge[i].to];</span><br><span class="line">mxson[x] = max(mxson[x], size[edge[i].to]);</span><br><span class="line">&#125;</span><br><span class="line">mxson[x] = max(mxson[x], sum - size[x]);</span><br><span class="line"><span class="keyword">if</span>(mxson[x] &lt; mxson[root])root = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = INF, tmp[<span class="number">1000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updTmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> dis, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dis &lt;= k)tmp[dis] = min(tmp[dis], d);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[edge[i].to] || edge[i].to == f)<span class="keyword">continue</span>;</span><br><span class="line">updTmp(edge[i].to, x, dis + edge[i].dis, d + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updAns</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> dis, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dis &lt;= k)ans = min(ans, d + tmp[k-dis]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[edge[i].to] || edge[i].to == f)<span class="keyword">continue</span>;</span><br><span class="line">updAns(edge[i].to, x, dis + edge[i].dis, d + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearTmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> dis)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dis &lt;= k)tmp[dis] = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[edge[i].to] || edge[i].to == f)<span class="keyword">continue</span>;</span><br><span class="line">clearTmp(edge[i].to, x, dis + edge[i].dis);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x] = <span class="number">1</span>, tmp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[edge[i].to])<span class="keyword">continue</span>;</span><br><span class="line">updAns(edge[i].to, x, edge[i].dis, <span class="number">1</span>);</span><br><span class="line">updTmp(edge[i].to, x, edge[i].dis, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[edge[i].to])<span class="keyword">continue</span>;</span><br><span class="line">clearTmp(edge[i].to, x, edge[i].dis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[edge[i].to])<span class="keyword">continue</span>;</span><br><span class="line">root = <span class="number">0</span>, sum = size[edge[i].to];</span><br><span class="line">findRoot(edge[i].to, <span class="number">0</span>);</span><br><span class="line">solve(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;p);</span><br><span class="line">addEdge(u+<span class="number">1</span>, v+<span class="number">1</span>, p);</span><br><span class="line">addEdge(v+<span class="number">1</span>, u+<span class="number">1</span>, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++)tmp[i] = INF;</span><br><span class="line">root = <span class="number">0</span>, mxson[<span class="number">0</span>] = INF, sum = n;</span><br><span class="line">findRoot(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">solve(root);</span><br><span class="line"><span class="keyword">if</span>(ans == INF)<span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line"><span class="keyword">else</span><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>—— 完 ——</p>]]></content>
      
      <categories>
          
          <category> OI </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 树（图论） </tag>
            
            <tag> 点分治 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[NOIP2017 D1 T2] 时间复杂度（栈，模拟）</title>
      <link href="/2018/04/14/NOIP2017-D1-T2-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%88%E6%A0%88%EF%BC%8C%E6%A8%A1%E6%8B%9F%EF%BC%89/"/>
      <url>/2018/04/14/NOIP2017-D1-T2-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%88%E6%A0%88%EF%BC%8C%E6%A8%A1%E6%8B%9F%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并 给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序， 于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。<a id="more"></a></p><p>A++语言的循环结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">F i x y</span><br><span class="line">循环体</span><br><span class="line">E</span><br></pre></td></tr></table></figure></p><p>其中F i x y表示新建变量 $i$（变量 $i$ 不可与未被销毁的变量重名）并初始化为 $x$， 然后判断 $i$ 和 $y$ 的大小关系，若 $i$ 小于等于 $y$ 则进入循环，否则不进入。每次循环结束后 $i$ 都会被修改成 $i +1$，一旦 $i$ 大于 $y$ 终止循环。</p><p>$x$ 和 $y$ 可以是正整数（$x$ 和 $y$ 的大小关系不定）或变量 $n$。$n$ 是一个表示数据规模的变量，在时间复杂度计算中需保留该变量而不能将其视为常数，该数远大于 100。</p><p>“E”表示循环体结束。循环体结束时，这个循环体新建的变量也被销毁。</p><p>注：本题中为了书写方便，在描述复杂度时，使用大写英文字母“O”表示通常意义下“Θ”的概念。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>输入文件第一行一个正整数 $t$，表示有 $t$（$t \le 10$）个程序需要计算时间复杂度。 每个程序我们只需抽取其中 F i x y和E即可计算时间复杂度。注意：循环结构允许嵌套。</p><p>接下来每个程序的第一行包含一个正整数 $L$ 和一个字符串，$L$ 代表程序行数，字符串表示这个程序的复杂度，O(1)表示常数复杂度，O(n^w)表示复杂度为$n^w$，其中w是一个小于100的正整数（输入中不包含引号），输入保证复杂度只有O(1)和O(n^w) 两种类型。</p><p>接下来 $L$ 行代表程序中循环结构中的F i x y或者 E。 程序行若以F开头，表示进入一个循环，之后有空格分离的三个字符（串）i x y， 其中 $i$ 是一个小写字母（保证不为$n$），表示新建的变量名，$x$ 和 $y$ 可能是正整数或 $n$ ，已知若为正整数则一定小于 100。</p><p>程序行若以E开头，则表示循环体结束。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>输出文件共 $t$ 行，对应输入的 $t$ 个程序，每行输出”Yes”或”No”或者”ERR”（输出中不包含引号），若程序实际复杂度与输入给出的复杂度一致则输出”Yes”，不一致则输出”No”，若程序有语法错误（其中语法错误只有: ① F 和 E 不匹配 ②新建的变量与已经存在但未被销毁的变量重复两种情况），则输出”ERR” 。</p><p>注意：即使在程序不会执行的循环体中出现了语法错误也会编译错误，要输出 ERR。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">2 O(1)</span><br><span class="line">F i 1 1</span><br><span class="line">E</span><br><span class="line">2 O(n^1)</span><br><span class="line">F x 1 n</span><br><span class="line">E</span><br><span class="line">1 O(1)</span><br><span class="line">F x 1 n</span><br><span class="line">4 O(n^2)</span><br><span class="line">F x 5 n</span><br><span class="line">F y 10 n</span><br><span class="line">E</span><br><span class="line">E</span><br><span class="line">4 O(n^2)</span><br><span class="line">F x 9 n</span><br><span class="line">E</span><br><span class="line">F y 2 n</span><br><span class="line">E</span><br><span class="line">4 O(n^1)</span><br><span class="line">F x 9 n</span><br><span class="line">F y n 4</span><br><span class="line">E</span><br><span class="line">E</span><br><span class="line">4 O(1)</span><br><span class="line">F y n 4</span><br><span class="line">F x 9 n</span><br><span class="line">E</span><br><span class="line">E</span><br><span class="line">4 O(n^2)</span><br><span class="line">F x 1 n</span><br><span class="line">F x 1 10</span><br><span class="line">E</span><br><span class="line">E</span><br></pre></td></tr></table></figure><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">ERR</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">ERR</span><br></pre></td></tr></table></figure><h2 id="输入输出样例解释"><a href="#输入输出样例解释" class="headerlink" title="输入输出样例解释"></a>输入输出样例解释</h2><p>第一个程序 $i$ 从 1 到 1 是常数复杂度。<br>第二个程序 $x$ 从 1 到 $n$ 是 $n$ 的一次方的复杂度。<br>第三个程序有一个 F 开启循环却没有 E 结束，语法错误。<br>第四个程序二重循环，$n$ 的平方的复杂度。<br>第五个程序两个一重循环，$n$ 的一次方的复杂度。<br>第六个程序第一重循环正常，但第二重循环开始即终止（因为$n$远大于100，100大于4）。<br>第七个程序第一重循环无法进入，故为常数复杂度。<br>第八个程序第二重循环中的变量 $x$ 与第一重循环中的变量重复，出现语法错误②，输出 ERR。</p><h2 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h2><p>对于 30%的数据：不存在语法错误，数据保证小明给出的每个程序的前 $L/2$ 行一定为以 F 开头的语句，第 $L/2+1$ 行至第 $L$ 行一定为以 $E$ 开头的语句，$L \le 10$，若 $x$、$y$ 均 为整数，$x$ 一定小于 $y$，且只有 $y$ 有可能为 $n$。<br>对于 50%的数据：不存在语法错误，$L \le 100$，且若 $x$、$y$ 均为整数，$x$ 一定小于 $y$， 且只有 $y$ 有可能为 $n$。<br>对于 70%的数据：不存在语法错误，$L \le 100$。<br>对于 100%的数据：$L \le 100$。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>由于循环必须要让F与E配对，联想到括号匹配问题，所以用栈来模拟。<br>为了方便计算，我在栈里维护了三个值，分别表示当前循环所用变量名、程序执行到当前循环时的复杂度、当前循环是否处于被跳过的循环之中（即程序不会执行到）。在压栈时维护一下这三个值就好了，最后的复杂度即为最大的可被执行到的复杂度。<br>最后，注意一下关于字符串的读入处理就好了。</p><hr><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, L, kind, w;<span class="comment">//kind == 1:O(1); kind == 2: O(n^w)</span></span><br><span class="line"><span class="keyword">int</span> top, ans;</span><br><span class="line"><span class="keyword">char</span> com[<span class="number">100</span>], opt[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">bool</span> used[<span class="number">1000</span>], err;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">int</span> c;<span class="comment">//执行至此的时间复杂度 </span></span><br><span class="line"><span class="keyword">bool</span> dir;<span class="comment">//是否处于直接跳过的循环中 </span></span><br><span class="line">&#125;sta[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d "</span>, &amp;L);</span><br><span class="line"><span class="built_in">cin</span>.getline(com, <span class="number">99</span>);</span><br><span class="line"><span class="keyword">if</span>(com[<span class="number">2</span>] == <span class="string">'1'</span>)kind = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> now = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">while</span>(com[now] &gt;= <span class="string">'0'</span> &amp;&amp; com[now] &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">w = w * <span class="number">10</span> + com[now] - <span class="string">'0'</span>;</span><br><span class="line">now++;</span><br><span class="line">&#125;</span><br><span class="line">kind = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= L; i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>.getline(opt, <span class="number">99</span>);</span><br><span class="line"><span class="keyword">if</span>(err)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(opt[<span class="number">0</span>] == <span class="string">'F'</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(used[opt[<span class="number">2</span>]])&#123; err = <span class="number">1</span>; <span class="keyword">continue</span>; &#125;</span><br><span class="line">used[opt[<span class="number">2</span>]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> now = <span class="number">4</span>, l = <span class="number">0</span>, r = <span class="number">0</span>, pre = <span class="number">0</span>, nxt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((opt[now] &gt;= <span class="string">'0'</span> &amp;&amp; opt[now] &lt;= <span class="string">'9'</span>) || opt[now] == <span class="string">'n'</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(opt[now] == <span class="string">'n'</span>)pre = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span>l = l * <span class="number">10</span> + opt[now] - <span class="string">'0'</span>;</span><br><span class="line">now++;</span><br><span class="line">&#125;</span><br><span class="line">now++;</span><br><span class="line"><span class="keyword">while</span>((opt[now] &gt;= <span class="string">'0'</span> &amp;&amp; opt[now] &lt;= <span class="string">'9'</span>) || (opt[now] == <span class="string">'n'</span>))&#123;</span><br><span class="line"><span class="keyword">if</span>(opt[now] == <span class="string">'n'</span>)nxt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span>r = r * <span class="number">10</span> + opt[now] - <span class="string">'0'</span>;</span><br><span class="line">now++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pre == <span class="number">1</span> &amp;&amp; nxt == <span class="number">1</span>)&#123;</span><br><span class="line">sta[top+<span class="number">1</span>] = (Node)&#123;opt[<span class="number">2</span>], sta[top].c, sta[top].dir&#125;;</span><br><span class="line">top++;</span><br><span class="line"><span class="keyword">if</span>(sta[top].dir == <span class="number">0</span>)ans = max(ans, sta[top].c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pre == <span class="number">1</span> &amp;&amp; nxt == <span class="number">0</span>)&#123;</span><br><span class="line">sta[top+<span class="number">1</span>] = (Node)&#123;opt[<span class="number">2</span>], sta[top].c, <span class="number">1</span>&#125;;</span><br><span class="line">top++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pre == <span class="number">0</span> &amp;&amp; nxt == <span class="number">1</span>)&#123;</span><br><span class="line">sta[top+<span class="number">1</span>] = (Node)&#123;opt[<span class="number">2</span>], sta[top].c + <span class="number">1</span>, sta[top].dir&#125;;</span><br><span class="line">top++;</span><br><span class="line"><span class="keyword">if</span>(sta[top].dir == <span class="number">0</span>)ans = max(ans, sta[top].c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pre == <span class="number">0</span> &amp;&amp; nxt == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= r)&#123;</span><br><span class="line">sta[top+<span class="number">1</span>] = (Node)&#123;opt[<span class="number">2</span>], sta[top].c, sta[top].dir&#125;;</span><br><span class="line">top++;</span><br><span class="line"><span class="keyword">if</span>(sta[top].dir == <span class="number">0</span>)ans = max(ans, sta[top].c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">sta[top+<span class="number">1</span>] = (Node)&#123;opt[<span class="number">2</span>], sta[top].c, <span class="number">1</span>&#125;;</span><br><span class="line">top++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(opt[<span class="number">0</span>] == <span class="string">'E'</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(top == <span class="number">0</span>)err = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">used[sta[top].ch] = <span class="number">0</span>;</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(top)err = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(err)&#123; <span class="built_in">puts</span>(<span class="string">"ERR"</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="keyword">if</span>(kind == <span class="number">1</span> &amp;&amp; ans == <span class="number">0</span>)&#123; <span class="built_in">puts</span>(<span class="string">"Yes"</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="keyword">if</span>(kind == <span class="number">2</span> &amp;&amp; w == ans)&#123; <span class="built_in">puts</span>(<span class="string">"Yes"</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"No"</span>); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(sta, <span class="number">0</span>, <span class="keyword">sizeof</span> sta); top = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(com, <span class="number">0</span>, <span class="keyword">sizeof</span> com);</span><br><span class="line"><span class="built_in">memset</span>(opt, <span class="number">0</span>, <span class="keyword">sizeof</span> opt);</span><br><span class="line"><span class="built_in">memset</span>(used, <span class="number">0</span>, <span class="keyword">sizeof</span> used);</span><br><span class="line">err = <span class="number">0</span>;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line">kind = w = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line">init();</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> OI </category>
          
          <category> NOIP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[NOIP2017 D1 T1] 小凯的疑惑（数论）</title>
      <link href="/2018/04/14/NOIP2017-D1-T1-%E5%B0%8F%E5%87%AF%E7%9A%84%E7%96%91%E6%83%91%EF%BC%88%E6%95%B0%E8%AE%BA%EF%BC%89/"/>
      <url>/2018/04/14/NOIP2017-D1-T1-%E5%B0%8F%E5%87%AF%E7%9A%84%E7%96%91%E6%83%91%EF%BC%88%E6%95%B0%E8%AE%BA%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>小凯手中有两种面值的金币，两种面值均为正整数且彼此互素。每种金币小凯都有 无数个。在不找零的情况下，仅凭这两种金币，有些物品他是无法准确支付的。现在小凯想知道在无法准确支付的物品中，最贵的价值是多少金币？注意：输入数据保证存在小凯无法准确支付的商品。<br><a id="more"></a></p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>输入数据仅一行，包含两个正整数 $a$ 和 $ b $，它们之间用一个空格隔开，表示小凯手 中金币的面值。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>输出文件仅一行，一个正整数 $ N $，表示不找零的情况下，小凯用手中的金币不能准确支付的最贵的物品的价值。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 7</span><br></pre></td></tr></table></figure><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h2 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h2><p>小凯手中有面值为3和7的金币无数个，在不找零的前提下无法准确支付价值为1、 2、4、5、8、11 的物品，其中最贵的物品价值为 11，比 11 贵的物品都能买到，比如：<br>$ 12 = 3 \times 4 + 7 \times 0 $<br>$ 13 = 3 \times 2 + 7 \times 1 $<br>$ 14 = 3 \times 0 + 7 \times 2 $<br>$ 15 = 3 \times 5 + 7 \times 0 $</p><h2 id="数据范围与约定"><a href="#数据范围与约定" class="headerlink" title="数据范围与约定"></a>数据范围与约定</h2><p>对于 30%的数据： $ 1 \le a,b \le 50 $。<br>对于 60%的数据： $ 1 \le a,b \le 10^4 $。<br>对于 100%的数据：$ 1 \le a,b \le 10^9 $。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>因为$ (a,b) = 1 $，所以$ {a, 2a, 3a, …, (b-1)a} $为模$ b $的完全剩余系。<br>设$ T $是一个$ a, b $无法表示的数且$ T \equiv ka(mod \ b) $，$ (1 \le k \le b-1) $.<br>若$ T \ge ka $，则$ T $一定可以表示为$ ka+nb $，$ (n \ge 0) $，所以$ T &lt; ka $，则此时$ T $最大为$ ka-b $.<br>显然，当$ k $最大时$ T $最大，所以$ T = (b-1)a-b = ab - a - b $.</p><hr><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">LL a, b;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,  a * b - a - b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> OI </category>
          
          <category> NOIP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello, world!</title>
      <link href="/2018/04/07/Hello-world-0/"/>
      <url>/2018/04/07/Hello-world-0/</url>
      <content type="html"><![CDATA[<p>搞了一个下午+一个晚上，终于把hexo+github博客搭建起来了……（尚待后续优化）</p><p>这个博客用于几个板块：OI/ACM 学习笔记（主要），学习总结，随笔，其他</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>?</span><br><span class="line"><span class="keyword">continue</span>!</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/04/06/hello-world/"/>
      <url>/2018/04/06/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
