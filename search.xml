<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[ZJOI2007]矩阵游戏（二分图匹配）]]></title>
    <url>%2F2018%2F07%2F25%2FZJOI2007-%E7%9F%A9%E9%98%B5%E6%B8%B8%E6%88%8F%EF%BC%88%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目Description小Q是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏——矩阵游戏。矩阵游戏在一个N*N黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）列交换操作：选择矩阵的任意行列，交换这两列（即交换对应格子的颜色）游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色。对于某些关卡，小Q百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！！于是小Q决定写一个程序来判断这些关卡是否有解。 Input第一行包含一个整数T，表示数据的组数。接下来包含T组数据，每组数据第一行为一个整数N，表示方阵的大小；接下来N行为一个N*N的01矩阵（0表示白色，1表示黑色）。 Output输出文件应包含T行。对于每一组数据，如果该关卡有解，输出一行Yes；否则输出一行No。 Sample Input12345678220 00 130 0 10 1 01 0 0 Sample Output12NoYes Hint对于100%的数据，N ≤ 200 解题思路对每一个黑格子都在其横坐标与纵坐标之间连一条边，可得到一个二分图。而题目相当于要求交换后可以得到 $1\rightarrow 1,2\rightarrow 2,\cdots,n\rightarrow n$ 这样一种匹配方法。容易发现，只要这个二分图存在一种匹配方法使所有点都被匹配上，那么我们一定可以通过交换得到 $1\rightarrow 1,2\rightarrow 2,\cdots,n\rightarrow n$ 的匹配。所以我们只需要判断该二分图最大匹配是否为 $N$ 即可。用网络流实现，则当且仅当最大流等于 $N$ 时有解。 以下代码为 dinic 实现最大流。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int INF = 1e9;const int N = 405;int C, S, T, n, a;struct Edge&#123; int nxt, from, to, cap;&#125;edge[N*N*2];int head[N], edgeNum = 1;void addEdge(int from, int to, int cap)&#123; edge[++edgeNum] = (Edge)&#123;head[from], from, to, cap&#125;; head[from] = edgeNum;&#125;int lay[N];bool bfs()&#123; memset(lay, 0, sizeof lay); queue&lt;int&gt; q; q.push(S); lay[S] = 1; while(!q.empty())&#123; int cur = q.front(); q.pop(); for(int i = head[cur]; i; i = edge[i].nxt)&#123; if(edge[i].cap &lt;= 0) continue; if(!lay[edge[i].to])&#123; lay[edge[i].to] = lay[cur] + 1; q.push(edge[i].to); &#125; &#125; &#125; return lay[T];&#125;int dfs(int x, int minCap)&#123; if(x == T) return minCap; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(edge[i].cap &lt;= 0 || lay[edge[i].to] != lay[x] + 1) continue; int t = dfs(edge[i].to, min(minCap, edge[i].cap)); if(t)&#123; edge[i].cap -= t; edge[i^1].cap += t; return t; &#125; &#125; return 0;&#125;int dinic()&#123; int maxFlow = 0; while(bfs()) if(int flow = dfs(S, INF)) maxFlow += flow; return maxFlow;&#125;void init()&#123; memset(head, 0, sizeof head); edgeNum = 1;&#125;int main()&#123; scanf("%d", &amp;C); while(C--)&#123; init(); scanf("%d", &amp;n); S = n + n + 1, T = n + n + 2; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; scanf("%d", &amp;a); if(a)&#123; addEdge(i, j+n, 1); addEdge(j+n, i, 0); &#125; &#125; addEdge(S, i, 1); addEdge(i, S, 0); addEdge(i+n, T, 1); addEdge(T, i+n, 0); &#125; puts(dinic() == n ? "Yes" : "No"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>二分图</category>
        <category>网络流</category>
        <category>二分图匹配</category>
        <category>最大流/最小割</category>
      </categories>
      <tags>
        <tag>ZJOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[网络流24题]飞行员配对方案问题]]></title>
    <url>%2F2018%2F07%2F24%2F%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98-%E9%A3%9E%E8%A1%8C%E5%91%98%E9%85%8D%E5%AF%B9%E6%96%B9%E6%A1%88%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目背景第二次世界大战时期.. 描述英国皇家空军从沦陷国征募了大量外籍飞行员。由皇家空军派出的每一架飞机都需要配备在航行技能和语言上能互相配合的2 名飞行员，其中1 名是英国飞行员，另1名是外籍飞行员。在众多的飞行员中，每一名外籍飞行员都可以与其他若干名英国飞行员很好地配合。如何选择配对飞行的飞行员才能使一次派出最多的飞机。对于给定的外籍飞行员与英国飞行员的配合情况，试设计一个算法找出最佳飞行员配对方案，使皇家空军一次能派出最多的飞机。对于给定的外籍飞行员与英国飞行员的配合情况，编程找出一个最佳飞行员配对方案，使皇家空军一次能派出最多的飞机。 输入第 1 行有 2 个正整数 m 和 n。n 是皇家空军的飞行员总数(n&lt;100)；m 是外籍飞行员数(m&lt;=n)。外籍飞行员编号为 1~m；英国飞行员编号为 m+1~n。接下来每行有 2 个正整数 i 和 j，表示外籍飞行员 i 可以和英国飞行员 j 配合。最后以 2个-1 结束。 输出第 1 行是最佳飞行员配对方案一次能派出的最多的飞机数 M。接下来 M 行是最佳飞行员配对方案。每行有 2个正整数 i 和 j，表示在最佳飞行员配对方案中，飞行员 i 和飞行员 j 配对。如果所求的最佳飞行员配对方案不存在，则输出‘No Solution!’。 输入样例1234567891011125 101 71 82 62 92 103 73 84 74 85 10-1 -1 输出样例1234541 72 93 85 10 解题思路裸的二分图匹配问题用网络流做重在构图：源点 S 向 1~m 连容量为 1 的边，m+1~n 向汇点 T 连容量为 1 的边，能匹配的也连容量为 1 的边。这样，最大匹配即是最大流。 下面是 Dinic 算法跑最大流的代码。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int INF = 1e9;const int N = 205;int n, m, u, v, S, T;struct Edge&#123; int from, nxt, to, cap;&#125;edge[N*N*2];int head[N], edgeNum = 1;void addEdge(int from, int to, int cap)&#123; edge[++edgeNum].nxt = head[from]; edge[edgeNum].from = from; edge[edgeNum].to = to; edge[edgeNum].cap = cap; head[from] = edgeNum;&#125;int lay[N];bool bfs()&#123; memset(lay, 0, sizeof lay); queue&lt;int&gt; q; q.push(S); lay[S] = 1; while(!q.empty())&#123; int cur = q.front(); q.pop(); for(int i = head[cur]; i; i = edge[i].nxt)&#123; if(edge[i].cap &lt;= 0) continue; if(!lay[edge[i].to])&#123; lay[edge[i].to] = lay[cur] + 1; q.push(edge[i].to); &#125; &#125; &#125; return lay[T];&#125;int dfs(int x, int minn)&#123; if(x == T) return minn; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(edge[i].cap &lt;= 0 || lay[edge[i].to] != lay[x] + 1) continue; int t = dfs(edge[i].to, min(minn, edge[i].cap)); if(t)&#123; edge[i].cap -= t; edge[i^1].cap += t; return t; &#125; &#125; return 0;&#125;int dinic()&#123; int maxFlow = 0; while(bfs()) if(int flow = dfs(S, INF)) maxFlow += flow; return maxFlow;&#125;int main()&#123; scanf("%d%d", &amp;m, &amp;n); S = n + 1, T = n + 2; for(int i = 1; i &lt;= m; i++)&#123; addEdge(S, i, 1); addEdge(i, S, 0); &#125; for(int i = m + 1; i &lt;= n; i++)&#123; addEdge(i, T, 1); addEdge(T, i, 0); &#125; while(scanf("%d%d", &amp;u, &amp;v) &amp;&amp; (u != -1 &amp;&amp; v != -1))&#123; addEdge(u, v, 1); addEdge(v, u, 0); &#125; int ans = dinic(); if(ans == 0) return puts("No Solution!"), 0; printf("%d\n", ans); for(int i = 1; i &lt;= edgeNum; i += 2) if(edge[i].cap == 1 &amp;&amp; edge[i].from != S &amp;&amp; edge[i].from != T &amp;&amp; edge[i].to != S &amp;&amp; edge[i].to != T) printf("%d %d\n", edge[i].from, edge[i].to); return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>二分图</category>
        <category>网络流</category>
        <category>二分图匹配</category>
        <category>最大流/最小割</category>
      </categories>
      <tags>
        <tag>网络流24题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ZJOI2006]书架（平衡树）]]></title>
    <url>%2F2018%2F07%2F23%2FZJOI2006-%E4%B9%A6%E6%9E%B6%EF%BC%88%E5%B9%B3%E8%A1%A1%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述小T有一个很大的书柜。这个书柜的构造有些独特，即书柜里的书是从上至下堆放成一列。她用$1$到$n$的正整数给每本书都编了号。小T在看书的时候，每次取出一本书，看完后放回书柜然后再拿下一本。由于这些书太有吸引力了，所以她看完后常常会忘记原来是放在书柜的什么位置。不过小T的记忆力是非常好的，所以每次放书的时候至少能够将那本书放在拿出来时的位置附近，比如说她拿的时候这本书上面有$X$本书，那么放回去时这本书上面就只可能有$X-1$、$X$或$X+1$本书。当然也有特殊情况，比如在看书的时候突然电话响了或者有朋友来访。这时候粗心的小T会随手把书放在书柜里所有书的最上面或者最下面，然后转身离开。久而久之，小T的书柜里的书的顺序就会越来越乱，找到特定的编号的书就变得越来越困难。于是她想请你帮她编写一个图书管理程序，处理她看书时的一些操作，以及回答她的两个提问：(1)编号为$X$的书在书柜的什么位置；(2)从上到下第$i$本书的编号是多少。 输入第一行有两个数$n,m$，分别表示书的个数以及命令的条数；第二行为$n$个正整数：第$i$个数表示初始时从上至下第$i$个位置放置的书的编号；第三行到$m+2$行，每行一条命令。命令有5种形式：1．Top S——表示把编号为$S$的书放在最上面。2． Bottom S——表示把编号为$S$的书放在最下面。3． Insert S T——$T∈\{-1,0,1\}$，若编号为$S$的书上面有$X$本书，则这条命令表示把这本书放回去后它的上面有$X+T$本书；4． Ask S——询问编号为$S$的书的上面目前有多少本书。5． Query S——询问从上面数起的第$S$本书的编号。 输出对于每一条Ask或Query语句你应该输出一行，一个数，代表询问的答案。 输入样例12345678910111210 101 3 2 7 5 8 10 4 9 6Query 3Top 5Ask 6Bottom 3Ask 3Top 6Insert 4 -1Query 5Query 2Ask 2 输出样例123456299753 说明100%的数据，$n,m &lt;= 80000$ 解题思路用平衡树可以完成这些操作： Top S：将该元素旋转至根，然后将其左子树连到它的后继上 Bottom S：将该元素旋转至根，然后将其右子树连到它的前驱上 Insert S T：将该元素与其前驱或后继交换信息 Ask S：将该元素旋转至根，返回其左子树大小 Query S：在树上直接找即可 时间复杂度：$O(M\log_2N)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 80005;int n, m, q, qt, a[N], pos[N];char opt[10];struct BST&#123;#define lson tr[x].son[0]#define rson tr[x].son[1] struct Splay&#123; int fa, son[2]; int size, id; &#125;tr[N]; int root = 0, cnt = 0; inline int newNode()&#123; cnt++; tr[cnt].fa = tr[cnt].son[0] = tr[cnt].son[1] = 0; tr[cnt].size = 1, tr[cnt].id = 0; return cnt; &#125; inline void pushup(int x)&#123; tr[x].size = tr[lson].size + tr[rson].size + 1; &#125; inline int build(int l, int r, int f)&#123; if(l &gt; r) return 0; int mid = (l + r) &gt;&gt; 1; int x = newNode(); tr[x].id = a[mid]; pos[a[mid]] = x; tr[x].fa = f; tr[x].son[0] = build(l, mid-1, x); tr[x].son[1] = build(mid+1, r, x); pushup(x); return x; &#125; inline void rotate(int x, int kind)&#123; int y = tr[x].fa, z = tr[y].fa, B = tr[x].son[kind]; tr[x].son[kind] = y, tr[y].son[!kind] = B, tr[z].son[tr[z].son[1] == y] = x; tr[x].fa = z, tr[y].fa = x, tr[B].fa = y; pushup(y), pushup(x); &#125; inline void splay(int x, int goal)&#123; if(x == goal) return; while(tr[x].fa != goal)&#123; int y = tr[x].fa, z = tr[y].fa; int dir1 = !(tr[y].son[1] == x), dir2 = !(tr[z].son[1] == y); if(z == goal) rotate(x, dir1); else&#123; if(dir1 == dir2) rotate(y, dir2); else rotate(x, dir1); rotate(x, dir2); &#125; &#125; if(goal == 0) root = x; &#125; inline int find(int k)&#123; int now = root; while(k)&#123; if(k &lt;= tr[tr[now].son[0]].size) now = tr[now].son[0]; else if(k == tr[tr[now].son[0]].size + 1) return now; else&#123; k -= tr[tr[now].son[0]].size + 1; now = tr[now].son[1]; &#125; &#125; return now; &#125; inline void top(int x)&#123; x = pos[x]; splay(x, 0); if(!tr[x].son[0]) return; if(!tr[x].son[1]) tr[x].son[1] = tr[x].son[0], tr[x].son[0] = 0; else&#123; int p = find(tr[tr[x].son[0]].size + 2); tr[p].son[0] = tr[x].son[0], tr[tr[x].son[0]].fa = p; tr[x].son[0] = 0; splay(tr[p].son[0], 0); &#125; &#125; inline void bot(int x)&#123; x = pos[x]; splay(x, 0); if(!tr[x].son[1]) return; if(!tr[x].son[0]) tr[x].son[0] = tr[x].son[1], tr[x].son[1] = 0; else&#123; int p = find(tr[tr[x].son[0]].size); tr[p].son[1] = tr[x].son[1], tr[tr[x].son[1]].fa = p; tr[x].son[1] = 0; splay(tr[p].son[1], 0); &#125; &#125; inline void insert(int x, int t)&#123; if(!t) return; x = pos[x]; splay(x, 0); int p = find(t == -1 ? tr[tr[root].son[0]].size : tr[tr[root].son[0]].size + 2); swap(tr[root].id, tr[p].id); swap(pos[tr[root].id], pos[tr[p].id]); &#125; inline int ask(int x)&#123; x = pos[x]; splay(x, 0); return tr[tr[x].son[0]].size; &#125; inline int query(int k)&#123; return tr[find(k)].id; &#125; inline void print(int x)&#123; if(tr[x].son[0]) print(tr[x].son[0]); printf("%d ", tr[x].id); if(tr[x].son[1]) print(tr[x].son[1]); &#125;&#125;T;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); T.root = T.build(1, n, 0); while(m--)&#123; scanf("%s%d", opt, &amp;q); switch(opt[0])&#123; case 'T': T.top(q); break; case 'B': T.bot(q); break; case 'I': scanf("%d", &amp;qt); T.insert(q, qt); break; case 'A': printf("%d\n", T.ask(q)); break; case 'Q': printf("%d\n", T.query(q)); break; default: break; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>平衡树</category>
      </categories>
      <tags>
        <tag>ZJOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2009 T3]最优贸易（分层图spfa / 两次spfa / tarjan + topo）]]></title>
    <url>%2F2018%2F07%2F07%2FNOIP2009-T3-%E6%9C%80%E4%BC%98%E8%B4%B8%E6%98%93%EF%BC%88%E5%88%86%E5%B1%82%E5%9B%BEspfa-%E4%B8%A4%E6%AC%A1spfa-tarjan-topo%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述$C$ 国有 $n$ 个大城市和 $m$ 条道路，每条道路连接这 $n$ 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 $m$ 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 $1$ 条。$C$ 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。商人阿龙来到 $C$ 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 $C$ 国 n 个城市的标号从 $1 \sim n$ ，阿龙决定从 $1$ 号城市出发，并最终在 $n$ 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 $n$ 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品――水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 $C$ 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。现在给出 $n$ 个城市的水晶球价格， $m$ 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。 输入第一行包含 $2$ 个正整数 $n$ 和 $m$ ，中间用一个空格隔开，分别表示城市的数目和道路的数目。第二行 $n$ 个正整数，每两个整数之间用一个空格隔开，按标号顺序分别表示这 $n$ 个城市的商品价格。接下来 $m$ 行，每行有 $3$ 个正整数 $x,y,z$ ，每两个整数之间用一个空格隔开。如果 $z=1$ ，表示这条道路是城市 $x$ 到城市 $y$ 之间的单向道路；如果 $z=2$ ，表示这条道路为城市 $x$ 和城市 $y$ 之间的双向道路。 输出一 个整数，表示最多能赚取的旅费。如果没有进行贸易，则输出 $0$ 。 输入样例12345675 5 4 3 5 6 1 1 2 1 1 4 1 2 3 2 3 5 1 4 5 2 输出样例15 数据范围输入数据保证 $1$ 号城市可以到达 $n$ 号城市。对于 10%的数据， $1≤n≤6$ 。对于 30%的数据， $1≤n≤100$ 。对于 50%的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。对于 100%的数据，$1≤n≤100000$ ，$1≤m≤500000$ ， $1≤x$ ， $y≤n$ ， 1≤z≤21≤z≤2 ， $1≤$ 各城市水晶球价格 $≤100$ 。 解题思路（共3种方法）法1——分层图spfa分层图是一个神奇的东西，建的好可以大大简化题目。针对这道题，我们可以把图分三层： 第一层表示买之前，第二层表示买之后卖之前，第三层表示卖之后； 每一层内部边权设为 $0$； 对于一个点 $i$，设 $i$ 能到 $j$，则从 $i$ 连一条边权为 $-v[i]$ 的单向边到 $j+n$（即 $j$ 在第二层图中对应的点），表示在 $i$ 买入后走到 $j$； 同理，从 $i+n$ 连一条边权为 $v[i]$ 的单向边到 $j+n+n$（即 $j$ 在第三层图中对应的点），表示在 $i$ 卖出后走到 $j$； 最后将 $n$ 和 $n+n+n$ 都连向一个终点 $T$。 那么，从 $1$ 出发到 $T$，要么一直在第一层中移动，表示没有进行买卖；要么从第一层经过第二层到达第三层，表示经过了一次买卖操作。可以发现，这样我们就把所有买卖情况考虑到了，因此，最后做一个简单的spfa找最长路即可。 法2——两次spfa设 $minPrice[i]$ 表示从 $1$ 到 $i$ 的路线中经过的最小价格，$maxPrice[i]$ 表示从 $i$ 到 $n$ 的路线中经过的最大价格，那么 $ans = \max\limits_{i=1}^{n} (maxPrice[i]-minPrice[i])$可以先正向用 spfa 求出 $minPrice$，再反向用 spfa 求出 $maxPrice$ 法3——tarjan+topo从50%的数据范围中得到启发，如果原图是一个DAG，那么我们可以用拓扑序得到答案：用拓扑序遍历该图，同时记录下历史最小价格，每到一个点用它的价格减去历史最小价格来更新答案，最后就能得到最大利润了。但是原图可能存在环，怎么办？我们可以用 tarjan 缩点。因为在同一个强连通分量中可以随意走动，所以缩点后新点的最低价格就是强连通分量中的最低价格，新点的最高价格就是强连通分量中的最高价格，于是我们成功把图转成了一个DAG，就可以用上述方法解决问题了。 Code#1分层图spfa12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int N = 100005;const int M = 500005;const int INF = 1e9;int n, m, v[N], x, y, z, T, S;struct Edge&#123; int nxt, to, dis;&#125;edge[M&lt;&lt;2];int head[N*3], edgeNum;void addEdge(int from, int to, int dis)&#123; edge[++edgeNum].nxt = head[from]; edge[edgeNum].to = to; edge[edgeNum].dis = dis; head[from] = edgeNum;&#125;int dis[N*3];bool inq[N*3];void spfa()&#123; for(int i = 1; i &lt;= n * 3; i++) dis[i] = -INF; queue&lt;int&gt; q; q.push(S); dis[S] = 0; inq[S] = 1; while(!q.empty())&#123; int cur = q.front(); q.pop(); inq[cur] = 0; for(int i = head[cur]; i; i = edge[i].nxt)&#123; if(dis[edge[i].to] &lt; dis[cur] + edge[i].dis)&#123; dis[edge[i].to] = dis[cur] + edge[i].dis; if(!inq[edge[i].to])&#123; q.push(edge[i].to); inq[edge[i].to] = 1; &#125; &#125; &#125; &#125;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;v[i]); for(int i = 1; i &lt;= m; i++)&#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); addEdge(x, y, 0); addEdge(x+n, y+n, 0); addEdge(x+n+n, y+n+n, 0); addEdge(x, y+n, -v[x]); addEdge(x+n, y+n+n, v[x]); if(z == 2)&#123; addEdge(y, x, 0); addEdge(y+n, x+n, 0); addEdge(y+n+n, x+n+n, 0); addEdge(y, x+n, -v[y]); addEdge(y+n, x+n+n, v[y]); &#125; &#125; S = 1, T = n+n+n+1; addEdge(n, T, 0); addEdge(n+n+n, T, 0); spfa(); printf("%d\n", dis[T]); return 0;&#125; Code#2两次spfa 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int MAXN = 100005;const int MAXM = 500005;int n, m, p[MAXN], u, v, q, ans;struct Edge&#123; int nxt, to;&#125;edge[MAXM&lt;&lt;1], fedge[MAXM&lt;&lt;1];int head[MAXN], edge_num;int fhead[MAXN], fedge_num;void add_edge(int from, int to)&#123; edge[++edge_num].nxt = head[from]; edge[edge_num].to = to; head[from] = edge_num; fedge[++fedge_num].nxt = fhead[to]; fedge[fedge_num].to = from; fhead[to] = fedge_num;&#125;int max_price[MAXN], min_price[MAXN];bool inq[MAXN];void spfa1()&#123; memset(inq, 0, sizeof inq); memset(min_price, 0x7f, sizeof min_price); queue&lt;int&gt; q; q.push(1); inq[1] = 1; min_price[1] = p[1]; while(!q.empty())&#123; int cur = q.front(); q.pop(); inq[cur] = 0; for(int i = head[cur]; i; i = edge[i].nxt)&#123; if(min_price[edge[i].to] &gt; min(min_price[cur], p[edge[i].to]))&#123; min_price[edge[i].to] = min(min_price[cur], p[edge[i].to]); if(!inq[edge[i].to])&#123; q.push(edge[i].to); inq[edge[i].to] = 1; &#125; &#125; &#125; &#125;&#125;void spfa2()&#123; memset(inq, 0, sizeof inq); memset(max_price, 0, sizeof max_price); queue&lt;int&gt; q; q.push(n); inq[n] = 1; max_price[n] = p[n]; while(!q.empty())&#123; int cur = q.front(); q.pop(); inq[cur] = 0; for(int i = fhead[cur]; i; i = fedge[i].nxt)&#123; if(max_price[fedge[i].to] &lt; max(max_price[cur], p[fedge[i].to]))&#123; max_price[fedge[i].to] = max(max_price[cur], p[fedge[i].to]); if(!inq[fedge[i].to])&#123; q.push(fedge[i].to); inq[fedge[i].to] = 1; &#125; &#125; &#125; &#125;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;p[i]); for(int i = 1; i &lt;= m; i++)&#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;q); add_edge(u, v); if(q == 2) add_edge(v, u); &#125; spfa1(); spfa2(); for(int i = 1; i &lt;= n; i++) ans = max(ans, max_price[i] - min_price[i]); printf("%d", ans); return 0;&#125; Code#3tarjan+topo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;const int MAXM = 500005;const int MAXN = 100005;int n, m, x, y, z, p[MAXN], minprice = 0x7fffffff, maxp[MAXN], minp[MAXN];inline int max(int a, int b)&#123; return a &gt; b ? a : b;&#125;inline int min(int a, int b)&#123; return a &lt; b ? a : b;&#125;struct Edge&#123; int nxt, to;&#125;edge[MAXM&lt;&lt;1], e[MAXM&lt;&lt;1], fe[MAXM&lt;&lt;1];int head[MAXN], edge_num;int fh[MAXN], fe_n;void add_edge(int from, int to)&#123; edge[++edge_num].nxt = head[from]; edge[edge_num].to = to; head[from] = edge_num; fe[++fe_n].nxt = fh[to]; fe[fe_n].to = from; fh[to] = fe_n;&#125;bool vis[MAXN];void dfs(int x)&#123; vis[x] = 1; for(int i = fh[x]; i; i = fe[i].nxt)&#123; if(!vis[fe[i].to]) dfs(fe[i].to); &#125;&#125;int h[MAXN], e_n, ind[MAXN];void a_e(int from, int to)&#123; e[++e_n].nxt = h[from]; e[e_n].to = to; h[from] = e_n; ind[to]++;&#125;int low[MAXN], dfn[MAXN], belong[MAXN], scc, dex;bool ins[MAXN];stack&lt;int&gt; s;void tarjan(int x)&#123; s.push(x); ins[x] = 1; low[x] = dfn[x] = ++dex; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(!vis[edge[i].to]) continue; if(!dfn[edge[i].to])&#123; tarjan(edge[i].to); low[x] = min(low[x], low[edge[i].to]); &#125; else if(ins[edge[i].to]) low[x] = min(low[x], dfn[edge[i].to]); &#125; if(low[x] == dfn[x])&#123; scc++; while(1)&#123; int cur = s.top(); s.pop(); ins[cur] = 0; belong[cur] = scc; maxp[scc] = max(maxp[scc], p[cur]); minp[scc] = min(minp[scc], p[cur]); if(cur == x) break; &#125; &#125;&#125;int f[MAXN], ans;void topo()&#123; queue&lt;int&gt; q; for(int s = 1; s &lt;= scc; s++) if(!ind[s]) q.push(s); while(!q.empty())&#123; int cur = q.front(); q.pop(); for(int i = h[cur]; i; i = e[i].nxt)&#123; ind[e[i].to]--; if(!ind[e[i].to])&#123; q.push(e[i].to); minprice = min(minprice, minp[e[i].to]); ans = max(ans, maxp[e[i].to] - minprice); &#125; &#125; &#125;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;p[i]); for(int i = 1; i &lt;= m; i++)&#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); add_edge(x, y); if(z == 2) add_edge(y, x); &#125; dfs(n); memset(maxp, 0, sizeof maxp); memset(minp, 0x7f, sizeof minp); for(int i = 1; i &lt;= n; i++) if(!dfn[i] &amp;&amp; vis[i]) tarjan(i); for(int i = 1; i &lt;= n; i++) for(int j = head[i]; j; j = edge[j].nxt) if(vis[edge[j].to] &amp;&amp; belong[edge[j].to] != belong[i]) a_e(belong[i], belong[edge[j].to]); topo(); printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>最短路</category>
        <category>强连通分量</category>
        <category>拓扑序</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder ARC099]E - Independence（图论，二分图染色）]]></title>
    <url>%2F2018%2F07%2F06%2FAtCoder-ARC099-E-Independence%EF%BC%88%E5%9B%BE%E8%AE%BA%EF%BC%8C%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9F%93%E8%89%B2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[E - IndependenceTime limit : 2sec / Memory limit : 1024MBScore : 700 points Problem StatementIn the State of Takahashi in AtCoderian Federation, there are $N$ cities, numbered $1,2,…,N$. $M$ bidirectional roads connect these cities. The $i$-th road connects City $A_i$ and City $B_i$. Every road connects two distinct cities. Also, for any two cities, there is at most one road that directly connects them. One day, it was decided that the State of Takahashi would be divided into two states, Taka and Hashi. After the division, each city in Takahashi would belong to either Taka or Hashi. It is acceptable for all the cities to belong Taka, or for all the cities to belong Hashi. Here, the following condition should be satisfied: Any two cities in the same state, Taka or Hashi, are directly connected by a road. Find the minimum possible number of roads whose endpoint cities belong to the same state. If it is impossible to divide the cities into Taka and Hashi so that the condition is satisfied, print -1. Constraints$2≤N≤700$$0≤M≤N(N?1)/2$$1≤A_i≤N$$1≤B_i≤N$$A_i≠B_i$If $i≠j$, at least one of the following holds: $A_i≠A_j$ and $B_i≠B_j$.If $i≠j$, at least one of the following holds: $A_i≠B_j$ and $B_i≠A_j$. InputInput is given from Standard Input in the following format: $N$ $M$$A_1 B_1$$A_2 B_2$:$A_M$ $B_M$ OutputPrint the answer. Samples Input Output 5 51 21 33 43 54 5 4 5 11 2 -1 4 31 21 32 3 3 10 397 27 15 65 89 102 88 73 1010 18 102 37 43 94 103 46 16 79 59 76 99 44 67 58 32 59 210 78 68 97 35 34 56 32 105 104 26 28 410 6 21 Sample#1:For example, if the cities 1,2 belong to Taka and the cities 3,4,5 belong to Hashi, the condition is satisfied. Here, the number of roads whose endpoint cities belong to the same state, is 4. Sample#2:In this sample, the condition cannot be satisfied regardless of which cities belong to each state. 解题思路题目大意：将一个图分成两个子图，使得每一个子图都是完全图。所有不相连的点不能再一个子图里，那么我们就对这些不相连点进行建边，然后二分图染色（即建立了一个原图的补图）在新图中，同一个连通块中且是相同颜色的点一定在同一个子图里，而不同连通块中不同颜色的点可以放在一起那么，用一个布尔数组 $s$ 做一个统计，$s[i]$ 表示是否存在大小为 $i$ 的子图，答案取最小情况即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 705;const int M = 490005;int n, m, u, v, ans = 0x7fffffff;bool g[N][N], s[N], t[N];int col[N], cnt[2];void dfs(int x, int c)&#123; col[x] = c; cnt[c == 1]++; for(int i = 1; i &lt;= n; i++)&#123; if(i == x || g[x][i]) continue; if(!col[i]) dfs(i, -c); else if(col[i] == c)&#123; puts("-1"); exit(0); &#125; &#125;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= m; i++)&#123; scanf("%d%d", &amp;u, &amp;v); g[u][v] = g[v][u] = 1; &#125; s[0] = 1; for(int i = 1; i &lt;= n; i++)&#123; if(col[i]) continue; cnt[0] = cnt[1] = 0; dfs(i, 1); memset(t, 0, sizeof t); for(int j = 0; j &lt;= n; j++)&#123; t[j+cnt[0]] |= s[j]; t[j+cnt[1]] |= s[j]; &#125; for(int j = 0; j &lt;= n; j++) s[j] = t[j]; &#125; for(int i = 0; i &lt;= n; i++) if(s[i]) ans = min(ans, i*(i-1)/2 + (n-i)*(n-i-1)/2); printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>二分图</category>
        <category>二分图染色</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[轮到我们了]]></title>
    <url>%2F2018%2F06%2F08%2F%E8%BD%AE%E5%88%B0%E6%88%91%E4%BB%AC%E4%BA%86%2F</url>
    <content type="text"><![CDATA[下午，高考结束的铃声终究是响了。此时此刻，高三的学长学姐们正式告别了十年寒窗的生涯——也意味着高三的接力棒，传到了我们手中。终于，轮到我们了。 我曾听说过高三的紧张与压力，也听说过高三的奋斗与无悔，只是，从来没有这么靠近过这一时刻。现在的我，不免有些紧张，也有些期待。有人做了这样一个比喻：如果说人生是一个椭圆轨道，梦想是椭圆的焦点，那么，高三就是距离焦点最近的地方——这是你最靠近你的梦想的时刻，也是你速度最快、最容易错过梦想的时刻。可以见得，高三是何等的关键。 从小学一年级开始，我们就开始了12km伏案苦读的长跑，现在，终于到了最后1km。这一路来，多少路边迷人的风景都没扰乱我们前行的意志，多少牵绊都没影响我们坚定的步伐。我们已经很优秀了，只是这最后一千米，我们还需要咬咬牙，再努力一些，坚持下去。因为，努力过，便无怨无悔。 是的，轮到我们了。愿我们不忘初心，砥砺前行。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces 988.F] Rain and Umbrellas（序列dp）]]></title>
    <url>%2F2018%2F06%2F03%2FCodeforces-988-F-Rain-and-Umbrellas%EF%BC%88%E5%BA%8F%E5%88%97dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[F. Rain and Umbrellastime limit per test:2 secondsmemory limit per test:256 megabytesinput:standard inputoutput:standard output Polycarp lives on a coordinate line at the point $x=0$. He goes to his friend that lives at the point $x=a$. Polycarp can move only from left to right, he can pass one unit of length each second. Now it’s raining, so some segments of his way are in the rain. Formally, it’s raining on $n$ non-intersecting segments, the $i$-th segment which is in the rain is represented as $[l_i,r_i]$ ($0≤l_i&lt;r_i≤a$). There are $m$ umbrellas lying on the line, the $i$-th umbrella is located at point $x_i$ ($0≤x_i≤a$) and has weight $p_i$. When Polycarp begins his journey, he doesn’t have any umbrellas. During his journey from $x=0$ to $x=a$ Polycarp can pick up and throw away umbrellas. Polycarp picks up and throws down any umbrella instantly. He can carry any number of umbrellas at any moment of time. Because Polycarp doesn’t want to get wet, he must carry at least one umbrella while he moves from $x$ to $x+1$ if a segment $[x,x+1]$ is in the rain (i.e. if there exists some $i$ such that $l_i≤x$ and $x+1≤r_i$). The condition above is the only requirement. For example, it is possible to go without any umbrellas to a point where some rain segment starts, pick up an umbrella at this point and move along with an umbrella. Polycarp can swap umbrellas while he is in the rain. Each unit of length passed increases Polycarp’s fatigue by the sum of the weights of umbrellas he carries while moving. Can Polycarp make his way from point $x=0$ to point $x=a$? If yes, find the minimum total fatigue after reaching $x=a$, if Polycarp picks up and throws away umbrellas optimally. InputThe first line contains three integers $a$, $n$ and $m$ ($1≤a,m≤2000,1≤n≤⌈\frac{a}{2}⌉$) — the point at which Polycarp’s friend lives, the number of the segments in the rain and the number of umbrellas. Each of the next $n$ lines contains two integers $l_i$ and $r_i$ ($0≤l_i&lt;r_i≤a$) — the borders of the $i$-th segment under rain. It is guaranteed that there is no pair of intersecting segments. In other words, for each pair of segments $i$ and $j$ either $r_i&lt;l_j$ or $r_j&lt;l_i$. Each of the next $m$ lines contains two integers $x_i$ and $p_i$ ($0≤x_i≤a$, $1≤p_i≤10^5$) — the location and the weight of the $i$-th umbrella. OutputPrint “-1“ (without quotes) if Polycarp can’t make his way from point $x=0$ to point $x=a$. Otherwise print one integer — the minimum total fatigue after reaching $x=a$, if Polycarp picks up and throws away umbrellas optimally. Examples input output 10 2 43 78 100 103 48 11 2 14 10 1 10 90 5 45 10 1 10 91 5 -1 NoteIn the first example the only possible strategy is to take the fourth umbrella at the point $x=1$, keep it till the point $x=7$ (the total fatigue at $x=7$ will be equal to $12$), throw it away, move on from $x=7$ to $x=8$ without an umbrella, take the third umbrella at x=8 and keep it till the end (the total fatigue at $x=10$ will be equal to $14$). In the second example the only possible strategy is to take the first umbrella, move with it till the point $x=9$, throw it away and proceed without an umbrella till the end. 解题思路这肯定是一道 dp 题。注意题目是从 $0$ 位置开始的，下列解法均先把所有位置右移了1格 首先有一个很显然的贪心：不可能同时拿着多把伞。然后预处理一下哪些地方下雨，哪些地方有伞，每把伞在什么位置 $O(n\cdot a+m)$ 下面是 dp：考虑到不同的状态取决于当前所在位置和当前拿着的伞，令 $dp[i][j]$ 表示走到 $i$ 时拿着第 $j$ 把伞（$j=0$ 表示没拿伞），分情况转移（已知 $dp[i][j]$，刷表法）： 拿着第 $j$ 把伞走到 $i+1$：$dp[i+1][j] = min(dp[i+1][j],dp[i][j] + weight[j])$前提： $j \neq 0$ 放下第 $j$ 把伞走到 $i+1$：$dp[i+1][0] = min(dp[i+1][0], dp[i][j])$前提：$i$ 处不下雨 拿起 $i$ 处的最轻的伞（假设是第 $k$ 把伞）走到 $i+1$：$dp[i+1][k] = min(dp[i+1][k], dp[i][j] + w[k]$前提：$i$ 处有伞 边界条件为 $dp[0][0] = 0$答案就是 $\min\limits_{i=0}^m dp[a][i]$ 坑点：同一个位置可以有多把伞！ 时间复杂度 $O(n\cdot a)$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 2005;bool rain[N];struct Umbrella&#123; int pos, w;&#125;umb[N];int a, n, m, x, y, umbre[N];int dp[N][N], ans = 1e9;int main()&#123; scanf("%d%d%d", &amp;a, &amp;n, &amp;m); a++; for(int i = 1; i &lt;= n; i++)&#123; scanf("%d%d", &amp;x, &amp;y); x++, y++; for(int j = x; j &lt; y; j++) rain[j] = 1; &#125; for(int i = 1; i &lt;= m; i++)&#123; scanf("%d%d", &amp;x, &amp;y); x++; umb[i].pos = x; umb[i].w = y; if(!umbre[x] || (umbre[x] &amp;&amp; y &lt; umb[umbre[x]].w)) umbre[x] = i; &#125; memset(dp, 0x3f, sizeof dp); dp[0][0] = 0; for(int i = 0; i &lt; a; i++)&#123; for(int j = 0; j &lt;= m; j++)&#123; if(umb[j].pos &gt; i) continue; if(j) dp[i+1][j] = min(dp[i+1][j], dp[i][j] + umb[j].w); if(!rain[i]) dp[i+1][0] = min(dp[i+1][0], dp[i][j]); if(umbre[i]) dp[i+1][umbre[i]] = min(dp[i+1][umbre[i]], dp[i][j] + umb[umbre[i]].w); &#125; &#125; for(int i = 0; i &lt;= m; i++) ans = min(ans, dp[a][i]); if(ans == 1e9) puts("-1"); else printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>序列dp</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces 985.E] Pencils and Boxes（dp，前缀和优化）]]></title>
    <url>%2F2018%2F05%2F27%2FCodeforces-985-E-Pencils-and-Boxes%EF%BC%88dp%EF%BC%8C%E5%89%8D%E7%BC%80%E5%92%8C%E4%BC%98%E5%8C%96%EF%BC%89%2F</url>
    <content type="text"><![CDATA[E. Pencils and Boxestime limit per test: 2 secondsmemory limit per test: 256 megabytesinput: standard inputoutput: standard output Mishka received a gift of multicolored pencils for his birthday! Unfortunately he lives in a monochrome world, where everything is of the same color and only saturation differs. This pack can be represented as a sequence $a_1, a_2, …, a_n$ of n integer numbers — saturation of the color of each pencil. Now Mishka wants to put all the mess in the pack in order. He has an infinite number of empty boxes to do this. He would like to fill some boxes in such a way that: Each pencil belongs to exactly one box; Each non-empty box has at least $k$ pencils in it; If pencils $i$ and $j$ belong to the same box, then $|a_i - a_j| ≤ d$, where $|x|$ means absolute value of $x$. Note that the opposite is optional, there can be pencils $i$ and $j$ such that $|a_i - a_j| ≤ d$ and they belong to different boxes. Help Mishka to determine if it’s possible to distribute all the pencils into boxes. Print &quot;YES&quot; if there exists such a distribution. Otherwise print &quot;NO&quot;. InputThe first line contains three integer numbers $n$, $k$ and $d$ ($1 ≤ k ≤ n ≤ 5·10^5$, $0 ≤ d ≤ 10^9$) — the number of pencils, minimal size of any non-empty box and maximal difference in saturation between any pair of pencils in the same box, respectively. The second line contains n integer numbers $a_1, a_2, …, a_n$ ($1 ≤ a_i ≤ 10^9$) — saturation of color of each pencil. OutputPrint &quot;YES&quot; if it’s possible to distribute all the pencils into boxes and satisfy all the conditions. Otherwise print &quot;NO&quot;. Examples Input Output 6 3 107 2 7 7 4 2 YES 6 2 34 5 3 13 4 10 YES 3 2 510 16 22 NO NoteIn the first example it is possible to distribute pencils into $2$ boxes with $3$ pencils in each with any distribution. And you also can put all the pencils into the same box, difference of any pair in it won’t exceed $10$. In the second example you can split pencils of saturations $[4, 5, 3, 4]$ into $2$ boxes of size $2$ and put the remaining ones into another box. 解题思路将数列排序，若有解，则一定存在一种数列划分的方式（即把连续一段铅笔放进一个盒子中）满足条件。设 $dp[i]$ 表示前 $i$ 个铅笔能否放进盒子中（$1$能，$0$不能），那么转移非常简单：只要存在一个 $dp[j]=1$，那么 $dp[i]=1$，其中 $j$ 满足 $1 \leqslant j \leqslant i - k$ 且 $a_i - a_{j+1} \leqslant d$（仔细想想为什么是 $a_{j+1}$）可是如果遍历 $j​$ 的话复杂度是 $O(N^2)​$ 的，显然需要优化——其实我们只需要知道 $j​$ 所在的那个区间内是否有 $1​$ 即可，或者说，和大于 $0​$ 即可。所以我们可以用前缀和轻松做到 $O(1)​$ 查询。 综上： dp状态：$dp[i]$ 表示前 $i$ 个铅笔能否放进盒子中（$1$能，$0$不能） dp方程：$dp[i] = (sum(pos-1, i - k) &gt; 0)$，其中 $pos$ 是最小的满足 $a[i] - a[pos] \leqslant d$ 的点 dp顺序：由dp方程可得：从小到大枚举 $i$ 即可 边界条件：这道题的边界条件有点迷……在实践过程中你会发现那些从 $1$ 开始的符合题意的区间会被判 $0$，所以边界条件可以是把它们置为 $1$。其他合法区间都可以从它们转移过去。 时间复杂度 $O(N)$ Code123456789101112131415161718192021222324252627282930#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 500005;int n, k, d, a[N], ptl, ptr, cnt, dpSum[N];bool dp[N]; // dp[i] represents whether we can put 1st~ith pencils into boxesinline int sum(int l, int r)&#123; if(l &gt; r) return 0; return dpSum[r] - dpSum[l-1];&#125;int main()&#123; scanf("%d%d%d", &amp;n, &amp;k, &amp;d); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); sort(a+1, a+n+1); for(int i = k; i &lt;= n; i++) if(a[i] - a[1] &lt;= d) dp[i] = 1; int pos = 1; for(int i = 1; i &lt;= n; i++)&#123; while(a[i] - a[pos] &gt; d) pos++; dp[i] |= sum(pos-1, i - k); dpSum[i] = dpSum[i-1] + dp[i]; &#125; return puts(dp[n] ? "YES" : "NO"), 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder ARC098]E - Range Minimum Queries]]></title>
    <url>%2F2018%2F05%2F27%2FAtCoder-ARC098-E-Range-Minimum-Queries%2F</url>
    <content type="text"><![CDATA[E - Range Minimum QueriesTime limit : 2sec / Memory limit : 1024MBScore : 600 points Problem StatementYou are given an integer sequence $A$ of length $N$ and an integer $K$. You will perform the following operation on this sequence $Q$ times: Choose a contiguous subsequence of length $K$, then remove the smallest element among the $K$ elements contained in the chosen subsequence (if there are multiple such elements, choose one of them as you like). Let $X$ and $Y$ be the values of the largest and smallest element removed in the $Q$ operations. You would like $X−Y$ to be as small as possible. Find the smallest possible value of $X−Y$ when the $Q$ operations are performed optimally. Constraints$1≤N≤2000$$1≤K≤N$$1≤Q≤N−K+1$$1≤A_i≤10^9$All values in input are integers. InputInput is given from Standard Input in the following format: $N$ $K$ $Q$$A_1$ $A_2$ … $A_N$ OutputPrint the smallest possible value of $X−Y$. Samples Input Output 5 3 24 3 1 5 2 1 10 1 61 1 2 3 5 8 13 21 34 55 7 11 7 524979445 861648772 623690081 433933447 476190629 262703497 211047202 971407775 628894325 731963982 822804784 451211184 In the first operation, whichever contiguous subsequence of length 3 we choose, the minimum element in it is $1$. Thus, the first operation removes $A_3=1$ and now we have $A=(4,3,5,2)$. In the second operation, it is optimal to choose $(A_2,A_3,A_4)=(3,5,2)$ as the contiguous subsequence of length $3$ and remove $A_4=2$. In this case, the largest element removed is $2$, and the smallest is $1$, so their difference is $2−1=1$. 解题思路如果从正面来想，最大值 $X$ 和最小值 $Y$ 都在变，所以不好解决。于是我们可以固定最小值 $Y$，每次找符合要求的最小的 $X$ 就行了。具体来说，从小到大枚举最小值 $Y$，对于每次枚举的 $Y$：我们可以找到一些区间，满足区间长度 $len$ 大于等于 $K$ 并且区间内的所有数都大于等于 $Y$，于是这个区间内的前 $len - K + 1$ 小都有可能被选进答案，记录下这些可能值后，排序就可以找到对于当前的 $Y$ 最小的 $X$ 是多少，用 $X-Y$ 更新 $ans$ 即可。 时间复杂度：枚举是 $O(N)$ 的，每次枚举中查找可能值+排序是 $O(N＋N\log N)$的，所以总复杂度是 $O(N^2\log N)$ Code1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 2005;int n, k, q, a[N], ans = 1e9+5, t[N], b[N], c[N];void cal(int mn)&#123; int l = 1, r = 1; b[0] = 0; while(l &lt;= n)&#123; c[0] = 0; while(a[l] &lt; mn &amp;&amp; l &lt;= n) l++; r = l; while(a[r] &gt;= mn &amp;&amp; r &lt;= n) r++; for(int i = l; i &lt; r &amp;&amp; i &lt;= n; i++) c[++c[0]] = a[i]; if(c[0] &gt;= k)&#123; sort(c+1, c+c[0]+1); for(int i = 1; i &lt;= c[0] - k + 1; i++) b[++b[0]] = c[i]; &#125; l = r; &#125; sort(b+1, b+b[0]+1); if(b[0] &gt;= q) ans = min(ans, b[q] - b[1]);&#125;int main()&#123; scanf("%d%d%d", &amp;n, &amp;k, &amp;q); for(int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;a[i]); t[i] = a[i]; &#125; sort(t+1, t+n+1); for(int i = 1; i &lt;= n; i++) cal(t[i]); printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder ARC097]E - Sorted and Sorted（dp，逆序对，前缀和优化）]]></title>
    <url>%2F2018%2F05%2F20%2FAtCoder-ARC097-E-Sorted-and-Sorted%EF%BC%88dp%EF%BC%8C%E9%80%86%E5%BA%8F%E5%AF%B9%EF%BC%8C%E5%89%8D%E7%BC%80%E5%92%8C%E4%BC%98%E5%8C%96%EF%BC%89%2F</url>
    <content type="text"><![CDATA[E - Sorted and SortedTime limit : 2sec / Memory limit : 1024MBScore : 600 points Problem StatementThere are $2N$ balls, $N$ white and $N$ black, arranged in a row. The integers from $1$ through $N$ are written on the white balls, one on each ball, and they are also written on the black balls, one on each ball. The integer written on the $i$-th ball from the left ($1 ≤ i ≤ 2N$) is $a_i$, and the color of this ball is represented by a letter $c_i$. $c_i = $ W represents the ball is white; $c_i = $B represents the ball is black.Takahashi the human wants to achieve the following objective: For every pair of integers $(i,j)$ such that $1 ≤ i &lt; j ≤ N$, the white ball with $i$ written on it is to the left of the white ball with $j$ written on it. For every pair of integers $(i,j)$ such that $1 ≤ i &lt; j ≤ N$, the black ball with $i$ written on it is to the left of the black ball with $j$ written on it. In order to achieve this, he can perform the following operation: Swap two adjacent balls. Find the minimum number of operations required to achieve the objective. Constraints$1 ≤ N ≤ 2000$$1 ≤ a_i ≤ N$$c_i = $ W or $c_i =$ B.If $i ≠ j$, $(a_i,c_i) ≠ (a_j,c_j)$. InputInput is given from Standard Input in the following format: $N$$c_1$ $a_1$$c_2$ $a_2$$:$$c_{2N}$ $a_{2N}$ OutputPrint the minimum number of operations required to achieve the objective. Samples Input Output 3B 1W 2B 3W 1W 3B 2 4 4B 4W 4B 3W 3B 2W 2B 1W 1 18 9W 3B 1B 4W 1B 5W 9W 2B 6W 5B 3W 8B 9W 7B 2B 8W 4W 6B 7 41 Sample 1:The objective can be achieved in four operations, for example, as follows:Swap the black 3 and white 1.Swap the white 1 and white 2.Swap the black 3 and white 3.Swap the black 3 and black 2. 解题思路先看一个最基本的问题： 已知 $1$ 到 $N$ 的一个排列，每次操作可以交换相邻两数，求至少多少次操作才能将这个数列变为 $1,2,3,\cdots,N$ 答案就是原数列的逆序对对数。证明如下：目标数列显然满足这样一个性质：对于 $\forall i \in [1,N)$，都有 $a_i &lt; a_{i+1}$。因此如果当前数列不是目标数列，一定 $\exists\ i \in [1,n)$ 使得 $a_i &gt; a_{i+1}$，那么 $a_i$ 和 $a_{i+1}$ 就构成了一对逆序对，我们需要一次操作交换这两个数。这样周而复始地进行交换操作，最终操作数量就是逆序对对数。 这个基本问题就可以衍生出许多问题，比如说 NOIP2013花匠 [题解]，又比如这道题。 这道题把一个 $1$ 到 $N$ 的排列变成了两个 $1$ 到 $N$ 的排列相混合，于是出现了一个问题：我们甚至都不知道最终数列的状态是怎样的。假设现在我们知道最终数列的状态，那么只需要像 NOIP2013花匠 一样扩展一下“逆序对” $(a_i,a_j)$ 的定义为：初始时 $a_i$ 在 $a_j$ 之后，目标状态下 $a_i$ 在 $a_j$ 之前的一对 $(a_i,a_j)$。这样，答案仍旧是逆序对对数。ok，现在我们只需要找到最优的目标状态了： dp状态：定义 $dp[i][j]$ 表示目标状态中，前 $i+j$ 个数由 $1$~$i$ 的黑球和 $1$~$j$ 的白球混合排列而成（对于任意一种颜色的球，排列是升序的）时，最少的逆序对对数 dp方程：$dp[i][j] = min(dp[i-1][j] + b_{i,j},dp[i][j-1] + w_{i, j})$，其中 $b_{i,j}$ 表示 $1$~$i$ 的白球和 $1$~$j$ 的黑球中，初始时在黑球 $i$ 之后的球的数量；$w_{i,j}$ 同理具体计算 $b_{i,j}$ 和 $w_{i,j}$ 可以在 dp 之前先 $O(N^2)$ 预处理出所有位置关系，再通过二维前缀和优化使得能够在 dp 时 $O(1)$ 得值 dp顺序：由dp方程易知：顺序 for i 再 for j 即可 边界条件：由dp定义和dp顺序可知：dp[0][0] = 0 答案即是 $dp[N][N]$ 时间复杂度：$O(N^2)$ Code12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int INF = 0x7fffffff;const int N = 2005;int n, a[N&lt;&lt;1], t, dp[N][N], g[N&lt;&lt;1][N&lt;&lt;1];char c;int cal(int x, int b, int w)&#123; return g[x][b] - g[x-1][b] + g[x][w] - g[x][n] - g[x-1][w] + g[x-1][n];&#125;int main()&#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n &lt;&lt; 1; i++)&#123; scanf("%s%d", &amp;c, &amp;a[i]); if(c == 'W') a[i] += n; for(int j = 1; j &lt; i; j++) g[a[j]][a[i]] = 1; &#125; for(int i = 1; i &lt;= n &lt;&lt; 1; i++) for(int j = 1; j &lt;= n &lt;&lt; 1; j++) g[i][j] += g[i-1][j] + g[i][j-1] - g[i-1][j-1]; memset(dp, 0x7f, sizeof dp); dp[0][0] = 0; for(int i = 0; i &lt;= n; i++)&#123; for(int j = 0; j &lt;= n; j++)&#123; if(!i &amp;&amp; !j) continue; dp[i][j] = min(i ? dp[i-1][j] + cal(i, i, j+n) : INF, j ? dp[i][j-1] + cal(j+n, i, j+n) : INF); &#125; &#125; printf("%d\n", dp[n][n]); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2013 D2 T2]花匠（贪心）]]></title>
    <url>%2F2018%2F05%2F07%2FNOIP2013-D2-T2-%E8%8A%B1%E5%8C%A0%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述花匠栋栋种了一排花，每株花都有自己的高度。花儿越长越大，也越来越挤。栋栋决定把这排中的一部分花移走，将剩下的留在原地，使得剩下的花能有空间长大，同时，栋栋希望剩下的花排列得比较别致。具体而言，栋栋的花的高度可以看成一列整数h1,h2..hn。设当一部分花被移走后，剩下的花的高度依次为g1,g2..gm，则栋栋希望下面两个条件中至少有一个满足：条件 A：对于所有g(2i)&gt;g(2i-1),g(2i)&gt;g(2i+1)条件 B：对于所有g(2i)]]></content>
      <categories>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder ABC096]D - Five, Five Everywhere（构造）]]></title>
    <url>%2F2018%2F05%2F05%2FAtCoder-ABC096-D-Five-Five-Everywhere%EF%BC%88%E6%9E%84%E9%80%A0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[D - Five, Five EverywhereTime limit : 2sec / Memory limit : 256MBScore: 400 points Problem StatementPrint a sequence $a_1,a_2,…,a_N$ whose length is $N$ that satisfies the following conditions: $a_i$ ($1≤i≤N$) is a prime number at most $55 555$. The values of $a_1,a_2,…,a_N$ are all different. In every choice of five different integers from $a_1,a_2,…,a_N$, the sum of those integers is a composite number.If there are multiple such sequences, printing any of them is accepted. NotesAn integer $N$ not less than $2$ is called a prime number if it cannot be divided evenly by any integers except $1$ and $N$, and called a composite number otherwise. Constraints $N$ is an integer between $5$ and $55$ (inclusive). InputInput is given from Standard Input in the following format: N OutputPrint $N$ numbers $a_1,a_2,a_3,…,a_N$ in a line, with spaces in between. Sample Input 115 Sample Output 113 5 7 11 31 Let us see if this output actually satisfies the conditions.First, 3, 5, 7, 11 and 31 are all different, and all of them are prime numbers.The only way to choose five among them is to choose all of them, whose sum is $a_1+a_2+a_3+a_4+a_5=57$, which is a composite number.There are also other possible outputs, such as 2 3 5 7 13, 11 13 17 19 31 and 7 11 5 31 3. Sample Input 216 Sample Output 212 3 5 7 11 13 $2, 3, 5, 7, 11, 13$ are all different prime numbers.$2+3+5+7+11=28$ is a composite number.$2+3+5+7+13=30$ is a composite number.$2+3+5+11+13=34$ is a composite number.$2+3+7+11+13=36$ is a composite number.$2+5+7+11+13=38$ is a composite number.$3+5+7+11+13=39$ is a composite number.Thus, the sequence 2 3 5 7 11 13 satisfies the conditions. Sample Input 318 Sample Output 312 5 7 13 19 37 67 79 解题思路比赛时居然没想出来，被可恶的样例解释带偏了…要求给出一个全是质数的数列，使得任取五个数的和都是合数既然这样，我们不妨让所有数的个位都是1，很容易证明在 $[5,55555]$ 中可以找出至少 $55$ 个这样的个位是1的质数那么，任意5个数的和的个位就一定是5了——那就一定是合数了oops… Code1234567891011121314151617181920212223#include&lt;cstdio&gt;using namespace std;int n;bool isPrime(int x)&#123; for(int i = 2; i * i &lt;= x; i++) if(x % i == 0) return false; return true;&#125;int main()&#123; scanf("%d", &amp;n); for(int i = 11; n; i += 10)&#123; if(isPrime(i))&#123; printf("%d ", i); n--; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces 940E]Cashback（动态规划，单调队列，贪心）]]></title>
    <url>%2F2018%2F04%2F30%2FCodeforces-940E-Cashback%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E8%B4%AA%E5%BF%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目E. Cashbacktime limit per test: 2 secondsmemory limit per test: 256 megabytesinput: standard inputoutput: standard output Since you are the best Wraith King, Nizhniy Magazin at the centre of Vinnytsia is offering you a discount.You are given an array $a$ of length $n$ and an integer $c$.The value of some array $b$ of length $k$ is the sum of its elements except for the $\lfloor \frac{k}{c} \rfloor$ smallest. For example, the value of the array $[3,1,6,5,2]$ with $c=2$ is $3+6+5=14$.Among all possible partitions of a into contiguous subarrays output the smallest possible sum of the values of these subarrays. InputThe first line contains integers n and c ($1≤n,c≤100000$).The second line contains n integers ai ($1≤a_i≤10^9$) — elements of a. OutputOutput a single integer — the smallest possible sum of values of these subarrays of some partition of $a$. Examples input output 3 51 2 3 6 12 101 1 10 10 10 10 10 10 9 10 10 10 92 7 22 3 6 4 5 7 1 17 8 41 3 4 5 5 3 4 1 23 NoteIn the first example any partition yields 6 as the sum.In the second example one of the optimal partitions is $[1,1],[10,10,10,10,10,10,9,10,10,10]$ with the values 2 and 90 respectively.In the third example one of the optimal partitions is $[2,3],[6,4,5,7],[1]$ with the values 3, 13 and 1 respectively.In the fourth example one of the optimal partitions is $[1],[3,4,5,5,3,4],[1]$ with the values 1, 21 and 1 respectively. 解题思路这当然是一道dp题。我们先设$dp[i]$表示前$i$个数字划分后的最小代价，那么转移就是$dp[i]=min\{dp[k]+cal(k+1, i)\ |\ 1 \leqslant k &lt; i\}$，其中$cal(l, r)$是计算$l$到$r$作为整体时的代价。复杂度？$cal(l,r)$可以用multiset之类的做到$O(\log n)$完成，但是dp方程里面有两层循环，所以复杂度高达$O(n^2\log n)$，差远了。 怎么优化呢？这里我们可以发现一个贪心：划分的每一块长度要么是1，要么是c。证明：如果块的长度小于c，那么代价是所有值的和，与把这些值划分成一份一份的等价；如果块的长度大于c，我们把它们划分成几个长为c或1的块，答案一定不会更差（去除数量相同，但区间更小，更有机会去除掉大一点的数，手动模拟一下就知道了）。综上所述，我们的dp长这样： dp状态：$dp[i]$表示前$i$个数字划分后的最小代价 dp方程：$dp[i] = min\big(dp[i-1] + a[i], dp[i-c] + sum(i-c+1, i) - min(i-c+1, i)\big)$由于长为c的段只会去除最小的值，所以上文中的$cal()$变成了此处的$min()$sum(l,r)表示$l$到$r$的和，可以前缀和优化到$O(1)$min(l,r)表示$l$到$r$的最小值，由于$l$~$r$长度固定为c，所以可以单调队列$O(n)$的预处理出来 dp顺序：由dp方程可知，$i$从小到大for即可 边界条件：$dp[0] = 0$ 时间复杂度 $O(n)$ Code12345678910111213141516171819202122232425262728293031#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;typedef long long LL;const int N = 100005;int n, c, hd, tl;LL a[N], sum[N], mnC[N], dp[N];pair&lt;LL, int&gt; q[N];int main()&#123; scanf("%d%d", &amp;n, &amp;c); for(int i = 1; i &lt;= n; i++)&#123; scanf("%lld", &amp;a[i]); sum[i] = sum[i-1] + a[i]; while(hd &lt; tl &amp;&amp; q[tl-1].first &gt; a[i]) tl--; q[tl++] = make_pair(a[i], i); while(hd &lt; tl &amp;&amp; q[hd].second &lt;= max(i - c, 0)) hd++; mnC[i] = q[hd].first; &#125; memset(dp, 0x7f, sizeof dp); dp[0] = 0; for(int i = 1; i &lt;= n; i++)&#123; dp[i] = dp[i-1] + a[i]; if(i - c &gt;= 0) dp[i] = min(dp[i], dp[i-c] + sum[i] - sum[i-c] - mnC[i]); &#125; printf("%lld", dp[n]); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>数据结构</category>
        <category>贪心</category>
        <category>队列</category>
        <category>单调队列</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2017 D2 T3]列队（线段树/平衡树）]]></title>
    <url>%2F2018%2F04%2F30%2FNOIP2017-D2-T3-%E5%88%97%E9%98%9F%EF%BC%88%E7%BA%BF%E6%AE%B5%E6%A0%91-%E5%B9%B3%E8%A1%A1%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述Sylvia 是一个热爱学习的女♂孩子。前段时间，Sylvia 参加了学校的军训。众所周知，军训的时候需要站方阵。Sylvia 所在的方阵中有$n \times m$名学生，方阵的行数为 $n$，列数为 $m$。为了便于管理，教官在训练开始时，按照从前到后，从左到右的顺序给方阵中 的学生从 1 到 $n \times m$ 编上了号码（参见后面的样例）。即：初始时，第 $i$ 行第 $j$ 列 的学生的编号是$(i-1)\times m + j$。然而在练习方阵的时候，经常会有学生因为各种各样的事情需要离队。在一天 中，一共发生了 $q$件这样的离队事件。每一次离队事件可以用数对$(x,y) (1 \le x \le n, 1 \le y \le m)$描述，表示第 $x$ 行第 $y$ 列的学生离队。在有学生离队后，队伍中出现了一个空位。为了队伍的整齐，教官会依次下达 这样的两条指令： 向左看齐。这时第一列保持不动，所有学生向左填补空缺。不难发现在这条 指令之后，空位在第 $x$ 行第 $m$ 列。 向前看齐。这时第一行保持不动，所有学生向前填补空缺。不难发现在这条 指令之后，空位在第 $n$ 行第 $m$ 列。 教官规定不能有两个或更多学生同时离队。即在前一个离队的学生归队之后， 下一个学生才能离队。因此在每一个离队的学生要归队时，队伍中有且仅有第 $n$ 行 第 $m$ 列一个空位，这时这个学生会自然地填补到这个位置。因为站方阵真的很无聊，所以 Sylvia 想要计算每一次离队事件中，离队的同学 的编号是多少。注意：每一个同学的编号不会随着离队事件的发生而改变，在发生离队事件后 方阵中同学的编号可能是乱序的。 输入输入共 $q+1$行。第 1 行包含 3 个用空格分隔的正整数 $n, m, q$，表示方阵大小是 $n$ 行 $m$ 列，一共发 生了 $q$ 次事件。接下来 $q$ 行按照事件发生顺序描述了 $q$ 件事件。每一行是两个整数 $x, y$，用一个空 格分隔，表示这个离队事件中离队的学生当时排在第 $x$ 行第 $y$ 列。 输出按照事件输入的顺序，每一个事件输出一行一个整数，表示这个离队事件中离队学 生的编号。 输入样例12342 2 31 12 21 2 输出样例123114 数据规模与约定$n,m,q \leq 3 \times 10^5$数据保证每一个事件满足 $1 \le x \le n,1 \le y \le m$ 解题思路一道数据结构的好题。首先我们发现，每次操作只会更改某一行和最后一列的状态，那么我们可以单独把最后一列拿出来用一个数据结构维护，再用$n$个数据结构维护每一行的前$m-1$个元素。那用什么数据结构好呢？ 一、线段树线段树是最容易想到的，共开$n+1$颗线段树，前$n$颗维护每行前$m-1$个元素，第$n+1$颗维护最后一列的元素。每次对$(x,y)$操作都可以转化为一个基本操作：从一颗线段树里面拿出一个元素加到一颗线段树的末尾，具体来说： 如果$y = m$，只需要从“列线段树”里拿出第$x$个元素加到它本身末尾 否则，从第$x$颗“行线段树”里拿出第$y$个元素加到“列线段树”末尾，再从“列线段树”里拿出第$x$个元素加到“行线段树”末尾 所谓的“拿出”操作就是一个在线段树上二分查找的过程，为此我们要在线段树每个节点上记录一个size，表示当前节点表示的区间里面还剩多少个元素。另外，每颗线段树要多开$q$的区间长度（想想操作过程就明白了）。 但是，以上并不是这道题的难点，这道题的特殊之处在于你无法直接开满$n+1$颗线段树！怎么办呢，我们可以动态开点来解决，也就是说当你要用某个点时再开它（想想主席树）。这样我们只需要$NlogN$的空间就够了。 时间复杂度 $O(q\log (n+q))$ 二、平衡树既然线段树可以，平衡树当然也可以了！同样的思路：每次操作都可以转化为从一颗平衡树上二分查找第k大的值，把它加到一颗平衡树的末尾。 怎么解决空间问题？由于有一些人至始至终都站在一起，我们可以在平衡树上只用一个节点表示这个区间$[l,r]$（编号从$l$到$r$的人），当我们发现这个区间中的某个人（如编号为$k$的人）要离队时，再把它split成两个小区间（$[l,k-1],[k+1,r]$），输出$k$，这样就能保证空间复杂度为 $NlogN$。 时间复杂度$O(q\log n)$ 三、树状数组有待学习… Code#1（线段树）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 300005;int n, m, q, qx, qy, p[N], root[N];LL t;struct segTree&#123; int son[2]; LL val, size;&#125;tr[N*30];struct OPT_segTree&#123; int cnt; inline int newNode(int l, int r, int kind)&#123; cnt++; int temp = (kind == 0 ? m - 1 : n); if(l &lt;= temp &amp;&amp; r &lt;= temp) tr[cnt].size = r - l + 1; else if(l &lt;= temp &amp;&amp; r &gt; temp) tr[cnt].size = temp - l + 1; else if(l &gt; temp &amp;&amp; r &gt; temp) tr[cnt].size = 0; return cnt; &#125; inline void pushup(int id)&#123; tr[id].size = tr[tr[id].son[0]].size + tr[tr[id].son[1]].size; &#125; LL getKth(int id, int l, int r, LL k, int kind)&#123; if(l == r)&#123; if(!tr[id].val)&#123; if(kind == 0) tr[id].val = 1ll * (qx - 1) * m + l; else tr[id].val = 1ll * l * m; &#125; tr[id].size = 0; return tr[id].val; &#125; int mid = (l + r) &gt;&gt; 1; if(!tr[id].son[0]) tr[id].son[0] = newNode(l, mid, kind); if(!tr[id].son[1]) tr[id].son[1] = newNode(mid+1, r, kind); LL res = 0; if(tr[tr[id].son[0]].size &gt;= k) res = getKth(tr[id].son[0], l, mid, k, kind); else res = getKth(tr[id].son[1], mid+1, r, k - tr[tr[id].son[0]].size, kind); pushup(id); return res; &#125; void insert(int id, int l, int r, int pos, LL val, int kind)&#123; if(l == r)&#123; tr[id].val = val; tr[id].size = 1; return; &#125; int mid = (l + r) &gt;&gt; 1; if(!tr[id].son[0]) tr[id].son[0] = newNode(l, mid, kind); if(!tr[id].son[1]) tr[id].son[1] = newNode(mid+1, r, kind); if(pos &lt;= mid) insert(tr[id].son[0], l, mid, pos, val, kind); else insert(tr[id].son[1], mid+1, r, pos, val, kind); pushup(id); &#125;&#125;Seg;int main()&#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;q); for(int i = 1; i &lt;= n; i++) p[i] = m - 1; p[n+1] = n; for(int i = 1; i &lt;= n; i++) root[i] = Seg.newNode(1, m - 1 + q, 0); root[n+1] = Seg.newNode(1, n + q, 1); for(int i = 1; i &lt;= q; i++)&#123; scanf("%d%d", &amp;qx, &amp;qy); if(qy == m)&#123; printf("%lld\n", t = Seg.getKth(root[n+1], 1, n + q, qx, 1)); Seg.insert(root[n+1], 1, n + q, ++p[n+1], t, 1); &#125; else&#123; printf("%lld\n", t = Seg.getKth(root[qx], 1, m - 1 + q, qy, 0)); Seg.insert(root[n+1], 1, n + q, ++p[n+1], t, 1); t = Seg.getKth(root[n+1], 1, n + q, qx, 1); Seg.insert(root[qx], 1, m - 1 + q, ++p[qx], t, 0); &#125; &#125; return 0;&#125; Code#2（Splay）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;cstdio&gt;using namespace std;typedef long long LL;const int N = 300005;int qx, qy, rt[N];LL t, n, m, q;struct Splay&#123; int son[2], fa; LL val, l, r, size;&#125;tr[N*30];struct OPT_Splay&#123; int cnt; inline void pushup(int id)&#123; tr[id].size = tr[id].r - tr[id].l + 1; if(tr[id].son[0]) tr[id].size += tr[tr[id].son[0]].size; if(tr[id].son[1]) tr[id].size += tr[tr[id].son[1]].size; &#125; inline int newNode(LL l, LL r)&#123; cnt++; tr[cnt].fa = tr[cnt].son[0] = tr[cnt].son[1] = 0; tr[cnt].size = (tr[cnt].r = r) - (tr[cnt].l = l) + 1; return cnt; &#125; inline void rotate(int x, int kind)&#123; int y = tr[x].fa, z = tr[y].fa, A = tr[y].son[kind], B = tr[x].son[kind], C = tr[x].son[!kind]; tr[x].son[kind] = y, tr[x].fa = z; tr[y].fa = x, tr[y].son[!kind] = B; tr[z].son[tr[z].son[1] == y] = x, tr[B].fa = y; pushup(y), pushup(x); &#125; inline void splay(int &amp;root, int x, int goal)&#123; if(x == goal) return; while(tr[x].fa != goal)&#123; int y = tr[x].fa, z = tr[y].fa; int isrson1 = tr[y].son[1] == x, isrson2 = tr[z].son[1] == y; if(z == goal) rotate(x, !isrson1); else&#123; if(isrson1 == isrson2) rotate(y, !isrson2); else rotate(x, !isrson1); rotate(x, !isrson2); &#125; &#125; if(goal == 0) root = x; &#125; inline int selectLast(int &amp;root)&#123; int now = root; while(tr[now].son[1]) now = tr[now].son[1]; return now; &#125; inline void insert(int &amp;root, LL val)&#123; int temp = newNode(val, val); int pos = selectLast(root); tr[pos].son[1] = temp; tr[temp].fa = pos; splay(root, temp, 0); &#125; LL split(int &amp;root, int now, LL k)&#123; splay(root, now, 0); k += tr[now].l - 1; int temp = newNode(k+1, tr[now].r); tr[now].r = k - 1; if(!tr[now].son[1])&#123; tr[now].son[1] = temp; tr[temp].fa = now; &#125; else&#123; tr[temp].son[1] = tr[now].son[1]; tr[tr[temp].son[1]].fa = temp; tr[now].son[1] = temp; tr[temp].fa = now; &#125; pushup(temp), pushup(now); return k; &#125; inline LL getKth(int &amp;root, LL k)&#123; int now = root; while(1)&#123; if(k &lt;= tr[tr[now].son[0]].size) now = tr[now].son[0]; else&#123; k -= tr[tr[now].son[0]].size; if(k &lt;= tr[now].r - tr[now].l + 1) return split(root, now, k); else&#123; k -= (tr[now].r - tr[now].l + 1); now = tr[now].son[1]; &#125; &#125; &#125; &#125;&#125;BST;int main()&#123; scanf("%lld%lld%lld", &amp;n, &amp;m, &amp;q); for(int i = 1; i &lt;= n; i++) rt[i] = BST.newNode((i - 1) * m + 1, i * m - 1); rt[n+1] = BST.newNode(m, m); for(int i = 2; i &lt;= n; i++) BST.insert(rt[n+1], i * m); while(q--)&#123; scanf("%d%d", &amp;qx, &amp;qy); if(qy == m)&#123; printf("%lld\n", t = BST.getKth(rt[n+1], qx)); BST.insert(rt[n+1], t); &#125; else&#123; printf("%lld\n", t = BST.getKth(rt[qx], qy)); BST.insert(rt[n+1], t); BST.insert(rt[qx], BST.getKth(rt[n+1], qx)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
        <category>平衡树</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2017 D2 T2]宝藏（状压dp）]]></title>
    <url>%2F2018%2F04%2F30%2FNOIP2017-D2-T2-%E5%AE%9D%E8%97%8F%EF%BC%88%E7%8A%B6%E5%8E%8Bdp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述参与考古挖掘的小明得到了一份藏宝图，藏宝图上标出了 $n$ 个深埋在地下的宝藏屋， 也给出了这 $n$ 个宝藏屋之间可供开发的 $m$ 条道路和它们的长度。 小明决心亲自前往挖掘所有宝藏屋中的宝藏。但是，每个宝藏屋距离地面都很远， 也就是说，从地面打通一条到某个宝藏屋的道路是很困难的，而开发宝藏屋之间的道路 则相对容易很多。 小明的决心感动了考古挖掘的赞助商，赞助商决定免费赞助他打通一条从地面到某 个宝藏屋的通道，通往哪个宝藏屋则由小明来决定。 在此基础上，小明还需要考虑如何开凿宝藏屋之间的道路。已经开凿出的道路可以 任意通行不消耗代价。每开凿出一条新道路，小明就会与考古队一起挖掘出由该条道路 所能到达的宝藏屋的宝藏。另外，小明不想开发无用道路，即两个已经被挖掘过的宝藏 屋之间的道路无需再开发。新开发一条道路的代价是： L \times K$L$代表这条道路的长度，$K$代表从赞助商帮你打通的宝藏屋到这条道路起点的宝藏屋所经过的 宝藏屋的数量（包括赞助商帮你打通的宝藏屋和这条道路起点的宝藏屋） 。 请你编写程序为小明选定由赞助商打通的宝藏屋和之后开凿的道路，使得工程总代价最小，并输出这个最小值。 输入第一行两个用空格分离的正整数 $n$ 和 $m$，代表宝藏屋的个数和道路数。 接下来 $m$ 行，每行三个用空格分离的正整数，分别是由一条道路连接的两个宝藏 屋的编号（编号为 $1$~$n$），和这条道路的长度 $v$。 输出输出共一行，一个正整数，表示最小的总代价。 样例输入样例输入11234564 5 1 2 1 1 3 3 1 4 1 2 3 4 3 4 1 样例输入21234564 5 1 2 1 1 3 3 1 4 1 2 3 4 3 4 2 样例输出样例输出114 样例输出215 数据规模与约定对于 20% 的数据： 保证输入是一棵树，$1 \le n \le 8$ , $v \le 5000$ 且所有的 v 都相等。对于 40% 的数据： $1 \le n \le 8$，$0 \le m \le 1000$ , $v \le 5000$ 且所有的 v 都相等。对于 70% 的数据： $1 \le n \le 8$，$0 \le m \le 1000$，$v \le 5000$对于 100% 的数据： $1 \le n \le 12$，$0 \le m \le 1000$ , $v \le 500000$ 解题思路首先，很容易发现打通后的道路一定是一棵树，并且，若以起点为根并令其深度为$0$，则题目中的 $K$ 即为这条路所连向的点的深度。 观察数据范围，$n \le 12$，显然是状压dp： dp状态：$dp[i][S]$ 表示考虑到树的第$i$层，前$i$层已选的点的集合为$S$（二进制状压）的最小代价。 dp方程（刷表法）： 已知$dp[i][S]$时，可枚举所有由不在$S$中的点构成的集合作为第$i+1$层，则状态转移为dp[i][S] \to dp[i+1][S|S'] + (i+1) \times \Sigma \ min\{G[a][b]|a \in S , b \in S',S \cap S' = \emptyset \} 简单一点，就是dp[i][S] \to dp[i+1][S|S'] + (i+1) \times sval[S'][S] \} 其中$sval[A][B]$表示集合A到集合B的最短距离，即集合A中所有点到集合B的最短距离之和。可以先预处理出每个点到每个集合的最短距离$pval[i][S]$（也就是点$i$到集合$S$中所有点的距离的最小值），然后用$pval[i][B]$更新$sval[A][B]$。 dp顺序：由dp方程可得：从小到大枚举层数，再枚举集合即可 边界条件：枚举根节点，设为$root$，则$dp[0][1&lt;&lt;(root-1)] = 0$ 状压相关技巧 若$S$是$U$的子集，则$S$关于$U$的补集：$S ^\wedge U$ 判断点$k$是否在集合$S$中（即$S$的第$k-1$位是否为$1$）：S &amp; (1 &lt;&lt; (k-1)) ！= 0 ? &quot;Yes&quot; : &quot;No&quot;; 枚举$S$的子集：for(int i = S; i; i = (i - 1) &amp; S){...} Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int INF = 1e7;const int N = 13;int n, m, g[N][N], u, v, p, U;LL dp[N][1&lt;&lt;N], ans = 1e14, sval[1&lt;&lt;N][1&lt;&lt;N], pval[N][1&lt;&lt;N];void init(int root)&#123; for(int i = 0; i &lt;= n; i++) for(int j = 0; j &lt;= U; j++) dp[i][j] = INF; dp[0][1&lt;&lt;(root-1)] = 0;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); U = (1 &lt;&lt; n) - 1; for(int i = 1; i &lt;= n; i++) //initialize g[i][j] for(int j = 1; j &lt;= n; j++) if(i ^ j) g[i][j] = INF; for(int i = 1; i &lt;= n; i++) for(int j = 0; j &lt;= U; j++) pval[i][j] = INF; for(int i = 0; i &lt;= U; i++) for(int j = 0; j &lt;= U; j++) sval[i][j] = INF; while(m--)&#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;p); g[u][v] = min(g[u][v], p); g[v][u] = min(g[v][u], p); &#125; for(int i = 1; i &lt;= n; i++) //initialize pval[i][S] for(int j = 0; j &lt;= U; j++) for(int k = 1; k &lt;= n; k++) if(j &amp; (1 &lt;&lt; (k - 1))) pval[i][j] = min(pval[i][j], 1ll*g[i][k]); for(int i = 0; i &lt;= U; i++)&#123; //initialize sval[A][B] int C = i ^ U; for(int s = C; s; s = (s - 1) &amp; C)&#123; LL temp = 0; for(int j = 1; j &lt;= n; j++) if(s &amp; (1 &lt;&lt; (j - 1))) temp += pval[j][i]; sval[s][i] = temp &gt;= INF ? INF : temp; &#125; &#125; for(int root = 1; root &lt;= n; root++)&#123; //dp init(root); for(int i = 0; i &lt; n; i++) for(int S = 0; S &lt;= U; S++) if(dp[i][S] != INF)&#123; int C = S ^ U; for(int s = C; s; s = (s - 1) &amp; C) dp[i+1][S|s] = min(dp[i+1][S|s], dp[i][S] + (i + 1) * sval[s][S]); &#125; for(int i = 0; i &lt; n; i++) ans = min(ans, dp[i][U]); &#125; printf("%lld", ans); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>状压dp</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2017 D2 T1]奶酪（并查集）]]></title>
    <url>%2F2018%2F04%2F30%2FNOIP2017-D2-T1-%E5%A5%B6%E9%85%AA%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述现有一块大奶酪，它的高度为 $h$，它的长度和宽度我们可以认为是无限大的，奶酪中间有许多半径相同的球形空洞。我们可以在这块奶酪中建立空间坐标系，在坐标系中，奶酪的下表面为$z=0$，奶酪的上表面为$z = h$。现在，奶酪的下表面有一只小老鼠 Jerry，它知道奶酪中所有空洞的球心所在的坐 标。如果两个空洞相切或是相交，则 Jerry 可以从其中一个空洞跑到另一个空洞，特别地，如果一个空洞与下表面相切或是相交，Jerry 则可以从奶酪下表面跑进空洞；如果一个空洞与上表面相切或是相交，Jerry 则可以从空洞跑到奶酪上表面。位于奶酪下表面的 Jerry 想知道，在不破坏奶酪的情况下，能否利用已有的空洞跑到奶酪的上表面去?空间内两点$P_1(x_1,y_1,z_1)$、$P2(x_2,y_2,z_2)$的距离公式如下： \mathrm{dist}(P_1,P_2)=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}输入每个输入文件包含多组数据。输入文件的第一行，包含一个正整数 $T$，代表该输入文件中所含的数据组数。接下来是 $T$ 组数据，每组数据的格式如下： 第一行包含三个正整数 $n,h$ 和 $r$，两个数之间以一个空格分开，分别代表奶酪中空洞的数量，奶酪的高度和空洞的半径。接下来的 $n$ 行，每行包含三个整数 $x,y,z$，两个数之间以一个空格分开，表示空洞球心坐标为$(x,y,z)$。 输出输出文件包含 $T$ 行，分别对应 $T$ 组数据的答案，如果在第 $i$ 组数据中，Jerry 能从下表面跑到上表面，则输出 “Yes”，如果不能，则输出 “No” （均不包含引号）。 样例输入123456789103 2 4 1 0 0 1 0 0 3 2 5 1 0 0 1 0 0 4 2 5 2 0 0 2 2 0 4 样例输出123YesNoYes 数据规模与约定对于 20%的数据，$n = 1$，$1 \le h,r \le 10,000$，坐标的绝对值不超过 10,000。 对于 40%的数据，$1 \le n \le 8$， $1 \le h,r \le 10,000$，坐标的绝对值不超过 10,000。 对于80%的数据， $1 \le n \le 1,000$， $1 \le h , r \le 10,000$，坐标的绝对值不超过10,000。 对于 100%的数据，$1 \le n \le 1,000$，$1 \le h , r \le 1,000,000,000$，$T \le 20$，坐标的绝对值不超过 1,000,000,000。 解题思路设下底面为点$S=n+1$，上底面为点$T=n+2$，枚举两个点看它们是否连通，连通即将它们用并查集并起来，最后看$S$与$T$是否连通即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;typedef long long LL;typedef long double LB;const int N = 1005;int CASES, n, h, S, T;LL r;struct Node&#123; int x, y, z;&#125;node[N];inline LB dist(int a, int b)&#123; return sqrt((LB)(node[a].x-node[b].x)*(node[a].x-node[b].x)+(LB)(node[a].y-node[b].y)*(node[a].y-node[b].y)+(LB)(node[a].z-node[b].z)*(node[a].z-node[b].z));&#125;int fa[N];void init()&#123; for(int i = 1; i &lt;= n+2; i++) fa[i] = i;&#125;int findfa(int x)&#123; if(fa[x] != x) fa[x] = findfa(fa[x]); return fa[x];&#125;void unionn(int x, int y)&#123; fa[findfa(y)] = findfa(x);&#125;int main()&#123; scanf("%d", &amp;CASES); while(CASES--)&#123; scanf("%d%d%lld", &amp;n, &amp;h, &amp;r); init(); S = n + 1, T = n + 2; for(int i = 1; i &lt;= n; i++)&#123; scanf("%d%d%d", &amp;node[i].x, &amp;node[i].y, &amp;node[i].z); for(int j = 1; j &lt; i; j++)&#123; if(dist(i, j) &lt;= 2 * r &amp;&amp; findfa(i) != findfa(j)) unionn(i, j); &#125; if(node[i].z + r &gt;= h) unionn(i, T); if(node[i].z - r &lt;= 0) unionn(i, S); &#125; if(findfa(T) == findfa(S)) puts("Yes"); else puts("No"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普通平衡树/文艺平衡树/二逼平衡树]]></title>
    <url>%2F2018%2F04%2F30%2F%E6%99%AE%E9%80%9A%E5%B9%B3%E8%A1%A1%E6%A0%91-%E6%96%87%E8%89%BA%E5%B9%B3%E8%A1%A1%E6%A0%91-%E4%BA%8C%E9%80%BC%E5%B9%B3%E8%A1%A1%E6%A0%91%2F</url>
    <content type="text"><![CDATA[普通平衡树题目链接：luogu3369bzoj3224 解题思路平衡树模板题，我分别用了 [非旋Treap] 和 [Splay] AC了本题。 一、Splay每个节点表示一个值，同时记录该点及其子树大小、该点表示的值的出现次数、左右儿子、父节点。 插入：将x前驱旋至根，x后继旋至根的右儿子，那么根的左儿子的右儿子即为要插入的位置，如果此位置上无数，则新建一个节点；否则该位置的出现次数和大小加1。 注意：为了避免找不到x前驱和后继，应事先插入一个值为-INF和值为INF的节点。 删除：将x前驱旋至根，x后继旋至根的右儿子，那么根的左儿子的右儿子即为要删除的节点，如果此节点大小为1，直接删除；否则该位置的出现次数和大小减1。 查x排名：将x旋至根，则x排名为根的左儿子大小+1 查排名为x的数：从根向下查找，如果当前节点的左儿子大小+1=x，则返回当前节点的值；否则，如果当前节点的左儿子大小$\geq$x，则向其右儿子查找；否则，向其左儿子查找。 求x前驱：从根向下查找，如果当前节点的值小于等于x，更新ans并向其右儿子查找；否则，向其左儿子查找。更新时，不断取max即可。 求x后继：从根向下查找，如果当前节点的值大于等于x，更新ans并向其左儿子查找；否则，向其右儿子查找。更新时，不断取min即可。 时间复杂度：每次操作 $O(log_2n)$ Code#1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int INF = 0x7fffffff;const int N = 100005;int n, opt, q;int cnt = 0, root = 0;struct Splay_tree&#123; int fa, son[2], size, val, times;&#125;tr[N];inline void pushup(int x)&#123; if(x)&#123; tr[x].size = tr[x].times; if(tr[x].son[0]) tr[x].size += tr[tr[x].son[0]].size; if(tr[x].son[1]) tr[x].size += tr[tr[x].son[1]].size; &#125;&#125;inline void rotate(int x, int kind)&#123; int y = tr[x].fa, z = tr[y].fa, A = tr[y].son[kind], B = tr[x].son[kind], C = tr[x].son[!kind]; tr[x].son[kind] = y, tr[x].fa = z; tr[y].son[!kind] = B, tr[y].fa = x, tr[B].fa = y; tr[z].son[tr[z].son[1] == y] = x; pushup(y), pushup(x);&#125;inline void splay(int x, int goal)&#123; if(x == goal) return; while(tr[x].fa != goal)&#123; int y = tr[x].fa, z = tr[y].fa; int isrson1 = tr[y].son[1] == x, isrson2 = tr[z].son[1] == y; if(z == goal) rotate(x, !isrson1); else&#123; if(isrson1 == isrson2) rotate(y, !isrson2); else rotate(x, !isrson1); rotate(x, !isrson2); &#125; &#125; if(goal == 0) root = x;&#125;inline int select(int x)&#123; int now = root; while(now)&#123; if(tr[now].val == x) break; else if(tr[now].val &lt; x) now = tr[now].son[1]; else if(tr[now].val &gt; x) now = tr[now].son[0]; &#125; if(!now) return -1; return now;&#125;inline int getPre(int x)&#123; int now = root, ans = -INF; while(now)&#123; if(tr[now].val &lt; x)&#123; ans = max(ans, tr[now].val); now = tr[now].son[1]; &#125; else now = tr[now].son[0]; &#125; return ans;&#125;inline int getSub(int x)&#123; int now = root, ans = INF; while(now)&#123; if(tr[now].val &gt; x)&#123; ans = min(ans, tr[now].val); now = tr[now].son[0]; &#125; else now = tr[now].son[1]; &#125; return ans;&#125;inline int getRank(int x)&#123; int now = root, ans = 0; while(now)&#123; if(tr[now].val == x)&#123; ans += tr[tr[now].son[0]].size + 1; break; &#125; else if(tr[now].val &lt; x)&#123; ans += tr[tr[now].son[0]].size + tr[now].times; now = tr[now].son[1]; &#125; else now = tr[now].son[0]; &#125; return ans - 1;&#125;inline int newNode(int val, int f)&#123; ++cnt; tr[cnt].val = val; tr[cnt].fa = f; tr[cnt].son[0] = tr[cnt].son[1] = 0; tr[cnt].size = tr[cnt].times = 1; return cnt;&#125;inline void insert(int x)&#123; splay(select(getPre(x)), 0); splay(select(getSub(x)), root); int t = tr[tr[root].son[1]].son[0]; if(!t) tr[tr[root].son[1]].son[0] = newNode(x, tr[root].son[1]); else tr[t].times++, tr[t].size++; pushup(tr[root].son[1]); pushup(root);&#125;inline void del(int x)&#123; splay(select(getPre(x)), 0); splay(select(getSub(x)), root); int t = tr[tr[root].son[1]].son[0]; if(!t || tr[t].times == 0) return; tr[t].times--, tr[t].size--; if(tr[t].times == 0) tr[tr[root].son[1]].son[0] = 0; pushup(tr[root].son[1]); pushup(root);&#125;inline int findRank(int x)&#123; int now = root; while(now)&#123; if(tr[tr[now].son[0]].size + 1 &lt;= x &amp;&amp; x &lt;= tr[tr[now].son[0]].size + tr[now].times) break; else if(tr[tr[now].son[0]].size + 1 &gt; x) now = tr[now].son[0]; else if(tr[tr[now].son[0]].size + tr[now].times &lt; x)&#123; x -= tr[tr[now].son[0]].size + tr[now].times; now = tr[now].son[1]; &#125; &#125; return tr[now].val;&#125;int main()&#123; scanf("%d", &amp;n); root = newNode(-INF, 0); tr[root].son[1] = newNode(INF, root), pushup(root); while(n--)&#123; scanf("%d%d", &amp;opt, &amp;q); if(opt == 1) insert(q); else if(opt == 2) del(q); else if(opt == 3) printf("%d\n", getRank(q)); else if(opt == 4) printf("%d\n", findRank(q+1)); else if(opt == 5) printf("%d\n", getPre(q)); else if(opt == 6) printf("%d\n", getSub(q)); &#125; return 0;&#125; 二、非旋Treap每个节点表示一个值，同时记录该点及其子树大小、左右儿子。 插入：从x处split，新建一个值为x的节点，再将三部分merge起来。（注：从x处分开：x在前一部分，下同） 删除：从x、x+1处split成三部分（记为l、t、r），将t的左右儿子merge起来，这样就删除了一个节点，再将三部分merge起来。 查x排名：从x-1处split，则x排名为前一部分的大小+1 查排名为x的数：同Splay 求x前驱：同Splay 求x后继：同Splay 时间复杂度：每次操作 $O(log_2n)$ Code#2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int INF = 1e9;const int N = 100005;int n, opt, q;struct Treap&#123; int val, son[2], size, hp;&#125;tr[N];struct OPT_Treap&#123; int cnt, root; inline int newNode(int val)&#123; cnt++; tr[cnt].val = val; tr[cnt].hp = rand(); tr[cnt].son[0] = tr[cnt].son[1] = 0; tr[cnt].size = 1; return cnt; &#125; inline void pushup(int id)&#123; tr[id].size = 1; if(tr[id].son[0]) tr[id].size += tr[tr[id].son[0]].size; if(tr[id].son[1]) tr[id].size += tr[tr[id].son[1]].size; &#125; inline void pushdown(int id)&#123; return; &#125; int merge(int a, int b)&#123; if(a == 0) return b; if(b == 0) return a; if(tr[a].hp &lt;= tr[b].hp)&#123; pushdown(a); tr[a].son[1] = merge(tr[a].son[1], b); pushup(a); return a; &#125; else&#123; pushdown(b); tr[b].son[0] = merge(a, tr[b].son[0]); pushup(b); return b; &#125; &#125; void split(int id, int k, int &amp;x, int &amp;y)&#123; if(!id)&#123; x = 0, y = 0; return; &#125; pushdown(id); if(tr[id].val &gt; k) y = id, split(tr[id].son[0], k, x, tr[id].son[0]); else x = id, split(tr[id].son[1], k, tr[id].son[1], y); pushup(id); &#125; inline void insert(int val)&#123; int l = 0, r = 0; split(root, val, l, r); int t = newNode(val); root = merge(merge(l, t), r); &#125; inline void del(int val)&#123; int l = 0, r = 0, t = 0; split(root, val - 1, l, t); split(t, val, t, r); t = merge(tr[t].son[0], tr[t].son[1]); root = merge(merge(l, t), r); &#125; inline int getRank(int x)&#123; int ans = 0, l = 0, r = 0; split(root, x-1, l, r); ans = tr[l].size + 1; root = merge(l, r); return ans; &#125; inline int getKth(int k)&#123; int now = root; while(now)&#123; if(tr[tr[now].son[0]].size + 1 == k) return tr[now].val; else if(tr[tr[now].son[0]].size &gt;= k) now = tr[now].son[0]; else k -= (tr[tr[now].son[0]].size + 1), now = tr[now].son[1]; &#125; return -INF; &#125; inline int getPre(int x)&#123; int ans = -INF, now = root; while(now)&#123; if(tr[now].val &gt;= x) now = tr[now].son[0]; else&#123; ans = max(ans, tr[now].val); now = tr[now].son[1]; &#125; &#125; return ans; &#125; inline int getSub(int x)&#123; int ans = INF, now = root; while(now)&#123; if(tr[now].val &lt;= x) now = tr[now].son[1]; else&#123; ans = min(ans, tr[now].val); now = tr[now].son[0]; &#125; &#125; return ans; &#125;&#125;BST;int main()&#123; srand(200127); scanf("%d", &amp;n); BST.root = BST.newNode(INF); while(n--)&#123; scanf("%d%d", &amp;opt, &amp;q); if(opt == 1) BST.insert(q); else if(opt == 2) BST.del(q); else if(opt == 3) printf("%d\n", BST.getRank(q)); else if(opt == 4) printf("%d\n", BST.getKth(q)); else if(opt == 5) printf("%d\n", BST.getPre(q)); else if(opt == 6) printf("%d\n", BST.getSub(q)); &#125; return 0;&#125; 文艺平衡树题目链接：luogu3391bzoj3223 解题思路一、Splay这道题只有区间翻转操作，线段树不好维护，只有用平衡树了。对于一次$[l,r]$的区间翻转，把$l-1$旋至根，$r+1$旋至根的右儿子，那么$[l,r]$就在根的右儿子的左儿子处了。和线段树一样，我们可以将它的左右儿子互换后打上一个翻转标记(rev ^= 1)，之后再pushdown。 Code#3123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int INF = 0x7fffffff;const int N = 100005;int n, m, ql, qr;int cnt, root;struct Splay_tree&#123; int fa, son[2], size, val; bool rev;&#125;tr[N];inline void pushup(int x)&#123; if(x)&#123; tr[x].size = 1; if(tr[x].son[0]) tr[x].size += tr[tr[x].son[0]].size; if(tr[x].son[1]) tr[x].size += tr[tr[x].son[1]].size; &#125;&#125;inline void pushdown(int x)&#123; if(tr[x].rev)&#123; if(tr[x].son[0])&#123; tr[tr[x].son[0]].rev ^= 1; swap(tr[tr[x].son[0]].son[0], tr[tr[x].son[0]].son[1]); &#125; if(tr[x].son[1])&#123; tr[tr[x].son[1]].rev ^= 1; swap(tr[tr[x].son[1]].son[0], tr[tr[x].son[1]].son[1]); &#125; tr[x].rev = 0; &#125;&#125;inline void rotate(int x, int kind)&#123; int y = tr[x].fa, z = tr[y].fa, A = tr[y].son[kind], B = tr[x].son[kind], C = tr[x].son[!kind]; tr[x].son[kind] = y, tr[x].fa = z; tr[y].son[!kind] = B, tr[y].fa = x; tr[z].son[tr[z].son[1] == y] = x; tr[B].fa = y; pushup(y), pushup(x);&#125;inline void splay(int x, int goal)&#123; if(x == goal) return; while(tr[x].fa != goal)&#123; int y = tr[x].fa, z = tr[y].fa; pushdown(z), pushdown(y), pushdown(x); int isrson1 = tr[y].son[1] == x, isrson2 = tr[z].son[1] == y; if(z == goal) rotate(x, !isrson1); else&#123; if(isrson1 == isrson2) rotate(y, !isrson2); else rotate(x, !isrson1); rotate(x, !isrson2); &#125; &#125; if(goal == 0) root = x;&#125;inline int newNode(int val, int f)&#123; cnt++; tr[cnt].val = val; tr[cnt].fa = f; tr[cnt].son[0] = tr[cnt].son[1] = 0; tr[cnt].size = 1; return cnt;&#125;int select(int x)&#123; int now = root; pushdown(now); while(tr[tr[now].son[0]].size + 1 != x)&#123; if(tr[tr[now].son[0]].size + 1 &gt; x) now = tr[now].son[0]; else&#123; x -= tr[tr[now].son[0]].size + 1; now = tr[now].son[1]; &#125; pushdown(now); &#125; return now;&#125;inline void reverse(int l, int r)&#123; splay(select(l-1), 0); splay(select(r+1), root); int t = tr[tr[root].son[1]].son[0]; tr[t].rev ^= 1; swap(tr[t].son[0], tr[t].son[1]);&#125;int build(int l, int r, int f)&#123; if(l &gt; r) return 0; int mid = (l + r) &gt;&gt; 1, x = ++cnt; tr[x].val = mid - 1; tr[x].size = 1; tr[x].fa = f; tr[x].rev = 0; tr[x].son[0] = build(l, mid-1, x); tr[x].son[1] = build(mid+1, r, x); pushup(x); return x;&#125;void print(int x)&#123; pushdown(x); if(tr[x].son[0]) print(tr[x].son[0]); if(tr[x].val &gt;= 1 &amp;&amp; tr[x].val &lt;= n) printf("%d ", tr[x].val); if(tr[x].son[1]) print(tr[x].son[1]);&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); root = build(1, n+2, 0); while(m--)&#123; scanf("%d%d", &amp;ql, &amp;qr); reverse(ql+1, qr+1); &#125; print(root); return 0;&#125; 二、非旋Treap同上。 Code#4123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int INF = 1e9;const int N = 100005;int n, m, ql, qr;struct Treap&#123; int val, size, son[2], hp; bool rev;&#125;tr[N];struct OPT_Treap&#123; int cnt, root; inline int newNode(int val)&#123; cnt++; tr[cnt].val = val; tr[cnt].hp = rand(); tr[cnt].size = 1; tr[cnt].son[0] = tr[cnt].son[1] = 0; tr[cnt].rev = 0; return cnt; &#125; inline void pushup(int id)&#123; if(!id) return; tr[id].size = 1; if(tr[id].son[0]) tr[id].size += tr[tr[id].son[0]].size; if(tr[id].son[1]) tr[id].size += tr[tr[id].son[1]].size; &#125; inline void pushdown(int id)&#123; if(!tr[id].rev) return; if(tr[id].son[0])&#123; int t = tr[id].son[0]; tr[t].rev ^= 1; swap(tr[t].son[0], tr[t].son[1]); &#125; if(tr[id].son[1])&#123; int t = tr[id].son[1]; tr[t].rev ^= 1; swap(tr[t].son[0], tr[t].son[1]); &#125; tr[id].rev ^= 1; &#125; int merge(int a, int b)&#123; if(a == 0) return b; if(b == 0) return a; if(tr[a].hp &lt;= tr[b].hp)&#123; pushdown(a); tr[a].son[1] = merge(tr[a].son[1], b); pushup(a); return a; &#125; else&#123; pushdown(b); tr[b].son[0] = merge(a, tr[b].son[0]); pushup(b); return b; &#125; &#125; void split(int id, int k, int &amp;x, int &amp;y)&#123; if(!id)&#123; x = 0, y = 0; return; &#125; pushdown(id); if(tr[tr[id].son[0]].size &gt;= k) y = id, split(tr[id].son[0], k, x, tr[id].son[0]); else x = id, split(tr[id].son[1], k - tr[tr[id].son[0]].size - 1, tr[id].son[1], y); pushup(id); &#125; inline void reverse(int l, int r)&#123; int L, t, R; split(root, l - 1, L, t); split(t, r - l + 1, t, R); tr[t].rev ^= 1; swap(tr[t].son[0], tr[t].son[1]); root = merge(merge(L, t), R); &#125; inline int build(int l, int r)&#123; if(l &gt; r) return 0; int mid = (l + r) &gt;&gt; 1; int t = newNode(mid); tr[t].son[0] = build(l, mid - 1); tr[t].son[1] = build(mid + 1, r); pushup(t); return t; &#125;&#125;BST;void print(int x)&#123; BST.pushdown(x); if(tr[x].son[0]) print(tr[x].son[0]); printf("%d ", tr[x].val); if(tr[x].son[1]) print(tr[x].son[1]);&#125;int main()&#123; srand(200127); scanf("%d%d", &amp;n, &amp;m); BST.root = BST.build(1, n); while(m--)&#123; scanf("%d%d", &amp;ql, &amp;qr); BST.reverse(ql, qr); &#125; print(BST.root); return 0;&#125; 二逼平衡树题目链接：luogu3380bzoj3196 解题思路一、线段树套Splay这道题与普通平衡树唯一的不同就在于所有查询都是区间查询，那么我们需要在平衡树外面套一层线段树以供区间查询，即线段树套平衡树。当然，并非真的要在每个线段树节点内建一颗平衡树，存一下在这个节点的平衡树的根的编号就行了。 查询区间内k的排名：在线段树上递归找查询的区间，在相应节点上的平衡树上查询比k小的数的个数，回溯时将所有答案相加得到了区间内比k小的数的个数，最后+1就是排名； 查询区间内排名为k的值：这个要麻烦一点，由于不同线段树节点上的答案不能进行合并，只能考虑二分答案，问题转化为二分出的答案在区间内的排名问题，即第一问； 修改某位置的值：修改即先删除原值，再插入新值；在线段树上找到该节点，对所经路线上所有线段树里的平衡树进行删除插入操作； 查询k在区间内的前驱：同第一问，只不过在更新答案时不是相加，而是取max； 查询k在区间内的后继：同第一问，只不过在更新答案时不是相加，而是取min。 Code#5123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((A[id].l+A[id].r)&gt;&gt;1)using namespace std;const int INF = 0x7fffffff;const int N = 50005;int n, m, a[N], opt, ql, qr, qk, qpos, tmp;struct splay&#123; int size, times, val, son[2], fa;&#125;B[(int)4e6];struct segTree&#123; int l, r, root;&#125;A[N&lt;&lt;2];struct OPT_splay&#123; int cnt; inline void pushup(int x)&#123; if(x)&#123; B[x].size = B[x].times; if(B[x].son[0]) B[x].size += B[B[x].son[0]].size; if(B[x].son[1]) B[x].size += B[B[x].son[1]].size; &#125; &#125; inline void rotate(int x, int kind)&#123; int y = B[x].fa, z = B[y].fa, a = B[y].son[kind], b = B[x].son[kind], c = B[x].son[!kind]; B[x].fa = z, B[x].son[kind] = y; B[y].fa = x, B[y].son[!kind] = b; B[z].son[B[z].son[1] == y] = x; B[b].fa = y; pushup(y), pushup(x); &#125; inline void splay(int x, int goal, int id)&#123; if(x == goal) return; while(B[x].fa != goal)&#123; int y = B[x].fa, z = B[y].fa; int isrson1 = B[y].son[1] == x, isrson2 = B[z].son[1] == y; if(z == goal) rotate(x, !isrson1); else&#123; if(isrson1 == isrson2) rotate(y, !isrson2); else rotate(x, !isrson1); rotate(x, !isrson2); &#125; &#125; if(goal == 0) A[id].root = x; &#125; inline int newNode(int val, int fa)&#123; cnt++; B[cnt].fa = fa; B[cnt].val = val; B[cnt].size = B[cnt].times = 1; B[cnt].son[0] = B[cnt].son[1] = 0; return cnt; &#125; inline int getPre(int x, int id)&#123; int now = A[id].root, res = -INF; while(now)&#123; if(B[now].val &lt; x)&#123; res = max(res, B[now].val); now = B[now].son[1]; &#125; else now = B[now].son[0]; &#125; return res; &#125; inline int getSub(int x, int id)&#123; int now = A[id].root, res = INF; while(now)&#123; if(B[now].val &gt; x)&#123; res = min(res, B[now].val); now = B[now].son[0]; &#125; else now = B[now].son[1]; &#125; return res; &#125; inline int select(int x, int id)&#123; int now = A[id].root; while(now)&#123; if(B[now].val == x) break; else if(B[now].val &gt; x) now = B[now].son[0]; else if(B[now].val &lt; x) now = B[now].son[1]; &#125; if(!now) return -1; return now; &#125; inline int getRank(int x, int id)&#123; if(select(x, id) != -1) splay(select(x, id), 0, id); else splay(select(getSub(x, id), id), 0, id); return B[B[A[id].root].son[0]].size; &#125; inline void insert(int val, int id)&#123; splay(select(getPre(val, id), id), 0, id); splay(select(getSub(val, id), id), A[id].root, id); int t = B[B[A[id].root].son[1]].son[0]; if(!t) B[B[A[id].root].son[1]].son[0] = newNode(val, B[A[id].root].son[1]); else B[t].times++, B[t].size++; pushup(B[A[id].root].son[1]); pushup(A[id].root); &#125; inline void del(int val, int id)&#123; splay(select(getPre(val, id), id), 0, id); splay(select(getSub(val, id), id), A[id].root, id); int t = B[B[A[id].root].son[1]].son[0]; if(!t || B[t].times == 0) return; B[t].times--, B[t].size--; if(B[t].times == 0) B[B[A[id].root].son[1]].son[0] = 0; pushup(B[A[id].root].son[1]); pushup(A[id].root); &#125;&#125;Splay;struct OPT_segTree&#123; void build(int id, int l, int r)&#123; A[id].root = Splay.newNode(-INF, 0); B[A[id].root].son[1] = Splay.newNode(INF, A[id].root); A[id].l = l, A[id].r = r; if(A[id].l == A[id].r) return; build(lid, l, mid); build(rid, mid+1, r); &#125; void insert(int id, int pos, int val)&#123; Splay.insert(val, id); if(A[id].l == A[id].r) return; if(pos &lt;= mid) insert(lid, pos, val); else insert(rid, pos, val); &#125; int getRank(int id, int l, int r, int x)&#123; if(A[id].l == l &amp;&amp; A[id].r == r) return Splay.getRank(x, id) - 1; if(r &lt;= mid) return getRank(lid, l, r, x); else if(l &gt; mid) return getRank(rid, l, r, x); else return getRank(lid, l, mid, x) + getRank(rid, mid+1, r, x); &#125; int getKth(int l, int r, int k)&#123; int ans = -1, L = 0, R = 1e8; while(L &lt;= R)&#123; int Mid = (L + R) &gt;&gt; 1; int t1 = getRank(1, l, r, Mid) + 1; int t2 = getRank(1, l, r, Mid+1); if(t1 &lt;= k &amp;&amp; k &lt;= t2)&#123; ans = Mid; break; &#125; if(t2 &lt; k) L = Mid+1; else if(t1 &gt; k) R = Mid-1; &#125; return ans; &#125; void modify(int id, int pos, int val)&#123; Splay.del(a[pos], id); Splay.insert(val, id); if(A[id].l == A[id].r) return; if(pos &lt;= mid) modify(lid, pos, val); else modify(rid, pos, val); &#125; int getPre(int id, int l, int r, int x)&#123; if(A[id].l == l &amp;&amp; A[id].r == r) return Splay.getPre(x, id); if(r &lt;= mid) return getPre(lid, l, r, x); else if(l &gt; mid) return getPre(rid, l, r, x); else return max(getPre(lid, l, mid, x), getPre(rid, mid+1, r, x)); &#125; int getSub(int id, int l, int r, int x)&#123; if(A[id].l == l &amp;&amp; A[id].r == r) return Splay.getSub(x, id); if(r &lt;= mid) return getSub(lid, l, r, x); else if(l &gt; mid) return getSub(rid, l, r, x); else return min(getSub(lid, l, mid, x), getSub(rid, mid+1, r, x)); &#125;&#125;Seg;int main()&#123; scanf("%d%d", &amp;n, &amp;m); Seg.build(1, 1, n); for(int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;a[i]); Seg.insert(1, i, a[i]); &#125; while(m--)&#123; scanf("%d", &amp;opt); if(opt == 3) scanf("%d%d", &amp;qpos, &amp;qk); else scanf("%d%d%d", &amp;ql, &amp;qr, &amp;qk); if(opt == 1) printf("%d\n", Seg.getRank(1, ql, qr, qk) + 1); else if(opt == 2) printf("%d\n", Seg.getKth(ql, qr, qk)); else if(opt == 3) Seg.modify(1, qpos, qk), a[qpos] = qk; else if(opt == 4) printf("%d\n", Seg.getPre(1, ql, qr, qk)); else if(opt == 5) printf("%d\n", Seg.getSub(1, ql, qr, qk)); &#125; return 0;&#125; 二、线段树套非旋Treap同上。 Code#6123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((A[id].l + A[id].r) &gt;&gt; 1)using namespace std;const int INF = 0x7fffffff;const int N = 50005;int n, m, opt, ql, qr, qk, qpos, a[N];struct Treap&#123; int val, son[2], size, hp;&#125;B[(int)4e6];struct segTree&#123; int l, r, root;&#125;A[N&lt;&lt;2];struct OPT_Treap&#123; int cnt; inline int newNode(int val)&#123; cnt++; B[cnt].val = val; B[cnt].son[0] = B[cnt].son[1] = 0; B[cnt].size = 1; B[cnt].hp = rand(); return cnt; &#125; inline void pushup(int id)&#123; if(!id) return; B[id].size = 1; if(B[id].son[0]) B[id].size += B[B[id].son[0]].size; if(B[id].son[1]) B[id].size += B[B[id].son[1]].size; &#125; int merge(int a, int b)&#123; if(a == 0) return b; if(b == 0) return a; if(B[a].hp &lt;= B[b].hp)&#123; B[a].son[1] = merge(B[a].son[1], b); pushup(a); return a; &#125; else&#123; B[b].son[0] = merge(a, B[b].son[0]); pushup(b); return b; &#125; &#125; void split(int id, int k, int &amp;x, int &amp;y)&#123; if(!id)&#123; x = 0, y = 0; return; &#125; if(B[id].val &gt; k) y = id, split(B[id].son[0], k, x, B[id].son[0]); else x = id, split(B[id].son[1], k, B[id].son[1], y); pushup(id); &#125; inline void insert(int &amp;rt, int val)&#123; int l = 0, r = 0; split(rt, val, l, r); int t = newNode(val); rt = merge(merge(l, t), r); &#125; inline void del(int &amp;rt, int val)&#123; int l = 0, r = 0, t = 0; split(rt, val - 1, l, t); split(t, val, t, r); t = merge(B[t].son[0], B[t].son[1]); rt = merge(merge(l, t), r); &#125; inline int getRank(int &amp;rt, int x)&#123; int l = 0, r = 0; split(rt, x - 1, l, r); int ans = B[l].size + 1; rt = merge(l, r); return ans; &#125; inline int getPre(int &amp;rt, int x)&#123; int now = rt, ans = -INF; while(now)&#123; if(B[now].val &lt; x)&#123; ans = max(ans, B[now].val); now = B[now].son[1]; &#125; else now = B[now].son[0]; &#125; return ans; &#125; inline int getSub(int &amp;rt, int x)&#123; int now = rt, ans = INF; while(now)&#123; if(B[now].val &gt; x)&#123; ans = min(ans, B[now].val); now = B[now].son[0]; &#125; else now = B[now].son[1]; &#125; return ans; &#125;&#125;BST;struct OPT_segTree&#123; void build(int id, int l, int r)&#123; A[id].l = l, A[id].r = r; A[id].root = BST.newNode(INF); if(A[id].l == A[id].r) return; build(lid, l, mid); build(rid, mid+1, r); &#125; void insert(int id, int pos, int val)&#123; BST.insert(A[id].root, val); if(A[id].l == A[id].r) return; if(pos &lt;= mid) insert(lid, pos, val); else insert(rid, pos, val); &#125; void modify(int id, int pos, int val)&#123; BST.del(A[id].root, a[pos]); BST.insert(A[id].root, val); if(A[id].l == A[id].r) return; if(pos &lt;= mid) modify(lid, pos, val); else modify(rid, pos, val); &#125; int query(int id, int l, int r, int x, int kind)&#123; if(A[id].l == l &amp;&amp; A[id].r == r)&#123; if(kind == 0) return BST.getRank(A[id].root, x); if(kind == 1) return BST.getPre(A[id].root, x); if(kind == 2) return BST.getSub(A[id].root, x); &#125; if(r &lt;= mid) return query(lid, l, r, x, kind); else if(l &gt; mid) return query(rid, l, r, x, kind); else&#123; if(kind == 0) return query(lid, l, mid, x, kind) + query(rid, mid+1, r, x, kind) - 1; if(kind == 1) return max(query(lid, l, mid, x, kind), query(rid, mid+1, r, x, kind)); if(kind == 2) return min(query(lid, l, mid, x, kind), query(rid, mid+1, r, x, kind)); &#125; &#125; int getKth(int l, int r, int k)&#123; int L = 0, R = 1e8, ans = 0; while(L &lt;= R)&#123; int Mid = (L + R) &gt;&gt; 1; int t1 = query(1, l, r, Mid, 0); int t2 = query(1, l, r, Mid+1, 0) - 1; if(t1 &lt;= k &amp;&amp; k &lt;= t2)&#123; ans = Mid; break; &#125; else if(t2 &lt; k) L = Mid + 1; else if(t1 &gt; k) R = Mid - 1; &#125; return ans; &#125;&#125;Seg;int main()&#123; srand(200127); scanf("%d%d", &amp;n, &amp;m); BST.cnt = 0; Seg.build(1, 1, n); for(int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;a[i]); Seg.insert(1, i, a[i]); &#125; while(m--)&#123; scanf("%d", &amp;opt); if(opt == 3) scanf("%d%d", &amp;qpos, &amp;qk); else scanf("%d%d%d", &amp;ql, &amp;qr, &amp;qk); if(opt == 1) printf("%d\n", Seg.query(1, ql, qr, qk, 0)); else if(opt == 2) printf("%d\n", Seg.getKth(ql, qr, qk)); else if(opt == 3) Seg.modify(1, qpos, qk), a[qpos] = qk; else if(opt == 4) printf("%d\n", Seg.query(1, ql, qr, qk, 1)); else if(opt == 5) printf("%d\n", Seg.query(1, ql, qr, qk, 2)); &#125; return 0;&#125; 三、树状数组套值域线段树（带修改主席树）hmm…这道题其实可以不用平衡树做，因为要求第k大，自然而然想到主席树可以做到，但这道题有修改操作，普通的维护前缀和的主席树修改一次就要把后面所有树都改了，所以修改一次的时间复杂度就是$O(NlogN)$的，显然不行。于是，带修改主席树应运而生：我们不再让值域线段树们维护前缀和了，而是让它们维护树状数组上对应的约$logN$个点，这样一次修改的时间复杂度就降到了$O(log_2^2N)$。 查询区间内k的排名：相当于找比k小的数有多少个（答案是个数+1）。在值域线段树上二分查找k时，如果往右儿子走，就把左儿子大小加进答案里去就行了； 查询区间内排名为k的值：找到树状数组里面相关的值域线段树（存进一个数组，见代码中的A[]和B[]），算出当前点左儿子大小，再决定是向左还是向右二分下去； 修改某位置的值：修改即先删除原值，再插入新值；找到树状数组里面相关的值域线段树，对每棵树都进行删除和插入操作； 查询k在区间内的前驱：查询区间内比k小的数有多少个，如果没有，输出-INF；否则输出区间内相应排名的值； 查询k在区间内的后继：查询区间内比k大的数有多少个，如果没有，输出INF；否则输出区间内相应排名的值。 涉及到值域线段树一般都要离散化，以保证空间；同时，这道题还必须动态开点才能保证空间。 Code#7纪念我的第一份超过200行的代码…123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int INF = 0x7fffffff;const int N = 50005;int n, m, a[N], t[N&lt;&lt;1], f[N&lt;&lt;1], MX, A[20], B[20];//因为有询问操作，t[]和f[]空间一定要开够!int root[N], cnt;struct Query&#123; int opt, l, r, k, pos;&#125;q[N];struct segTree&#123; int size, son[2];&#125;tr[N*15*15];inline void readin()&#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]), t[++t[0]] = a[i]; for(int i = 1; i &lt;= m; i++)&#123; scanf("%d", &amp;q[i].opt); if(q[i].opt != 3)&#123; scanf("%d%d%d", &amp;q[i].l, &amp;q[i].r, &amp;q[i].k); if(q[i].opt != 2) t[++t[0]] = q[i].k; &#125; else&#123; scanf("%d%d", &amp;q[i].pos, &amp;q[i].k); t[++t[0]] = q[i].k; &#125; &#125;&#125;inline void disc()&#123; sort(t+1, t+t[0]+1); int len = unique(t+1, t+t[0]+1) - (t+1); for(int i = 1; i &lt;= n; i++)&#123; int temp = lower_bound(t+1, t+len+1, a[i]) - t; f[temp] = a[i], a[i] = temp; MX = max(MX, temp); &#125; for(int i = 1; i &lt;= m; i++)&#123; if(q[i].opt == 2) continue; int temp = lower_bound(t+1, t+len+1, q[i].k) - t; f[temp] = q[i].k, q[i].k = temp; MX = max(MX, temp); &#125; f[MX+1] = -INF; f[MX+2] = INF;&#125;inline int lowbit(int x)&#123; return x &amp; -x; &#125;inline void init1(int x, int X[])&#123; X[0] = 0; for(int i = x; i; i -= lowbit(i))&#123; if(!root[i]) root[i] = ++cnt; X[++X[0]] = root[i]; &#125;&#125;inline void init2(int x, int X[])&#123; X[0] = 0; for(int i = x; i &lt;= n; i += lowbit(i))&#123; if(!root[i]) root[i] = ++cnt; X[++X[0]] = root[i]; &#125;&#125;inline void pushup(int id)&#123; tr[id].size = tr[tr[id].son[0]].size + tr[tr[id].son[1]].size;&#125;void insert(int &amp;id, int l, int r, int val)&#123; if(!id) id = ++cnt; if(l == r)&#123; tr[id].size++; return; &#125; int mid = (l + r) &gt;&gt; 1; if(val &lt;= mid) insert(tr[id].son[0], l, mid, val); else insert(tr[id].son[1], mid+1, r, val); pushup(id);&#125;void del(int &amp;id, int l, int r, int val)&#123; if(!id) id = ++cnt; if(l == r)&#123; if(tr[id].size &gt; 0) tr[id].size--; return; &#125; int mid = (l + r) &gt;&gt; 1; if(val &lt;= mid) del(tr[id].son[0], l, mid, val); else del(tr[id].son[1], mid+1, r, val); pushup(id);&#125;int getSmaller(int l, int r, int k)&#123; if(l == r) return 0; int mid = (l + r) &gt;&gt; 1; if(k &lt;= mid)&#123; for(int i = 1; i &lt;= A[0]; i++)&#123; if(!tr[A[i]].son[0]) tr[A[i]].son[0] = ++cnt; A[i] = tr[A[i]].son[0]; &#125; for(int i = 1; i &lt;= B[0]; i++)&#123; if(!tr[B[i]].son[0]) tr[B[i]].son[0] = ++cnt; B[i] = tr[B[i]].son[0]; &#125; return getSmaller(l, mid, k); &#125; else&#123; int res = 0; for(int i = 1; i &lt;= A[0]; i++)&#123; if(!tr[A[i]].son[1]) tr[A[i]].son[1] = ++cnt; res -= tr[tr[A[i]].son[0]].size; A[i] = tr[A[i]].son[1]; &#125; for(int i = 1; i &lt;= B[0]; i++)&#123; if(!tr[B[i]].son[1]) tr[B[i]].son[1] = ++cnt; res += tr[tr[B[i]].son[0]].size; B[i] = tr[B[i]].son[1]; &#125; return res + getSmaller(mid+1, r, k); &#125;&#125;int getBigger(int l, int r, int k)&#123; if(l == r) return 0; int mid = (l + r) &gt;&gt; 1; if(k &lt;= mid)&#123; int res = 0; for(int i = 1; i &lt;= A[0]; i++)&#123; if(!tr[A[i]].son[0]) tr[A[i]].son[0] = ++cnt; res -= tr[tr[A[i]].son[1]].size; A[i] = tr[A[i]].son[0]; &#125; for(int i = 1; i &lt;= B[0]; i++)&#123; if(!tr[B[i]].son[0]) tr[B[i]].son[0] = ++cnt; res += tr[tr[B[i]].son[1]].size; B[i] = tr[B[i]].son[0]; &#125; return res + getBigger(l, mid, k); &#125; else&#123; for(int i = 1; i &lt;= A[0]; i++)&#123; if(!tr[A[i]].son[1]) tr[A[i]].son[1] = ++cnt; A[i] = tr[A[i]].son[1]; &#125; for(int i = 1; i &lt;= B[0]; i++)&#123; if(!tr[B[i]].son[1]) tr[B[i]].son[1] = ++cnt; B[i] = tr[B[i]].son[1]; &#125; return getBigger(mid+1, r, k); &#125;&#125;int getKth(int l, int r, int k)&#123; if(l == r) return l; int lsize = 0; for(int i = 1; i &lt;= A[0]; i++) lsize -= tr[tr[A[i]].son[0]].size; for(int i = 1; i &lt;= B[0]; i++) lsize += tr[tr[B[i]].son[0]].size; int mid = (l + r) &gt;&gt; 1; if(lsize &gt;= k)&#123; for(int i = 1; i &lt;= A[0]; i++)&#123; if(!tr[A[i]].son[0]) tr[A[i]].son[0] = ++cnt; A[i] = tr[A[i]].son[0]; &#125; for(int i = 1; i &lt;= B[0]; i++)&#123; if(!tr[B[i]].son[0]) tr[B[i]].son[0] = ++cnt; B[i] = tr[B[i]].son[0]; &#125; return getKth(l, mid, k); &#125; else&#123; for(int i = 1; i &lt;= A[0]; i++)&#123; if(!tr[A[i]].son[1]) tr[A[i]].son[1] = ++cnt; A[i] = tr[A[i]].son[1]; &#125; for(int i = 1; i &lt;= B[0]; i++)&#123; if(!tr[B[i]].son[1]) tr[B[i]].son[1] = ++cnt; B[i] = tr[B[i]].son[1]; &#125; return getKth(mid+1, r, k - lsize); &#125;&#125;inline int getPre(int ql, int qr, int k)&#123; init1(ql-1, A), init1(qr, B); int rank = getSmaller(1, MX, k) + 1; init1(ql-1, A), init1(qr, B); if(rank == 1) return MX+1; else return getKth(1, MX, rank-1);&#125;inline int getSub(int ql, int qr, int k)&#123; init1(ql-1, A), init1(qr, B); int rank = getBigger(1, MX, k) + 1; init1(ql-1, A), init1(qr, B); if(rank == 1) return MX+2; else return getKth(1, MX, qr - ql + 3 - rank);&#125;int main()&#123; readin(); disc(); for(int i = 1; i &lt;= n; i++)&#123; init2(i, A); for(int j = 1; j &lt;= A[0]; j++) insert(A[j], 1, MX, a[i]); &#125; for(int i = 1; i &lt;= m; i++)&#123; switch(q[i].opt)&#123; case 1: init1(q[i].l-1, A); init1(q[i].r, B); printf("%d\n", getSmaller(1, MX, q[i].k) + 1); break; case 2: init1(q[i].l-1, A); init1(q[i].r, B); printf("%d\n", f[getKth(1, MX, q[i].k)]); break; case 3:&#123; init2(q[i].pos, A); for(int j = 1; j &lt;= A[0]; j++)&#123; del(A[j], 1, MX, a[q[i].pos]); insert(A[j], 1, MX, q[i].k); &#125; a[q[i].pos] = q[i].k; break; &#125; case 4: printf("%d\n", f[getPre(q[i].l, q[i].r, q[i].k)]); break; case 5: printf("%d\n", f[getSub(q[i].l, q[i].r, q[i].k)]); break; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>平衡树</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ZJOI2008]树的统计（树链剖分，线段树）]]></title>
    <url>%2F2018%2F04%2F29%2FZJOI2008-%E6%A0%91%E7%9A%84%E7%BB%9F%E8%AE%A1%EF%BC%88%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%EF%BC%8C%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述一棵树上有n个节点，编号分别为1到n，每个节点都有一个权值w。我们将以下面的形式来要求你对这棵树完成一些操作：I. CHANGE u t : 把结点u的权值改为tII. QMAX u v: 询问从点u到点v的路径上的节点的最大权值III. QSUM u v: 询问从点u到点v的路径上的节点的权值和注意：从点u到点v的路径上的节点包括u和v本身 输入格式输入文件的第一行为一个整数n，表示节点的个数。接下来n – 1行，每行2个整数a和b，表示节点a和节点b之间有一条边相连。接下来一行n个整数，第i个整数wi表示节点i的权值。接下来1行，为一个整数q，表示操作的总数。接下来q行，每行一个操作，以“CHANGE u t”或者“QMAX u v”或者“QSUM u v”的形式给出。 输出格式对于每个“QMAX”或者“QSUM”的操作，每行输出一个整数表示要求输出的结果。 输入样例12345678910111213141516171841 22 34 14 2 1 312QMAX 3 4QMAX 3 3QMAX 3 2QMAX 2 3QSUM 3 4QSUM 2 1CHANGE 1 5QMAX 3 4CHANGE 3 6QMAX 3 4QMAX 2 4QSUM 3 4 输出样例12345678910412210656516 说明对于100％的数据，保证$1 \leq n \leq 30000，0 \leq q \leq 200000$；中途操作中保证每个节点的权值w在$-30000$到$30000$之间。 解题思路这是一道树链剖分的模板题了。注意权值有可能为负数，所以求最大值时要初始化为-INF 复杂度$O(n \log ^2n)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const LL INF = 1e16;const int N = 30005;int n, u, v, q;char opt[10];LL a[N];struct Edge&#123; int nxt, to;&#125;edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to)&#123; edge[++edgeNum].nxt = head[from]; edge[edgeNum].to = to; head[from] = edgeNum;&#125;int size[N], fa[N], dep[N], son[N];void dfs1(int x, int f, int depth)&#123; size[x] = 1, fa[x] = f, dep[x] = depth, son[x] = 0; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(edge[i].to == f) continue; dfs1(edge[i].to, x, depth+1); size[x] += size[edge[i].to]; if(size[edge[i].to] &gt; size[son[x]]) son[x] = edge[i].to; &#125;&#125;int st[N], ed[N], belong[N], dfsClock, fun[N];void dfs2(int x, int top)&#123; st[x] = ++dfsClock, fun[dfsClock] = x; belong[x] = top; if(son[x]) dfs2(son[x], top); for(int i = head[x]; i; i = edge[i].nxt)&#123; if(edge[i].to == fa[x] || edge[i].to == son[x]) continue; dfs2(edge[i].to, edge[i].to); &#125; ed[x] = dfsClock;&#125;#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((tr[id].l+tr[id].r)&gt;&gt;1)struct segTree&#123; int l, r; LL mx, sum; segTree()&#123; l = r = 0; sum = 0ll; mx = -INF; &#125;&#125;tr[N&lt;&lt;2];struct &#123; inline void pushup(int id)&#123; tr[id].mx = max(tr[lid].mx, tr[rid].mx); tr[id].sum = tr[lid].sum + tr[rid].sum; &#125; void build(int id, int l, int r)&#123; tr[id].l = l, tr[id].r = r; if(tr[id].l == tr[id].r)&#123; tr[id].mx = tr[id].sum = a[fun[l]]; return; &#125; build(lid, l, mid); build(rid, mid+1, r); pushup(id); &#125; LL query(int id, int l, int r, int k)&#123; if(tr[id].l == l &amp;&amp; tr[id].r == r) return k == 0 ? tr[id].mx : tr[id].sum; if(r &lt;= mid) return query(lid, l, r, k); else if(l &gt; mid) return query(rid, l, r, k); else return k == 0 ? max(query(lid, l, mid, k), query(rid, mid+1, r, k)) : query(lid, l, mid, k) + query(rid, mid+1, r, k); &#125; void modify(int id, int pos, LL v)&#123; if(tr[id].l == tr[id].r)&#123; tr[id].sum = tr[id].mx = v; return; &#125; if(pos &lt;= mid) modify(lid, pos, v); else modify(rid, pos, v); pushup(id); &#125;&#125;seg;LL query(int u, int v, int k)&#123; LL res = k == 0 ? -INF : 0; while(belong[u] != belong[v])&#123; if(dep[belong[u]] &lt; dep[belong[v]]) swap(u, v); res = k == 0 ? max(res, seg.query(1, st[belong[u]], st[u], 0)) : res + seg.query(1, st[belong[u]], st[u], 1); u = fa[belong[u]]; &#125; if(dep[u] &gt; dep[v]) swap(u, v); res = k == 0 ? max(res, seg.query(1, st[u], st[v], 0)) : res + seg.query(1, st[u], st[v], 1); return res;&#125;int main()&#123; scanf("%d", &amp;n); for(int i = 1; i &lt; n; i++)&#123; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v); addEdge(v, u); &#125; for(int i = 1; i &lt;= n; i++) scanf("%lld", &amp;a[i]); dfs1(1, 1, 1); dfs2(1, 1); seg.build(1, 1, n); scanf("%d", &amp;q); while(q--)&#123; scanf("%s%d%d", opt, &amp;u, &amp;v); if(opt[0] == 'C') seg.modify(1, st[u], 1ll*v); else if(opt[1] == 'M') printf("%lld\n", query(u, v, 0)); else if(opt[1] == 'S') printf("%lld\n", query(u, v, 1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>数据结构</category>
        <category>线段树</category>
        <category>树</category>
        <category>树链剖分</category>
      </categories>
      <tags>
        <tag>ZJOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDOI2011]染色（树链剖分，线段树）]]></title>
    <url>%2F2018%2F04%2F28%2FSDOI2011-%E6%9F%93%E8%89%B2%EF%BC%88%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%EF%BC%8C%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目Description给定一棵有n个节点的无根树和m个操作，操作有2类：1、将节点a到节点b路径上所有点都染成颜色c；2、询问节点a到节点b路径上的颜色段数量（连续相同颜色被认为是同一段），如“112221”由3段组成：“11”、“222”和“1”。请你写一个程序依次完成这m个操作。 Input第一行包含2个整数n和m，分别表示节点数和操作数；第二行包含n个正整数表示n个节点的初始颜色下面 n-1 行每行包含两个整数x和y，表示x和y之间有一条无向边。下面 m 行每行描述一个操作：“C a b c”表示这是一个染色操作，把节点a到节点b路径上所有点（包括a和b）都染成颜色c；“Q a b”表示这是一个询问操作，询问节点a到节点b（包括a和b）路径上的颜色段数量。 Output对于每个询问操作，输出一行答案。 Sample Input1234567891011126 52 2 1 2 1 11 21 32 42 52 6Q 3 5C 2 1 1Q 3 5C 5 1 2Q 3 5 Sample Output123312 HINT$N \leq 10^5, M \leq 10^5$，所有的颜色C为整数且在$[0, 10^9]$之间。 解题思路这道题思路应该是很好想到的——树链剖分+线段树显然，合并两个颜色段时，如果合并点两侧颜色相同，那么颜色段数量为左右两段数量之和再减一，否则就是它们的和。根据这个基本性质——线段树维护3个值：颜色段数量(cnt)、左端颜色(lcol)、右端颜色(rcol)，于是tr[id].cnt = tr[lid].cnt + tr[rid].cnt - (tr[lid].rcol == tr[rid].lcol);树链剖分询问时（即往上“跳”时），记录一下上一次询问的端点颜色，如果本次询问的相应端点颜色在合并点处与上次询问端点颜色相等，就要减一。至此本题解决。 复杂度$O(n\log ^2n)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 100005;int n, m, a[N], u, v, qa, qb, qc;char opt[2];struct Edge&#123; int nxt, to;&#125;edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to)&#123; edge[++edgeNum].nxt = head[from]; edge[edgeNum].to = to; head[from] = edgeNum;&#125;int fa[N], dep[N], size[N], son[N];void dfs1(int x, int f, int depth)&#123; fa[x] = f, dep[x] = depth, size[x] = 1, son[x] = 0; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(edge[i].to == f) continue; dfs1(edge[i].to, x, depth+1); size[x] += size[edge[i].to]; if(size[edge[i].to] &gt; size[son[x]]) son[x] = edge[i].to; &#125;&#125;int belong[N], st[N], ed[N], dfsClock, fun[N];void dfs2(int x, int top)&#123; st[x] = ++dfsClock, fun[dfsClock] = x; belong[x] = top; if(son[x]) dfs2(son[x], top); for(int i = head[x]; i; i = edge[i].nxt)&#123; if(edge[i].to == fa[x] || edge[i].to == son[x]) continue; dfs2(edge[i].to, edge[i].to); &#125; ed[x] = dfsClock;&#125;#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((tr[id].l+tr[id].r)&gt;&gt;1)struct segTree&#123; int l, r, lcol, rcol, cnt, cov; segTree()&#123; l = r = lcol = rcol = cnt = cov = 0; &#125;&#125;tr[N&lt;&lt;2];struct &#123; inline void pushup(int id)&#123; tr[id].cnt = tr[lid].cnt + tr[rid].cnt - (tr[lid].rcol == tr[rid].lcol); tr[id].lcol = tr[lid].lcol; tr[id].rcol = tr[rid].rcol; &#125; inline void pushdown(int id)&#123; if(tr[id].l == tr[id].r) return; if(tr[id].cov)&#123; int t = tr[id].cov; tr[lid].cov = tr[rid].cov = t; tr[lid].lcol = tr[lid].rcol = t; tr[rid].lcol = tr[rid].rcol = t; tr[lid].cnt = tr[rid].cnt = 1; tr[id].cov = 0; &#125; &#125; void build(int id, int l, int r)&#123; tr[id].l = l, tr[id].r = r; if(tr[id].l == tr[id].r)&#123; tr[id].cnt = 1; tr[id].lcol = tr[id].rcol = a[fun[l]]; return; &#125; build(lid, l, mid); build(rid, mid+1, r); pushup(id); &#125; void cover(int id, int l, int r, int c)&#123; pushdown(id); if(tr[id].l == l &amp;&amp; tr[id].r == r)&#123; tr[id].cov = c; tr[id].cnt = 1; tr[id].lcol = tr[id].rcol = c; return; &#125; if(r &lt;= mid) cover(lid, l, r, c); else if(l &gt; mid) cover(rid, l, r, c); else cover(lid, l, mid, c), cover(rid, mid+1, r, c); pushup(id); &#125; segTree query(int id, int l, int r)&#123; pushdown(id); if(tr[id].l == l &amp;&amp; tr[id].r == r) return tr[id]; if(r &lt;= mid) return query(lid, l, r); else if(l &gt; mid) return query(rid, l, r); else&#123; segTree t1 = query(lid, l, mid), t2 = query(rid, mid+1, r), t; t.cnt = t1.cnt + t2.cnt - (t1.rcol == t2.lcol); t.lcol = t1.lcol, t.rcol = t2.rcol; return t; &#125; &#125;&#125;seg;void cover(int u, int v, int c)&#123; while(belong[u] != belong[v])&#123; if(dep[belong[u]] &lt; dep[belong[v]]) swap(u, v); seg.cover(1, st[belong[u]], st[u], c); u = fa[belong[u]]; &#125; if(dep[u] &gt; dep[v]) swap(u, v); seg.cover(1, st[u], st[v], c);&#125;int query(int u, int v)&#123; int ans = 0, lastu = 0, lastv = 0; while(belong[u] != belong[v])&#123; if(dep[belong[u]] &lt; dep[belong[v]]) swap(u, v), swap(lastu, lastv); segTree t = seg.query(1, st[belong[u]], st[u]); ans += t.cnt - (t.rcol == lastu); lastu = t.lcol; u = fa[belong[u]]; &#125; if(dep[u] &gt; dep[v]) swap(u, v), swap(lastu, lastv); segTree t = seg.query(1, st[u], st[v]); ans += t.cnt - (t.lcol == lastu) - (t.rcol == lastv); return ans;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]), a[i]++; for(int i = 1; i &lt; n; i++)&#123; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v); addEdge(v, u); &#125; dfs1(1, 1, 1); dfs2(1, 1); seg.build(1, 1, n); while(m--)&#123; scanf("%s", opt); if(opt[0] == 'C')&#123; scanf("%d%d%d", &amp;qa, &amp;qb, &amp;qc); qc++; cover(qa, qb, qc); &#125; else if(opt[0] == 'Q')&#123; scanf("%d%d", &amp;qa, &amp;qb); printf("%d\n", query(qa, qb)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>数据结构</category>
        <category>线段树</category>
        <category>树</category>
        <category>树链剖分</category>
      </categories>
      <tags>
        <tag>SDOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点分治学习笔记]]></title>
    <url>%2F2018%2F04%2F22%2F%E7%82%B9%E5%88%86%E6%B2%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[简介点分治主要解决树上路径问题，其主要思想是把一颗有根树以根为分治点分为一个森林（其实就是各个子树），解决经过当前根的路径后在子树里继续分治，从而将问题“分而治之”。 这里面，根的选择非常重要。为了保证复杂度，我们的分治点应该尽可能的“居中”，所以分治点一般选择正在处理的树的重心。 套路 找到当前树的重心作为根 解决通过这个根的路径的答案（一般有两种方法，一种是通过与子树容斥，一种是直接计算子树贡献） 递归解决子树 实现求重心12345678910111213//root = 0, mxson[0] = INF, sum = n;//root = 0, mxson[0] = INF, sum = size[edge[i].to];void findRoot(int x, int f)&#123; size[x] = 1, mxson[x] = 0; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to] || edge[i].to == f) continue; findRoot(edge[i].to, x); size[x] += size[edge[i].to]; mxson[x] = max(mxson[x], size[edge[i].to]); &#125; mxson[x] = max(mxson[x], sum - size[x]); if(mxson[x] &lt; mxson[root]) root = x;&#125; size[]是子树大小，mxson[]是最大子树大小，root是重心，sum是当前整颗树的大小注意每次 findRoot() 前要初始化 root 和 sum 分治计算1234567891011void solve(int x)&#123; cal(x);//如果此处计算时将子树中一些不合法的路径的贡献也算进去了，那么需要容斥，即在下方*处减掉子树贡献；如果不容斥，就直接利用每颗子树的信息计算答案 vis[x] = 1; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to]) continue; cal(edge[i].to);//* root = 0, sum = size[edge[i].to], mxson[0] = INF; findRoot(edge[i].to, 0); solve(root); &#125;&#125; vis[]标记此点是否计算过，cal()计算以x为根、经过根的路径的答案 注意事项不要再分治时用memset O(n) 地进行初始化，否则点分治好不容易保证的复杂度就被毁了。 练习poj1741 tree题意给一棵树，边有边权，问两点之间的距离小于等于K的点对有多少个。题解点分治时用容斥做：计算以x为根的子树时直接将求得的dis排序后O(n)求答案，然后再减去每个子树中被统计了的不合法答案Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int INF = 1e9;const int N = 10005;int n, k, u, v, p;struct Edge&#123; int nxt, to, dis;&#125;edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to, int dis)&#123; edge[++edgeNum].nxt = head[from]; edge[edgeNum].to = to; edge[edgeNum].dis = dis; head[from] = edgeNum;&#125;bool vis[N];int root, sum, size[N], mxson[N];void findRoot(int x, int f)&#123; size[x] = 1, mxson[x] = 0; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(edge[i].to == f || vis[edge[i].to]) continue; findRoot(edge[i].to, x); size[x] += size[edge[i].to]; mxson[x] = max(mxson[x], size[edge[i].to]); &#125; mxson[x] = max(mxson[x], sum - size[x]); if(mxson[x] &lt; mxson[root]) root = x;&#125;int dis[N], ans;void getDis(int x, int f, int d)&#123; dis[++dis[0]] = d; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(edge[i].to == f || vis[edge[i].to]) continue; getDis(edge[i].to, x, d + edge[i].dis); &#125;&#125;int cal(int x, int d)&#123; int res = 0; for(int i = 1; i &lt;= dis[0]; i++) dis[i] = 0; dis[0] = 0; getDis(x, 0, d); sort(dis+1, dis+dis[0]+1); int l = 1, r = dis[0]; while(l &lt; r)&#123; if(dis[l] + dis[r] &lt;= k) res += r - l, l++; else r--; &#125; return res;&#125;void solve(int x)&#123; ans += cal(x, 0); vis[x] = 1; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to]) continue; ans -= cal(edge[i].to, edge[i].dis); root = 0, mxson[0] = INF, sum = size[edge[i].to]; findRoot(edge[i].to, 0); solve(root); &#125;&#125;void init()&#123; memset(edge, 0, sizeof edge); memset(head, 0, sizeof head); edgeNum = 0; root = sum = ans = 0; memset(size, 0, sizeof size); memset(mxson, 0, sizeof mxson); memset(vis, 0, sizeof vis);&#125;int main()&#123; while(1)&#123; scanf("%d%d", &amp;n, &amp;k); if(n == 0 &amp;&amp; k == 0) break; init(); for(int i = 1; i &lt; n; i++)&#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;p); addEdge(u, v, p); addEdge(v, u, p); &#125; sum = n, root = 0, mxson[0] = INF; findRoot(1, 0); solve(root); printf("%d\n", ans); &#125; return 0;&#125; luogu3806 【模板】点分治1题意给定一棵有n个点的树，多次询问树上距离为k的点对是否存在。题解和上一题差不多，也是容斥，只不过我们把所有k的答案一次性求出来，每次询问O(1)回答。Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;map&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int INF = 1e9;const int N = 10005;int n, m, k[105], u, v, p;struct Edge&#123; int nxt, to, dis;&#125;edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to, int dis)&#123; edge[++edgeNum].nxt = head[from]; edge[edgeNum].to = to; edge[edgeNum].dis = dis; head[from] = edgeNum;&#125;int size[N], mxson[N], dis[N], root, sum;bool vis[N];map&lt;int, int&gt; cnt;void findRoot(int x, int f)&#123; size[x] = 1, mxson[x] = 0; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to] || edge[i].to == f) continue; findRoot(edge[i].to, x); size[x] += size[edge[i].to]; mxson[x] = max(mxson[x], size[edge[i].to]); &#125; mxson[x] = max(mxson[x], sum - size[x]); if(mxson[x] &lt; mxson[root]) root = x;&#125;void getDis(int x, int f, int d)&#123; dis[++dis[0]] = d; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(edge[i].to == f || vis[edge[i].to]) continue; getDis(edge[i].to, x, d + edge[i].dis); &#125;&#125;void cal(int x, int d, int fl)&#123; for(int i = 1; i &lt;= dis[0]; i++) dis[i] = 0; dis[0] = 0; getDis(x, 0, d); sort(dis+1, dis+dis[0]+1); for(int i = 1; i &lt;= dis[0]; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(dis[i] + dis[i] &gt; k[j]) continue; int l = lower_bound(dis+i, dis+dis[0]+1, k[j]-dis[i]) - dis; if(dis[l] + dis[i] != k[j]) continue; int r = upper_bound(dis+i, dis+dis[0]+1, k[j]-dis[i]) - dis; cnt[k[j]] += (r - l) * fl; &#125; &#125;&#125;void solve(int x)&#123; cal(x, 0, 1); vis[x] = 1; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to]) continue; cal(edge[i].to, edge[i].dis, -1); root = 0, sum = size[edge[i].to], mxson[0] = INF; findRoot(edge[i].to, 0); solve(root); &#125;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt; n; i++)&#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;p); addEdge(u, v, p); addEdge(v, u, p); &#125; for(int i = 1; i &lt;= m; i++) scanf("%d", &amp;k[i]); root = 0, sum = n, mxson[0] = INF; findRoot(1, 0); solve(root); for(int i = 1; i &lt;= m; i++) puts(cnt[k[i]] &gt; 0 ? "AYE" : "NAY"); return 0;&#125; [国家集训队] 聪聪可可题意求边权和是3的倍数的点对个数题解思路和上面两道题大同小异，而且更简单了：不用对dis排序，只需记录下距当前根dis为0,1,2的点的个数(cnt)，则答案就是$cnt[0] * cnt[0] + cnt[1] * cnt[2] * 2$当然这样做也要容斥Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 20005;const int INF = 1e9;int n, u, v, p;struct Edge&#123; int nxt, to, dis;&#125;edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to, int dis)&#123; edge[++edgeNum].nxt = head[from]; edge[edgeNum].to = to; edge[edgeNum].dis = dis; head[from] = edgeNum;&#125;int root, mxson[N], sum, size[N];bool vis[N];void findRoot(int x, int f)&#123; size[x] = 1, mxson[x] = 0; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to] || edge[i].to == f) continue; findRoot(edge[i].to, x); size[x] += size[edge[i].to]; mxson[x] = max(mxson[x], size[edge[i].to]); &#125; mxson[x] = max(mxson[x], sum - size[x]); if(mxson[x] &lt; mxson[root]) root = x;&#125;int cnt[3];void getDis(int x, int f, int d)&#123; cnt[d%3]++; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to] || edge[i].to == f) continue; getDis(edge[i].to, x, (d + edge[i].dis) % 3); &#125;&#125;int cal(int x, int d)&#123; cnt[0] = cnt[1] = cnt[2] = 0; getDis(x, 0, d); return cnt[0] * cnt[0] + cnt[1] * cnt[2] * 2;&#125;int ans;void solve(int x)&#123; ans += cal(x, 0); vis[x] = 1; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to]) continue; ans -= cal(edge[i].to, edge[i].dis % 3); root = 0, sum = size[edge[i].to], mxson[0] = INF; findRoot(edge[i].to, 0); solve(root); &#125;&#125;int gcd(int a, int b)&#123; return b == 0 ? a : gcd(b, a % b);&#125;int main()&#123; scanf("%d", &amp;n); for(int i = 1; i &lt; n; i++)&#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;p); addEdge(u, v, p % 3); addEdge(v, u, p % 3); &#125; root = 0, mxson[0] = INF, sum = n; findRoot(1, 0); solve(root); int g = gcd(ans, n*n); printf("%d/%d", ans / g, n * n / g); return 0;&#125; [IOI]Race题意给一棵树，每条边有权。求一条简单路径，权值和等于 K ，且边的数量最小。输出最小边数题解发现这道不能容斥…所以我们想办法通过子树信息直接计算经过分治点的路径的答案记$tmp[i]$为当前子树中，路径长为$i$的最小边数，于是对于当前根$x$，我们每次遍历它的子树，先用$tmp[]$和正在遍历的子树更新答案（代码中的 $updAns()$ 函数），再用正在遍历的这颗子树更新$tmp[]$（代码中的 $updTmp()$ 函数），这样就保证了不会把不合法的路径算进来Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int INF = 1e9;const int N = 200005;int n, k, u, v, p;struct Edge&#123; int nxt, to, dis;&#125;edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to, int dis)&#123; edge[++edgeNum].nxt = head[from]; edge[edgeNum].to = to; edge[edgeNum].dis = dis; head[from] = edgeNum;&#125;int root, mxson[N], size[N], sum;bool vis[N];void findRoot(int x, int f)&#123; size[x] = 1, mxson[x] = 0; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to] || edge[i].to == f) continue; findRoot(edge[i].to, x); size[x] += size[edge[i].to]; mxson[x] = max(mxson[x], size[edge[i].to]); &#125; mxson[x] = max(mxson[x], sum - size[x]); if(mxson[x] &lt; mxson[root]) root = x;&#125;int ans = INF, tmp[1000005];void updTmp(int x, int f, int dis, int d)&#123; if(dis &lt;= k) tmp[dis] = min(tmp[dis], d); for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to] || edge[i].to == f) continue; updTmp(edge[i].to, x, dis + edge[i].dis, d + 1); &#125;&#125;void updAns(int x, int f, int dis, int d)&#123; if(dis &lt;= k) ans = min(ans, d + tmp[k-dis]); for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to] || edge[i].to == f) continue; updAns(edge[i].to, x, dis + edge[i].dis, d + 1); &#125;&#125;void clearTmp(int x, int f, int dis)&#123; if(dis &lt;= k) tmp[dis] = INF; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to] || edge[i].to == f) continue; clearTmp(edge[i].to, x, dis + edge[i].dis); &#125;&#125;void solve(int x)&#123; vis[x] = 1, tmp[0] = 0; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to]) continue; updAns(edge[i].to, x, edge[i].dis, 1); updTmp(edge[i].to, x, edge[i].dis, 1); &#125; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to]) continue; clearTmp(edge[i].to, x, edge[i].dis); &#125; for(int i = head[x]; i; i = edge[i].nxt)&#123; if(vis[edge[i].to]) continue; root = 0, sum = size[edge[i].to]; findRoot(edge[i].to, 0); solve(root); &#125;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;k); for(int i = 1; i &lt; n; i++)&#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;p); addEdge(u+1, v+1, p); addEdge(v+1, u+1, p); &#125; for(int i = 0; i &lt;= k; i++) tmp[i] = INF; root = 0, mxson[0] = INF, sum = n; findRoot(1, 0); solve(root); if(ans == INF) puts("-1"); else printf("%d\n", ans); return 0;&#125; —— 完 ——]]></content>
      <categories>
        <category>图论</category>
        <category>树</category>
        <category>点分治</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2017 D1 T2]时间复杂度（栈，模拟）]]></title>
    <url>%2F2018%2F04%2F14%2FNOIP2017-D1-T2-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%88%E6%A0%88%EF%BC%8C%E6%A8%A1%E6%8B%9F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并 给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序， 于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。 A++语言的循环结构如下：123F i x y 循环体E 其中F i x y表示新建变量 $i$（变量 $i$ 不可与未被销毁的变量重名）并初始化为 $x$， 然后判断 $i$ 和 $y$ 的大小关系，若 $i$ 小于等于 $y$ 则进入循环，否则不进入。每次循环结束后 $i$ 都会被修改成 $i +1$，一旦 $i$ 大于 $y$ 终止循环。 $x$ 和 $y$ 可以是正整数（$x$ 和 $y$ 的大小关系不定）或变量 $n$。$n$ 是一个表示数据规模的变量，在时间复杂度计算中需保留该变量而不能将其视为常数，该数远大于 100。 “E”表示循环体结束。循环体结束时，这个循环体新建的变量也被销毁。 注：本题中为了书写方便，在描述复杂度时，使用大写英文字母“O”表示通常意义下“Θ”的概念。 输入输入文件第一行一个正整数 $t$，表示有 $t$（$t \le 10$）个程序需要计算时间复杂度。 每个程序我们只需抽取其中 F i x y和E即可计算时间复杂度。注意：循环结构允许嵌套。 接下来每个程序的第一行包含一个正整数 $L$ 和一个字符串，$L$ 代表程序行数，字符串表示这个程序的复杂度，O(1)表示常数复杂度，O(n^w)表示复杂度为$n^w$，其中w是一个小于100的正整数（输入中不包含引号），输入保证复杂度只有O(1)和O(n^w) 两种类型。 接下来 $L$ 行代表程序中循环结构中的F i x y或者 E。 程序行若以F开头，表示进入一个循环，之后有空格分离的三个字符（串）i x y， 其中 $i$ 是一个小写字母（保证不为$n$），表示新建的变量名，$x$ 和 $y$ 可能是正整数或 $n$ ，已知若为正整数则一定小于 100。 程序行若以E开头，则表示循环体结束。 输出输出文件共 $t$ 行，对应输入的 $t$ 个程序，每行输出”Yes”或”No”或者”ERR”（输出中不包含引号），若程序实际复杂度与输入给出的复杂度一致则输出”Yes”，不一致则输出”No”，若程序有语法错误（其中语法错误只有: ① F 和 E 不匹配 ②新建的变量与已经存在但未被销毁的变量重复两种情况），则输出”ERR” 。 注意：即使在程序不会执行的循环体中出现了语法错误也会编译错误，要输出 ERR。 样例输入1234567891011121314151617181920212223242526272829303132333482 O(1)F i 1 1E2 O(n^1)F x 1 nE1 O(1)F x 1 n4 O(n^2)F x 5 nF y 10 nEE4 O(n^2)F x 9 nEF y 2 nE4 O(n^1)F x 9 nF y n 4EE4 O(1)F y n 4F x 9 nEE4 O(n^2)F x 1 nF x 1 10EE 样例输出12345678YesYesERRYesNoYesYesERR 输入输出样例解释第一个程序 $i$ 从 1 到 1 是常数复杂度。第二个程序 $x$ 从 1 到 $n$ 是 $n$ 的一次方的复杂度。第三个程序有一个 F 开启循环却没有 E 结束，语法错误。第四个程序二重循环，$n$ 的平方的复杂度。第五个程序两个一重循环，$n$ 的一次方的复杂度。第六个程序第一重循环正常，但第二重循环开始即终止（因为$n$远大于100，100大于4）。第七个程序第一重循环无法进入，故为常数复杂度。第八个程序第二重循环中的变量 $x$ 与第一重循环中的变量重复，出现语法错误②，输出 ERR。 数据规模与约定对于 30%的数据：不存在语法错误，数据保证小明给出的每个程序的前 $L/2$ 行一定为以 F 开头的语句，第 $L/2+1$ 行至第 $L$ 行一定为以 $E$ 开头的语句，$L \le 10$，若 $x$、$y$ 均 为整数，$x$ 一定小于 $y$，且只有 $y$ 有可能为 $n$。对于 50%的数据：不存在语法错误，$L \le 100$，且若 $x$、$y$ 均为整数，$x$ 一定小于 $y$， 且只有 $y$ 有可能为 $n$。对于 70%的数据：不存在语法错误，$L \le 100$。对于 100%的数据：$L \le 100$。 解题思路由于循环必须要让F与E配对，联想到括号匹配问题，所以用栈来模拟。为了方便计算，我在栈里维护了三个值，分别表示当前循环所用变量名、程序执行到当前循环时的复杂度、当前循环是否处于被跳过的循环之中（即程序不会执行到）。在压栈时维护一下这三个值就好了，最后的复杂度即为最大的可被执行到的复杂度。最后，注意一下关于字符串的读入处理就好了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int T, L, kind, w;//kind == 1:O(1); kind == 2: O(n^w)int top, ans;char com[100], opt[100];bool used[1000], err;struct Node&#123; char ch; int c;//执行至此的时间复杂度 bool dir;//是否处于直接跳过的循环中 &#125;sta[1000];void solve()&#123; scanf("%d ", &amp;L); cin.getline(com, 99); if(com[2] == '1') kind = 1; else&#123; int now = 4; while(com[now] &gt;= '0' &amp;&amp; com[now] &lt;= '9')&#123; w = w * 10 + com[now] - '0'; now++; &#125; kind = 2; &#125; for(int i = 1; i &lt;= L; i++)&#123; cin.getline(opt, 99); if(err) continue; if(opt[0] == 'F')&#123; if(used[opt[2]])&#123; err = 1; continue; &#125; used[opt[2]] = 1; int now = 4, l = 0, r = 0, pre = 0, nxt = 0; while((opt[now] &gt;= '0' &amp;&amp; opt[now] &lt;= '9') || opt[now] == 'n')&#123; if(opt[now] == 'n') pre = 1; else l = l * 10 + opt[now] - '0'; now++; &#125; now++; while((opt[now] &gt;= '0' &amp;&amp; opt[now] &lt;= '9') || (opt[now] == 'n'))&#123; if(opt[now] == 'n') nxt = 1; else r = r * 10 + opt[now] - '0'; now++; &#125; if(pre == 1 &amp;&amp; nxt == 1)&#123; sta[top+1] = (Node)&#123;opt[2], sta[top].c, sta[top].dir&#125;; top++; if(sta[top].dir == 0) ans = max(ans, sta[top].c); &#125; else if(pre == 1 &amp;&amp; nxt == 0)&#123; sta[top+1] = (Node)&#123;opt[2], sta[top].c, 1&#125;; top++; &#125; else if(pre == 0 &amp;&amp; nxt == 1)&#123; sta[top+1] = (Node)&#123;opt[2], sta[top].c + 1, sta[top].dir&#125;; top++; if(sta[top].dir == 0) ans = max(ans, sta[top].c); &#125; else if(pre == 0 &amp;&amp; nxt == 0)&#123; if(l &lt;= r)&#123; sta[top+1] = (Node)&#123;opt[2], sta[top].c, sta[top].dir&#125;; top++; if(sta[top].dir == 0) ans = max(ans, sta[top].c); &#125; else&#123; sta[top+1] = (Node)&#123;opt[2], sta[top].c, 1&#125;; top++; &#125; &#125; &#125; else if(opt[0] == 'E')&#123; if(top == 0) err = 1; else&#123; used[sta[top].ch] = 0; top--; &#125; &#125; &#125; if(top) err = 1; if(err)&#123; puts("ERR"); return; &#125; if(kind == 1 &amp;&amp; ans == 0)&#123; puts("Yes"); return; &#125; if(kind == 2 &amp;&amp; w == ans)&#123; puts("Yes"); return; &#125; puts("No"); return;&#125;void init()&#123; memset(sta, 0, sizeof sta); top = 0; memset(com, 0, sizeof com); memset(opt, 0, sizeof opt); memset(used, 0, sizeof used); err = 0; ans = 0; kind = w = 0;&#125;int main()&#123; scanf("%d", &amp;T); while(T--)&#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>模拟</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2017 D1 T1]小凯的疑惑（数论）]]></title>
    <url>%2F2018%2F04%2F14%2FNOIP2017-D1-T1-%E5%B0%8F%E5%87%AF%E7%9A%84%E7%96%91%E6%83%91%EF%BC%88%E6%95%B0%E8%AE%BA%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述小凯手中有两种面值的金币，两种面值均为正整数且彼此互素。每种金币小凯都有 无数个。在不找零的情况下，仅凭这两种金币，有些物品他是无法准确支付的。现在小凯想知道在无法准确支付的物品中，最贵的价值是多少金币？注意：输入数据保证存在小凯无法准确支付的商品。 输入输入数据仅一行，包含两个正整数 $a$ 和 $ b $，它们之间用一个空格隔开，表示小凯手 中金币的面值。 输出输出文件仅一行，一个正整数 $ N $，表示不找零的情况下，小凯用手中的金币不能准确支付的最贵的物品的价值。 样例输入13 7 样例输出111 样例说明小凯手中有面值为3和7的金币无数个，在不找零的前提下无法准确支付价值为1、 2、4、5、8、11 的物品，其中最贵的物品价值为 11，比 11 贵的物品都能买到，比如：$ 12 = 3 \times 4 + 7 \times 0 $$ 13 = 3 \times 2 + 7 \times 1 $$ 14 = 3 \times 0 + 7 \times 2 $$ 15 = 3 \times 5 + 7 \times 0 $ 数据范围与约定对于 30%的数据： $ 1 \le a,b \le 50 $。对于 60%的数据： $ 1 \le a,b \le 10^4 $。对于 100%的数据：$ 1 \le a,b \le 10^9 $。 解题思路因为$ (a,b) = 1 $，所以$ \{a, 2a, 3a, …, (b-1)a\} $为模$ b $的完全剩余系。设$ T $是一个$ a, b $无法表示的数且$ T \equiv ka(mod \ b) $，$ (1 \le k \le b-1) $.若$ T \ge ka $，则$ T $一定可以表示为$ ka+nb $，$ (n \ge 0) $，所以$ T &lt; ka $，则此时$ T $最大为$ ka-b $.显然，当$ k $最大时$ T $最大，所以$ T = (b-1)a-b = ab - a - b $. Code123456789#include&lt;cstdio&gt;using namespace std;typedef long long LL;LL a, b;int main()&#123; scanf("%lld%lld", &amp;a, &amp;b); printf("%lld", a * b - a - b); return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello, world!]]></title>
    <url>%2F2018%2F04%2F07%2FHello-world-0%2F</url>
    <content type="text"><![CDATA[搞了一个下午+一个晚上，终于把hexo+github博客搭建起来了……（尚待后续优化） 这个博客用于几个板块：OI/ACM 学习笔记（主要），学习总结，随笔，其他 12break?continue!]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
